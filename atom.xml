<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Easygo_Space</title>
  
  <subtitle>The quick brown fox jumps over the lazy dog.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mlone.top/"/>
  <updated>2019-09-28T09:13:24.338Z</updated>
  <id>https://mlone.top/</id>
  
  <author>
    <name>easy go</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>反射—Java高级开发必须懂的</title>
    <link href="https://mlone.top/2019/09/28/%E5%8F%8D%E5%B0%84%E2%80%94Java%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E6%87%82%E7%9A%84/"/>
    <id>https://mlone.top/2019/09/28/反射—Java高级开发必须懂的/</id>
    <published>2019-09-28T08:54:21.000Z</published>
    <updated>2019-09-28T09:13:24.338Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>原文地址：<a href="http://www.cnblogs.com/rocomp/p/4781987.html" target="_blank" rel="noopener">www.cnblogs.com/rocomp/p/4781987.html</a></p><br><a id="more"></a><p></p><p>　　<br>　　理解反射对学习Java框架有很大的帮助，如Spring框架的核心就是使用Java反射实现的，而且对做一些Java底层的操作会很有帮助。 </p><p>　　</p><h2 id="一、Class类的使用"><a href="#一、Class类的使用" class="headerlink" title="一、Class类的使用"></a>一、Class类的使用</h2><p>　　1、万事万物皆对象，（当然，基本数据类型，静态成员不是面向对象（属于类的）），所以我们创建的每一个类也都是对象，即类本身是java.lang.Class类的实例对象，但是这些对象都不需要new出来，因为java.lang.Class类的构造方法是私有的</p><p>　　2、任何一个类都是Class类的实例对象，这个实例对象有三种表示方式：(我们新建一个Student类)</p><ul><li><p>Class c1 = Student.class;//实际告诉我们任何一个类都有一个隐含的静态成员变量class（知道类名时用）</p></li><li><p>Class c2 = stu.getClass();//已知该类的对象通过getClass方法（知道对象时用）  </p></li><li><p>Class c3 = Class.forName(“类的全名”);//会有一个ClassNotFoundException异常</p></li></ul><p>　　官网解释说：c1,c2表示了Student类的类类型（）class type)，万事万物皆对象，类也是对象，是Class类的实例对象，这个对象我们成为该类的类类型（有点乱，但是慢慢捋一下还是能理解的）</p><p>　　<strong>这里有一点值得注意，</strong>当我们执行<code>System.out.println(c1==c2);</code>语句，结果返回的是<code>true</code>，这是为什么呢？原因是不管c1还是c2都代表了Student类的类类型，一个类可能是Class类的一个实例对象。</p><p>　　我们完全可以通过类的类类型创建该类的对象实例，即通过c1或c2创建Student的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu = (Student)c1.newInstance();<span class="comment">//前提是必须要有无参的构造方法，因为该语句会去调用其无参构造方法。该语句会抛出异常。</span></span><br></pre></td></tr></table></figure></p><p>　　</p><h2 id="二、动态加载类"><a href="#二、动态加载类" class="headerlink" title="二、动态加载类"></a>二、动态加载类</h2><p>　　1、编译时加载类是静态加载类，</p><p>　　new 创建对象是静态加载类，在编译时刻就需要加载所有可用使用到的类，如果有一个用不了，那么整个文件都无法通过编译</p><p>　　2、运行时加载类是动态加载类      </p><p>　　Class c =  Class.forName(“类的全名”)，不仅表示了类的类型，还表示了动态加载类，编译不会报错，在运行时才会加载，使用接口标准能更方便动态加载类的实现。功能性的类尽量使用动态加载，而不用静态加载。</p><p>　　很多软件比如QQ,360的在线升级，并不需要重新编译文件，只是动态的加载新的东西。</p><p>　　</p><h2 id="三、获取方法信息"><a href="#三、获取方法信息" class="headerlink" title="三、获取方法信息"></a>三、获取方法信息</h2><p>　　1、基本的数据类型，void关键字都存在类类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c1 =<span class="keyword">int</span>.class;<span class="comment">//int的类类型</span></span><br><span class="line">Class c2 =String.class;<span class="comment">//String类的类类型，可以理解为编译生成的那个String.class字节码文件，</span></span><br><span class="line"><span class="comment">//当然，这并不是官方的说法</span></span><br><span class="line">Class c3 =<span class="keyword">double</span>.class;</span><br><span class="line">Class c4 =Double.class;</span><br><span class="line">Class c5 =<span class="keyword">void</span>.class;</span><br></pre></td></tr></table></figure></p><p>2、Class类的基本API操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 打印类的信息，包括类的成员函数，成员变量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> obj 该对象所属类的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">publicstaticvoid <span class="title">printClassMessage</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">//要获取类的信息，首先要获取类的类类型</span></span><br><span class="line">Class c = obj.getClass();<span class="comment">//传递的是哪个子类的对象，c就是该子类的类类型</span></span><br><span class="line"><span class="comment">//获取类的名称</span></span><br><span class="line">System.out.println(<span class="string">"累的名称是："</span>+c.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Method类，方法的对象</span></span><br><span class="line"><span class="comment">   * 一个成员方法就是一个Method对象</span></span><br><span class="line"><span class="comment">   * getMethods()方法获取的是所有的public的函数，包括父类继承而来的</span></span><br><span class="line"><span class="comment">   * getDeclaredMethods()获取的是多有该类自己声明的方法，不问访问权限</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   Method[] ms = c.getMethods();<span class="comment">//c.getDeclaredMethods();</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; ms.length; i++)&#123;</span><br><span class="line">      <span class="comment">//得到方法的返回值类型的类类型</span></span><br><span class="line">      Class retrunType = ms[i].getReturnType();</span><br><span class="line">      System.out.print(retrunType.getName()+<span class="string">" "</span>);</span><br><span class="line">      <span class="comment">//得到方法的名称</span></span><br><span class="line">      System.out.print(ms[i].getName()+<span class="string">"("</span>);</span><br><span class="line">      <span class="comment">//获取的参数类型---&gt;得到的是参数列表的类型的类类型</span></span><br><span class="line">      Class[] paraTypes = ms[i].getParameterTypes();</span><br><span class="line">      <span class="keyword">for</span>(Class class1 : paraTypes)&#123;</span><br><span class="line">         System.out.print(class1.getName()+<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">")"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　Class的API中还有很多其他的方法，可以得到interface、Package、Annotation等很多信息，具体使用请参考帮助手册，本文就不在详细讲解。特别注意的一点是，如果你想得到一个类的信息，首先就要获取该类的类类型。</p><p>　　</p><h3 id="四、获取成员变量构造函数信息"><a href="#四、获取成员变量构造函数信息" class="headerlink" title="四、获取成员变量构造函数信息"></a>四、获取成员变量构造函数信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 成员变量也是对象，是java.lang.reflect.Field这个类的的对象</span></span><br><span class="line"><span class="comment">   * Field类封装了关于成员变量的操作</span></span><br><span class="line"><span class="comment">   * getFields()方法获取的是所有public的成员变量的信息</span></span><br><span class="line"><span class="comment">   * getDeclareFields()方法获取的是该类自己声明的成员变量的信息</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   Field[] fs = c.getDeclaredFields();</span><br><span class="line">   <span class="keyword">for</span>(Field field : fs)&#123;</span><br><span class="line">      <span class="comment">//得到成员变量的类型的类类型</span></span><br><span class="line">      Class fieldType = field.getType();</span><br><span class="line">      String typeName = fieldType.getName();</span><br><span class="line">      <span class="comment">//得到成员变量的名称</span></span><br><span class="line">      String fieldName = field.getName();</span><br><span class="line">      System.out.print(typeName+<span class="string">" "</span>+fieldName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造函数也是对象</span></span><br><span class="line"><span class="comment">* java.lang.Constructor中封装了构造函数的信息</span></span><br><span class="line"><span class="comment">* getConstructor()方法获取所有的public的构造函数</span></span><br><span class="line"><span class="comment">* getDeclaredConstructors得到所有的构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   Constructor[] cs = c.getDeclaredConstructors();</span><br><span class="line">   <span class="keyword">for</span>(Constructor constructor : cs)&#123;</span><br><span class="line">      System.out.print(constructor.getName()+<span class="string">"("</span>);</span><br><span class="line">      <span class="comment">//获取构造函数的参数列表---》得到的是参数雷彪的类类型</span></span><br><span class="line">      Class[] paramTypes = constructor.getParameterTypes();</span><br><span class="line">      <span class="keyword">for</span>(Class class1 : paramTypes)&#123;</span><br><span class="line">         System.out.print(class1.getName()+<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">")"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　</p><h2 id="五、方法反射的基本操作"><a href="#五、方法反射的基本操作" class="headerlink" title="五、方法反射的基本操作"></a>五、方法反射的基本操作</h2><ol><li>如何获取某个方法<br>　　方法的名称和方法的参数列表才能唯一决定某个方法<br>　　<code>Method m = c.getDeclaredMethod(&quot;方法名&quot;，可变参数列表（参数类型.class）)</code></li></ol><ol start="2"><li>方法的反射操作<br>　　<code>m.invoke(对象，参数列表)</code><br>　　方法如果没有返回值，返回null，如果有返回值返回Object类型，然后再强制类型转换为原函数的返回值类型</li></ol><p>　　</p><h2 id="六、通过反射了解集合泛型的本质"><a href="#六、通过反射了解集合泛型的本质" class="headerlink" title="六、通过反射了解集合泛型的本质"></a>六、通过反射了解集合泛型的本质</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list1 =newArrayList();</span><br><span class="line">ArrayList&lt;String&gt; list2 =newArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">Class c1 = list1.getClass();</span><br><span class="line">Class c2 = list2.getClass();</span><br><span class="line"></span><br><span class="line">System.out.println(c1==c2);<span class="comment">//结果为true，为什么？？</span></span><br></pre></td></tr></table></figure><p>　　结果分析：因为反射的操作都是编译之后的操作，也就是运行时的操作，c1==c2返回true，说明编译之后集合的泛型是去泛型化的。</p><p>　　那么我们就可以理解为，Java集合中的泛型，是用于防止错误类型元素输入的，比如在list2中我们add一个int，add(10)就会编译报错，那么这个泛型就可以只在编译阶段有效，通过了编译阶段，泛型就不存在了。可以验证，我们绕过编译，用反射动态的在list2中add一个int是可以成功的，只是这时因为list2中存储了多个不同类型的数据（String型，和int型），就不能用for-each来遍历了，会抛出类型转换错误异常<code>ClassCastException</code></p><p>　　</p><h2 id="补充资料："><a href="#补充资料：" class="headerlink" title="补充资料："></a>补充资料：</h2><h2 id="七、关于Java类加载器内容的详解"><a href="#七、关于Java类加载器内容的详解" class="headerlink" title="七、关于Java类加载器内容的详解"></a>七、关于Java类加载器内容的详解</h2><h3 id="1、类的加载"><a href="#1、类的加载" class="headerlink" title="1、类的加载"></a>1、类的加载</h3><p>　　当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化</p><ul><li><p>加载：<br>　　就是指将class文件读入内存，并为之创建一个Class对象，任何类被使用时系统都会建立一个Class对象</p></li><li><p>连接：<br>　　验证：确保被加载类的正确性<br>　　准备：负责为类的静态成员分配内存，并设置默认初始化值<br>　　解析：将类中的符号引用替换为直接引用　　</p></li><li>初始化：<br>　　局部变量保存在栈区：必须手动初始化<br>　　new 的对象保存在堆区：虚拟机会进行默认初始化，基本数据类型初始化值为0，引用类型初始化值为null</li></ul><p>　　</p><h3 id="2、类加载的时机（只加载一次）"><a href="#2、类加载的时机（只加载一次）" class="headerlink" title="2、类加载的时机（只加载一次）"></a>2、类加载的时机（只加载一次）</h3><p>　　以下时机仅表示第一次的时候</p><ol><li>创建类的实例的时候</li><li>访问类的静态变量的时候</li><li>调用类的静态方法的时候</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类的时候</li><li>直接使用java.exe命令来运行某个主类</li></ol><p>　　</p><h3 id="3、类加载器"><a href="#3、类加载器" class="headerlink" title="3、类加载器"></a>3、类加载器</h3><p>　　负责将.class文件加载到内存中，并为之生成对应的Class对象</p><p>　　虽然我们在开发过程中不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行</p><p>　　</p><h3 id="4、类加载器的组成"><a href="#4、类加载器的组成" class="headerlink" title="4、类加载器的组成"></a>4、类加载器的组成</h3><ol><li><p>Bootstrap ClassLoader 根类加载器<br>　　也被称为引导类加载器，负责Java核心类的加载，比如System类，在JDK中JRE的lib目录下rt.jar文件中的类</p></li><li><p>Extension ClassLoader 扩展类加载器<br>　　负责JRE的扩展目录中jar包的加载，在JDK中JRE的lib目录下ext目录</p></li><li><p>System ClassLoader 系统类加载器<br>　　负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径，主要是我们开发者自己写的类</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://www.cnblogs.com/rocomp/p/4781987.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.cnblogs.com/rocomp/p/4781987.html&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java SFTP传输文件实例</title>
    <link href="https://mlone.top/2019/09/28/Java-SFTP%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%AE%9E%E4%BE%8B/"/>
    <id>https://mlone.top/2019/09/28/Java-SFTP传输文件实例/</id>
    <published>2019-09-28T08:07:38.000Z</published>
    <updated>2019-09-28T08:49:53.957Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>原文地址：<a href="http://www.baeldung.com/java-file-sftp" target="_blank" rel="noopener">www.baeldung.com/java-file-sftp</a></p><br><a id="more"></a><p></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>　　这篇文章将介绍如何用 Java 在远程服务器上通过 SFTP 上传和下载文件。<br>　　接下来将使用三种不同的开发库实现，分别是 JSch、SSHJ 和 Apache Commons VFS。</p><p>　　</p><h2 id="2-使用JSch"><a href="#2-使用JSch" class="headerlink" title="2. 使用JSch"></a>2. 使用JSch</h2><p>　　首先，让我们看看如何使用 JSch 在远程服务器上实现文件上传和下载。</p><p>　　</p><h3 id="2-1-Maven-配置"><a href="#2-1-Maven-配置" class="headerlink" title="2.1  Maven 配置"></a>2.1  Maven 配置</h3><p>　　在项目 pom.xml 中添加 jsch 依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.jcraft&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jsch&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.1.55&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>　　在 Maven 中央仓库可以找到 jsch 的最新版本。</p><p>　　</p><h3 id="2-2-配置-JSch"><a href="#2-2-配置-JSch" class="headerlink" title="2.2. 配置 JSch"></a>2.2. 配置 JSch</h3><p>　　现在开始配置 JSch。</p><p>　　JSch 支持密码或公共密钥认证访问远程服务器。下面的示例采用密码认证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelSftp <span class="title">setupJsch</span><span class="params">()</span> <span class="keyword">throws</span> JSchException </span>&#123;</span><br><span class="line">    JSch jsch = <span class="keyword">new</span> JSch();</span><br><span class="line">    jsch.setKnownHosts(<span class="string">"/Users/john/.ssh/known_hosts"</span>);</span><br><span class="line">    Session jschSession = jsch.getSession(username, remoteHost);</span><br><span class="line">    jschSession.setPassword(password);</span><br><span class="line">    jschSession.connect();</span><br><span class="line">    <span class="keyword">return</span> (ChannelSftp) jschSession.openChannel(<span class="string">"sftp"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在这个示例中，remoteHost 表示成服务器的名称或 IP 地址（例如 example.com）。在测试中可以像下面这样定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String remoteHost = <span class="string">"HOST_NAME_HERE"</span>;</span><br><span class="line"><span class="keyword">private</span> String username = <span class="string">"USERNAME_HERE"</span>;</span><br><span class="line"><span class="keyword">private</span> String password = <span class="string">"PASSWORD_HERE"</span>;</span><br></pre></td></tr></table></figure></p><p>　　还以用下面的命令生成 known_hosts 文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keyscan -H -t rsa REMOTE_HOSTNAME &gt;&gt; known_hosts</span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="2-3-使用-JSch-上传文件"><a href="#2-3-使用-JSch-上传文件" class="headerlink" title="2.3. 使用 JSch 上传文件"></a>2.3. 使用 JSch 上传文件</h3><p>　　<strong>调用<code>ChannelSftp.put()</code> 可以上传文件到远程服务器：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenUploadFileUsingJsch_thenSuccess</span><span class="params">()</span> <span class="keyword">throws</span> JSchException, SftpException </span>&#123;</span><br><span class="line">    ChannelSftp channelSftp = setupJsch();</span><br><span class="line">    channelSftp.connect();</span><br><span class="line">    String localFile = <span class="string">"src/main/resources/sample.txt"</span>;</span><br><span class="line">    String remoteDir = <span class="string">"remote_sftp_test/"</span>;</span><br><span class="line">    channelSftp.put(localFile, remoteDir + <span class="string">"jschFile.txt"</span>);</span><br><span class="line">    channelSftp.exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在这个示例中，第一个参数代表要上传的本地文件，比如 <code>src/main/resources/sample.txt;`</code>remoteDir` 表示待上传的远程服务器路径。</p><p>　　</p><h3 id="2-4-使用-JSch-下载文件"><a href="#2-4-使用-JSch-下载文件" class="headerlink" title="2.4. 使用 JSch 下载文件"></a>2.4. 使用 JSch 下载文件</h3><p>　　还可以使用 ChannelSftp.get() 从远程服务器上下载文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenDownloadFileUsingJsch_thenSuccess</span><span class="params">()</span> <span class="keyword">throws</span> JSchException, SftpException </span>&#123;</span><br><span class="line">    ChannelSftp channelSftp = setupJsch();</span><br><span class="line">    channelSftp.connect();</span><br><span class="line">    String remoteFile = <span class="string">"welcome.txt"</span>;</span><br><span class="line">    String localDir = <span class="string">"src/main/resources/"</span>;</span><br><span class="line">    channelSftp.get(remoteFile, localDir + <span class="string">"jschFile.txt"</span>);</span><br><span class="line">    channelSftp.exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　remoteFile 表示要要下载的文件路径，localDir 表示下载到本地的文件路径。</p><p>　　</p><h2 id="3-使用-SSHJ"><a href="#3-使用-SSHJ" class="headerlink" title="3. 使用 SSHJ"></a>3. 使用 SSHJ</h2><p>　　接下来，我们将使用 SSHJ 库在远程服务器上实现文件上传和下载。</p><p>　　</p><h3 id="3-1-Maven-配置"><a href="#3-1-Maven-配置" class="headerlink" title="3.1. Maven 配置"></a>3.1. Maven 配置</h3><p>　　首先，在项目 pom.xml 中添加依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.hierynomus&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sshj&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.27.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>　　在 Maven 中央仓库可以找到 sshj 的最新版本。</p><p>　　</p><h3 id="3-2-配置-SSHJ"><a href="#3-2-配置-SSHJ" class="headerlink" title="3.2. 配置 SSHJ"></a>3.2. 配置 SSHJ</h3><p>　　接下来配置 SSHClient。</p><p>　　SSHJ 同样支持密码或公共密钥认证访问远程服务器。下面的示例采用密码认证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SSHClient <span class="title">setupSshj</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SSHClient client = <span class="keyword">new</span> SSHClient();</span><br><span class="line">    client.addHostKeyVerifier(<span class="keyword">new</span> PromiscuousVerifier());</span><br><span class="line">    client.connect(remoteHost);</span><br><span class="line">    client.authPassword(username, password);</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="3-3-使用-SSHJ-上传文件"><a href="#3-3-使用-SSHJ-上传文件" class="headerlink" title="3.3. 使用 SSHJ 上传文件"></a>3.3. 使用 SSHJ 上传文件</h3><p>　　与 JSch 类似，调用 SFTPClient.put() 可以上传文件到远程服务器:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenUploadFileUsingSshj_thenSuccess</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SSHClient sshClient = setupSshj();</span><br><span class="line">    SFTPClient sftpClient = sshClient.newSFTPClient();</span><br><span class="line">    sftpClient.put(localFile, remoteDir + <span class="string">"sshjFile.txt"</span>);</span><br><span class="line">    sftpClient.close();</span><br><span class="line">    sshClient.disconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这里定义两个新变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String localFile = <span class="string">"src/main/resources/input.txt"</span>;</span><br><span class="line"><span class="keyword">private</span> String remoteDir = <span class="string">"remote_sftp_test/"</span>;</span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="3-4-使用-SSHJ-下载文件"><a href="#3-4-使用-SSHJ-下载文件" class="headerlink" title="3.4. 使用 SSHJ 下载文件"></a>3.4. 使用 SSHJ 下载文件</h3><p>　　同样，这里用 SFTPClient.get() 从远程服务器上下载文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenDownloadFileUsingSshj_thenSuccess</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SSHClient sshClient = setupSshj();</span><br><span class="line">    SFTPClient sftpClient = sshClient.newSFTPClient();</span><br><span class="line">    sftpClient.get(remoteFile, localDir + <span class="string">"sshjFile.txt"</span>);</span><br><span class="line">    sftpClient.close();</span><br><span class="line">    sshClient.disconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　添加两个前面用到的变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String remoteFile = <span class="string">"welcome.txt"</span>;</span><br><span class="line"><span class="keyword">private</span> String localDir = <span class="string">"src/main/resources/"</span>;</span><br></pre></td></tr></table></figure></p><p>　　</p><h2 id="4-使用-Apache-Commons-VFS"><a href="#4-使用-Apache-Commons-VFS" class="headerlink" title="4. 使用 Apache Commons VFS"></a>4. 使用 Apache Commons VFS</h2><p>　　最后，使用 Apache Commons VFS 与远程服务器传送文件。<br>　　实际上，Apache Commons VFS 内部使用了 JSch 库。</p><p>　　</p><h3 id="4-1-Maven-配置"><a href="#4-1-Maven-配置" class="headerlink" title="4.1. Maven 配置"></a>4.1. Maven 配置</h3><p>　　需要在项目 pom.xml 中添加 commons-vfs2 依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-vfs2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>　　在 Maven 中央仓库可以找到 commons-vfs2 的最新版本。</p><p>　　</p><h3 id="4-2-使用-Apache-Commons-VFS-下载文件"><a href="#4-2-使用-Apache-Commons-VFS-下载文件" class="headerlink" title="4.2. 使用 Apache Commons VFS 下载文件"></a>4.2. 使用 Apache Commons VFS 下载文件</h3><p>　　Apache Commons VFS 的用法略有不同。</p><p>　　<strong>用<code>FileSystemManager</code>为目标文件创建<code>FileObjects</code> 对象，然后发送。</strong></p><p>　　在这个示例中，调用 <code>FileObject.copyFrom()</code> 上传文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenUploadFileUsingVfs_thenSuccess</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileSystemManager manager = VFS.getManager();</span><br><span class="line">    FileObject local = manager.resolveFile(</span><br><span class="line">      System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/"</span> + localFile);</span><br><span class="line">    FileObject remote = manager.resolveFile(</span><br><span class="line">      <span class="string">"sftp://"</span> + username + <span class="string">":"</span> + password + <span class="string">"@"</span> + remoteHost + <span class="string">"/"</span> + remoteDir + <span class="string">"vfsFile.txt"</span>);</span><br><span class="line">    remote.copyFrom(local, Selectors.SELECT_SELF);</span><br><span class="line">    local.close();</span><br><span class="line">    remote.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　注意：本地文件应该使用绝对路径，远程文件路径应该以 <code>sftp://username:password@remoteHost</code> 开始。</p><p>　　</p><h3 id="4-3-使用-Apache-Commons-VFS-下载文件"><a href="#4-3-使用-Apache-Commons-VFS-下载文件" class="headerlink" title="4.3. 使用 Apache Commons VFS 下载文件"></a>4.3. 使用 Apache Commons VFS 下载文件</h3><p>　　从远程服务器上下载文件用法类似，还是用 FileObject.copyFrom() 从 remoteFile 拷贝到 localFile：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenDownloadFileUsingVfs_thenSuccess</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileSystemManager manager = VFS.getManager();</span><br><span class="line">    FileObject local = manager.resolveFile(</span><br><span class="line">      System.getProperty(<span class="string">"user.dir"</span>) + <span class="string">"/"</span> + localDir + <span class="string">"vfsFile.txt"</span>);</span><br><span class="line">    FileObject remote = manager.resolveFile(</span><br><span class="line">      <span class="string">"sftp://"</span> + username + <span class="string">":"</span> + password + <span class="string">"@"</span> + remoteHost + <span class="string">"/"</span> + remoteFile);</span><br><span class="line">    local.copyFrom(remote, Selectors.SELECT_SELF);</span><br><span class="line">    local.close();</span><br><span class="line">    remote.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>　　这篇文章中，我们学习了如何用 Java 从远程 SFTP 服务器上载和下载文件。为此，我们使用了 JSch、SSHJ 和 Apache Commons VFS 多个开发库。</p><p>　　完整的示例源代码可以在 GitHub 上找到：<br>github.com/eugenp/tutorials/tree/master/libraries-io</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://www.baeldung.com/java-file-sftp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.baeldung.com/java-file-sftp&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java高并发面试题</title>
    <link href="https://mlone.top/2019/09/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://mlone.top/2019/09/24/java高并发面试题/</id>
    <published>2019-09-24T13:12:15.000Z</published>
    <updated>2019-09-24T14:12:23.957Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>原文地址：<a href="https://blog.csdn.net/u012998254/article/details/79400549" target="_blank" rel="noopener">https://blog.csdn.net/u012998254/article/details/79400549</a></p><br><a id="more"></a><p></p><p>　　</p><h3 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1. 线程与进程"></a>1. 线程与进程</h3><ol><li>进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。</li><li>一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。　　</li><li>区别不同：</li></ol><ul><li>地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;</li><li>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源；</li><li>线程是处理器调度的基本单位,但进程不是；</li><li>二者均可并发执行.</li></ul><p>　　</p><h3 id="2-守护线程"><a href="#2-守护线程" class="headerlink" title="2. 守护线程"></a>2. 守护线程</h3><p>　　在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。<br>守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</p><p>　　</p><h3 id="3-java-thread状态"><a href="#3-java-thread状态" class="headerlink" title="3. java thread状态"></a>3. java thread状态</h3><ol><li><code>NEW</code> 状态是指线程刚创建, 尚未启动</li><li><code>RUNNABLE</code> 状态是线程正在正常运行中, 当然可能会有某种耗时计算/IO等待的操作/CPU时间片切换等, 这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep等</li><li><code>BLOCKED</code> 这个状态下, 是在多个线程有同步操作的场景, 比如正在等待另一个线程的synchronized 块的执行释放, 也就是这里是线程在等待进入临界区</li><li><code>WAITING</code> 这个状态下是指线程拥有了某个锁之后, 调用了他的wait方法, 等待其他线程/锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作, 这里要区分 BLOCKED 和 WATING 的区别, 一个是在临界点外面等待进入, 一个是在理解点里面wait等待别人notify, 线程调用了join方法 join了另外的线程的时候, 也会进入WAITING状态, 等待被他join的线程执行结束</li><li><code>TIMED_WAITING</code> 这个状态就是有限的(时间限制)的WAITING, 一般出现在调用wait(long), join(long)等情况下, 另外一个线程sleep后, 也会进入TIMED_WAITING状态</li><li><code>TERMINATED</code> 这个状态下表示 该线程的run方法已经执行完毕了, 基本上就等于死亡了(当时如果线程被持久持有, 可能不会被回收)</li></ol><p>　　</p><h3 id="4-请说出与线程同步以及线程调度相关的方法"><a href="#4-请说出与线程同步以及线程调度相关的方法" class="headerlink" title="4. 请说出与线程同步以及线程调度相关的方法"></a>4. 请说出与线程同步以及线程调度相关的方法</h3><ul><li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理- InterruptedException异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li></ul><p>　　</p><h3 id="5、进程调度算法"><a href="#5、进程调度算法" class="headerlink" title="5、进程调度算法"></a>5、进程调度算法</h3><p><strong>实时系统：</strong>FIFO(First Input First Output，先进先出算法)，SJF(Shortest Job First，最短作业优先算法)，SRTF(Shortest Remaining Time First，最短剩余时间优先算法）。</p><p><strong>交互式系统：</strong>RR(Round Robin，时间片轮转算法)，HPF(Highest Priority First，最高优先级算法)，多级队列，最短进程优先，保证调度，彩票调度，公平分享调度。</p><p>　　</p><h3 id="6、wait-和sleep-的区别"><a href="#6、wait-和sleep-的区别" class="headerlink" title="6、wait()和sleep()的区别"></a>6、wait()和sleep()的区别</h3><ol><li>sleep来自Thread类，和wait来自Object类</li><li>调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</li><li>sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU</li><li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒</li></ol><p>　　</p><h3 id="7-ThreadLocal-以及死锁分析"><a href="#7-ThreadLocal-以及死锁分析" class="headerlink" title="7. ThreadLocal 以及死锁分析"></a>7. ThreadLocal 以及死锁分析</h3><ul><li>hreadLocal为每个线程维护一个本地变量。</li><li>采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。</li><li>ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值为对应线程的变量副本。<br><a href="https://www.cnblogs.com/xzwblog/p/7227509.html" target="_blank" rel="noopener">彻底理解ThreadLocal</a></li></ul><p>　　</p><h3 id="8-Synchronized-与Lock"><a href="#8-Synchronized-与Lock" class="headerlink" title="8. Synchronized 与Lock"></a>8. Synchronized 与Lock</h3><ol><li>ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候</li></ol><ul><li>线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，</li><li>如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断</li><li>如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</li></ul><ol start="2"><li>ReentrantLock获取锁定与三种方式：</li></ol><ul><li>lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁</li><li>tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；</li><li>tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；</li><li>lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断</li></ul><p>总体的结论先摆出来：<br><strong>synchronized：</strong><br>　　在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronized，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。</p><p><strong>ReentrantLock:</strong><br>　　ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。</p><p><a href="https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1" target="_blank" rel="noopener">详解synchronized与Lock的区别与使用</a></p><p>　　</p><h3 id="9-Volatile和Synchronized"><a href="#9-Volatile和Synchronized" class="headerlink" title="9. Volatile和Synchronized"></a>9. Volatile和Synchronized</h3><p>Volatile和Synchronized四个不同点：</p><ol><li>粒度不同，前者针对变量 ，后者锁对象和类</li><li>syn阻塞，volatile线程不阻塞</li><li>syn保证三大特性，volatile不保证原子性</li><li>syn编译器优化，volatile不优化<br>要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</li></ol><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul><p><a href="https://www.cnblogs.com/hapjin/p/5492880.html" target="_blank" rel="noopener">JAVA多线程之volatile 与 synchronized 的比较</a></p><p>　　</p><h3 id="10-CAS"><a href="#10-CAS" class="headerlink" title="10. CAS"></a>10. CAS</h3><p>　　CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><p>　　</p><h3 id="11-Java中Unsafe类详解"><a href="#11-Java中Unsafe类详解" class="headerlink" title="11. Java中Unsafe类详解"></a>11. Java中Unsafe类详解</h3><ol><li>通过Unsafe类可以分配内存，可以释放内存；类中提供的3个本地方法allocateMemory、reallocateMemory、freeMemory分别用于分配内存，扩充内存和释放内存，与C语言中的3个方法对应；</li><li>可以定位对象某字段的内存位置，也可以修改对象的字段值，即使它是私有的；</li><li>挂起与恢复:将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。整个并发框架中对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法；</li><li>CAS：<a href="http://blog.csdn.net/bluetjs/article/details/52758095" target="_blank" rel="noopener">Java中Unsafe类详解</a></li></ol><p>　　</p><h3 id="12-线程池"><a href="#12-线程池" class="headerlink" title="12. 线程池"></a>12. 线程池</h3><p>线程池的作用：<br>　　在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程</p><ul><li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>第三：提高线程的可管理性。</li><li>常用线程池：ExecutorService 是主要的实现类，其中常用的有：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executors.</span><br><span class="line">      newSingleThreadPool();</span><br><span class="line">      newFixedThreadPool();</span><br><span class="line">      newcachedTheadPool();</span><br><span class="line">      newScheduledThreadPool();</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="13-ThreadPoolExecutor"><a href="#13-ThreadPoolExecutor" class="headerlink" title="13. ThreadPoolExecutor"></a>13. ThreadPoolExecutor</h3><p><strong>构造方法参数说明：</strong></p><ul><li>corePoolSize：核心线程数，默认情况下核心线程会一直存活，即使处于闲置状态也不会受keepAliveTime限制。除非将allowCoreThreadTimeOut设置为true。</li><li>maximumPoolSize：线程池所能容纳的最大线程数。超过这个数的线程将被阻塞。当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效。</li><li>keepAliveTime:非核心线程的闲置超时时间，超过这个时间就会被回收。</li><li>unit:指定keepAliveTime的单位，如TimeUnit.SECONDS。当将allowCoreThreadTimeOut设置为true时对corePoolSize生效。</li><li>workQueue:线程池中的任务队列. 常用的有三种队列：<code>SynchronousQueue</code>,<code>LinkedBlockingDeque</code>,<code>ArrayBlockingQueue</code>。</li><li>threadFactory：线程工厂，提供创建新线程的功能。ThreadFactory是一个接口，只有一个方法。</li></ul><p><strong>原理：</strong></p><ol><li>如果当前池大小 poolSize 小于 corePoolSize ，则创建新线程执行任务。</li><li>如果当前池大小 poolSize 大于 corePoolSize ，且等待队列未满，则进入等待队列</li><li>如果当前池大小 poolSize 大于 corePoolSize 且小于 maximumPoolSize ，且等待队列已满，则创建新线程执行任务。</li><li>如果当前池大小 poolSize 大于 corePoolSize 且大于 maximumPoolSize ，且等待队列已满，则调用拒绝策略来处理该任务。</li><li>线程池里的每个线程执行完任务后不会立刻退出，而是会去检查下等待队列里是否还有线程任务需要执行，如果在 keepAliveTime 里等不到新的任务了，那么线程就会退出。</li></ol><p>　　</p><h3 id="14-Executor拒绝策略"><a href="#14-Executor拒绝策略" class="headerlink" title="14. Executor拒绝策略"></a>14. <strong>Executor拒绝策略</strong></h3><ol><li>AbortPolicy：为java线程池默认的阻塞策略，不执行此任务，而且直接抛出一个运行时异常，切记ThreadPoolExecutor.execute需要try-catch，否则程序会直接退出.</li><li>DiscardPolicy：直接抛弃，任务不执行，空方法.</li><li>DiscardOldestPolicy：从队列里面抛弃head的一个任务，并再次execute 此task.</li><li>CallerRunsPolicy：在调用execute的线程里面执行此command，会阻塞入</li><li>用户自定义拒绝策略：实现RejectedExecutionHandler，并自己定义策略模式.</li></ol><p>　　</p><h3 id="15-CachedThreadPool-、-FixedThreadPool、SingleThreadPool"><a href="#15-CachedThreadPool-、-FixedThreadPool、SingleThreadPool" class="headerlink" title="15. CachedThreadPool 、 FixedThreadPool、SingleThreadPool"></a>15. CachedThreadPool 、 FixedThreadPool、SingleThreadPool</h3><ol><li>newSingleThreadExecutor :创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务， 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行 </li></ol><p>　　适用场景：任务少 ，并且不需要并发执行</p><p>　　</p><ol start="2"><li>newCachedThreadPool :创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.<br>　　线程没有任务要执行时，便处于空闲状态，处于空闲状态的线程并不会被立即销毁（会被缓存住），只有当空闲时间超出一段时间(默认为60s)后，线程池才会销毁该线程（相当于清除过时的缓存）。新任务到达后，线程池首先会让被缓存住的线程（空闲状态）去执行任务，如果没有可用线程（无空闲线程），便会创建新的线程。 </li></ol><p>　　适用场景：处理任务速度 &gt; 提交任务速度,耗时少的任务(避免无限新增线程)</p><p>　　</p><ol start="3"><li><p>newFixedThreadPool :创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p></li><li><p>newScheduledThreadPool:创建一个定长线程池，支持定时及周期性任务执行</p></li></ol><p>　　</p><h3 id="16-CopyOnWriteArrayList"><a href="#16-CopyOnWriteArrayList" class="headerlink" title="16. CopyOnWriteArrayList"></a>16. CopyOnWriteArrayList</h3><p>　　CopyOnWriteArrayList : 写时加锁，当添加一个元素的时候，将原来的容器进行copy，复制出一个新的容器，然后在新的容器里面写，写完之后再将原容器的引用指向新的容器，而读的时候是读旧容器的数据，所以可以进行并发的读，但这是一种弱一致性的策略。 </p><p>　　使用场景：CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。</p><p>　　</p><h3 id="17-AQS"><a href="#17-AQS" class="headerlink" title="17. AQS"></a>17. AQS</h3><p>　　AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。<br><code>private volatile int state;//共享变量，使用volatile修饰保证线程可见性</code></p><ol><li>2种同步方式：独占式，共享式。独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock</li></ol><p>　　</p><ol start="2"><li><p>节点的状态 </p><ul><li>CANCELLED，值为1，表示当前的线程被取消； </li><li>SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark； </li><li>CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中； </li><li>PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行； </li><li>值为0，表示当前节点在sync队列中，等待着获取锁。</li></ul></li></ol><p>　　</p><ol start="3"><li><p>模板方法模式 </p><ul><li>protected boolean tryAcquire(int arg) : 独占式获取同步状态，试着获取，成功返回true，反之为false </li><li>protected boolean tryRelease(int arg) ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态； </li><li>protected int tryAcquireShared(int arg) ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败； </li><li>protected boolean tryReleaseShared(int arg) ：共享式释放同步状态，成功为true，失败为false </li></ul></li></ol><p>　　AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点。双端双向链表。 </p><p>　　1. 独占式:乐观的并发策略 </p><p>　　<code>acquire</code> </p><p>　　a. 首先tryAcquire获取同步状态，成功则直接返回；否则，进入下一环节；<br>　　b. 线程获取同步状态失败，就构造一个结点，加入同步队列中，这个过程要保证线程安全；<br>　　c. 加入队列中的结点线程进入自旋状态，若是老二结点（即前驱结点为头结点），才有机会尝试去获取同步状态；否则，当其前驱结点的状态为SIGNAL，线程便可安心休息，进入阻塞状态，直到被中断或者被前驱结点唤醒。 </p><p>　　<code>release</code> </p><p>　　release的同步状态相对简单，需要找到头结点的后继结点进行唤醒，若后继结点为空或处于CANCEL状态，从后向前遍历找寻一个正常的结点，唤醒其对应线程。</p><p>　　</p><ol start="4"><li>共享式: </li></ol><p>　　共享式地获取同步状态.同步状态的方法tryAcquireShared返回值为int。 </p><p>　　a.当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取； </p><p>　　b.当返回值等于0时，表示获取同步状态成功，但没有可用同步状态了； </p><p>　　c.当返回值小于0时，表示获取同步状态失败。</p><p>　　</p><ol start="5"><li>AQS实现公平锁和非公平锁 </li></ol><p>　　非公平锁中，那些尝试获取锁且尚未进入等待队列的线程会和等待队列head结点的线程发生竞争。公平锁中，在获取锁时，增加了isFirst(current)判断，当且仅当，等待队列为空或当前线程是等待队列的头结点时，才可尝试获取锁。 </p><p>　　</p><h3 id="18-Java里的阻塞队列"><a href="#18-Java里的阻塞队列" class="headerlink" title="18. Java里的阻塞队列"></a>18. Java里的阻塞队列</h3><p><strong>7个阻塞队列。分别是</strong></p><ol><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。 </li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 </li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 </li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。 </li><li>SynchronousQueue：一个不存储元素的阻塞队列。 </li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 </li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ol><p><strong>添加元素</strong></p><p>　　Java中的阻塞队列接口BlockingQueue继承自Queue接口。BlockingQueue接口提供了3个添加元素方法。</p><ul><li>add：添加元素到队列里，添加成功返回true，由于容量满了添加失败会抛出IllegalStateException异常 </li><li>offer：添加元素到队列里，添加成功返回true，添加失败返回false </li><li>put：添加元素到队列里，如果容量满了会阻塞直到容量不满</li></ul><p><strong>删除方法</strong></p><p>3个删除方法：</p><ul><li>poll：删除队列头部元素，如果队列为空，返回null。否则返回元素。 </li><li>remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false </li><li>take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除</li></ul><p>　　</p><h3 id="19-Condition"><a href="#19-Condition" class="headerlink" title="19. Condition"></a>19. Condition</h3><p>　　对Condition的源码理解，主要就是理解等待队列，等待队列可以类比同步队列，而且等待队列比同步队列要简单，因为等待队列是单向队列，同步队列是双向队列。</p><p>　　</p><h3 id="20-DelayQueue"><a href="#20-DelayQueue" class="headerlink" title="20. DelayQueue"></a>20. DelayQueue</h3><p>　　队列中每个元素都有个过期时间，并且队列是个优先级队列，当从队列获取元素时候，只有过期元素才会出队列。</p><p>　　</p><h3 id="21-Fork-Join框架"><a href="#21-Fork-Join框架" class="headerlink" title="21. Fork/Join框架"></a>21. Fork/Join框架</h3><p>　　Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork/Join框架要完成两件事情：</p><ol><li>任务分割：首先Fork/Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</li><li>执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</li></ol><p>在Java的Fork/Join框架中，使用两个类完成上述操作：</p><ol><li><p>ForkJoinTask:我们要使用Fork/Join框架，首先需要创建一个ForkJoin任务。该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集成ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了两个子类：<br>　　- RecursiveAction：用于没有返回结果的任务<br>　　- RecursiveTask：用于有返回结果的任务</p></li><li><p>ForkJoinPool:ForkJoinTask需要通过ForkJoinPool来执行</p></li></ol><p>　　任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务(工作窃取算法)。 </p><p><strong>Fork/Join框架的实现原理：</strong> </p><p>　　ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool，而ForkJoinWorkerThread负责执行这</p><p>　　</p><h3 id="22-原子操作类"><a href="#22-原子操作类" class="headerlink" title="22. 原子操作类"></a>22. 原子操作类</h3><p>　　在java.util.concurrent.atomic包下，可以分为四种类型的原子更新类：原子更新基本类型、原子更新数组类型、原子更新引用和原子更新属性。</p><ol><li>原子更新基本类型 </li></ol><p>　　使用原子方式更新基本类型，共包括3个类： </p><ul><li>AtomicBoolean：原子更新布尔变量 </li><li>AtomicInteger：原子更新整型变量 </li><li>AtomicLong：原子更新长整型变量</li></ul><ol start="2"><li>原子更新数组 </li></ol><p>　　通过原子更新数组里的某个元素，共有3个类： </p><ul><li>AtomicIntegerArray：原子更新整型数组的某个元素 </li><li>AtomicLongArray：原子更新长整型数组的某个元素 </li><li>AtomicReferenceArray：原子更新引用类型数组的某个元素 </li></ul><p>　　AtomicIntegerArray常用的方法有： </p><ul><li>int addAndSet(int i, int delta)：以原子方式将输入值与数组中索引为i的元素相加 </li><li>boolean compareAndSet(int i, int expect, int update)：如果当前值等于预期值，则以原子方式更新数组中索引为i的值为update值</li></ul><ol start="3"><li>原子更新引用类型 </li></ol><ul><li>AtomicReference：原子更新引用类型 </li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段 </li><li>AtomicMarkableReference：原子更新带有标记位的引用类型。</li></ul><ol start="4"><li>原子更新字段类 </li></ol><p>　　如果需要原子更新某个类的某个字段，就需要用到原子更新字段类，可以使用以下几个类： </p><ul><li>AtomicIntegerFieldUpdater：原子更新整型字段 </li><li>AtomicLongFieldUpdater：原子更新长整型字段 </li><li>AtomicStampedReference：原子更新带有版本号的引用类型。 </li></ul><p>　　要想原子更新字段，需要两个步骤： </p><ul><li>每次必须使用newUpdater创建一个更新器，并且需要设置想要更新的类的字段 </li><li>更新类的字段（属性）必须为public volatile</li></ul><p>　　</p><h3 id="23-同步屏障CyclicBarrier"><a href="#23-同步屏障CyclicBarrier" class="headerlink" title="23. 同步屏障CyclicBarrier"></a>23. 同步屏障CyclicBarrier</h3><p>　　CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><p><strong>CyclicBarrier和CountDownLatch的区别：</strong></p><ul><li><p>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。 </p></li><li><p>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。比如以下代码执行完之后会返回true。</p></li></ul><p>　　</p><h3 id="24-Semaphore"><a href="#24-Semaphore" class="headerlink" title="24.  Semaphore"></a>24.  Semaphore</h3><p>　　Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源 </p><p>　　Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控.</p><p>　　</p><h3 id="25-死锁-以及解决死锁"><a href="#25-死锁-以及解决死锁" class="headerlink" title="25. 死锁,以及解决死锁"></a>25. 死锁,以及解决死锁</h3><p>死锁产生的四个必要条件：</p><ul><li>互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。 </li><li>不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。 </li><li>请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。 </li><li>循环等待条件：在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。</li></ul><p><strong>解决死锁：</strong></p><ol><li>死锁预防，就是不让上面的四个条件同时成立。 </li><li>合理分配资源。 </li><li>使用银行家算法，如果该进程请求的资源操作系统剩余量可以满足，那么就分配。</li></ol><p>　　</p><h3 id="26-进程间的通信方式"><a href="#26-进程间的通信方式" class="headerlink" title="26. 进程间的通信方式"></a>26. 进程间的通信方式</h3><ol><li>管道( pipe)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li>共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li><li>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li></ol><p>　　</p><h3 id="27-中断"><a href="#27-中断" class="headerlink" title="27. 中断"></a>27. 中断</h3><p>　　interrupt()的作用是中断本线程。 </p><p>　　本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。 </p><p>　　如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。</p><p>　　例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。</p><p>　　如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。</p><p>　　如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。 </p><p>　　中断一个“已终止的线程”不会产生任何操作。</p><ol><li>终止处于“阻塞状态”的线程 </li></ol><p>　　通常，我们通过“中断”方式终止处于“阻塞状态”的线程。 </p><p>　　当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程， </p><ol start="2"><li>终止处于“运行状态”的线程</li></ol><p><strong>interrupted() 和 isInterrupted()的区别：</strong><br>　　interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。 </p><p>　　区别是：interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;原文地址：&lt;a href=&quot;https://blog.csdn.net/u012998254/article/details/79400549&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/u012998254/article/details/79400549&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Java Faker生成随机数</title>
    <link href="https://mlone.top/2019/09/23/%E4%BD%BF%E7%94%A8Java-Faker%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>https://mlone.top/2019/09/23/使用Java-Faker生成随机数/</id>
    <published>2019-09-23T15:52:45.000Z</published>
    <updated>2019-09-23T16:07:11.120Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>原文地址：rieckpil.de/howto-generate-random-data-in-java-using-java-faker/</p><br><a id="more"></a><p></p><p>　　<br>　　原型开发好以后，通常需要一些展示数据。如果没有实际数据，怎样为 Java 程序生成一些有意义的随机数据？</p><p>　　我用过 UUID 和 ThreadLocalRandom 来生成随机数，但是能力有限，无法提供特定领域的随机数据。于是，我开始寻找更好的解决方案。最后找到了 <strong>Faker</strong> 这个好东西，幸运的是有 Java 版本：Java Faker。不仅使用方便，而且可以设置多个领域，几秒钟内生成需要的随机数。</p><p>　　</p><h3 id="1-Java-Faker-上手"><a href="#1-Java-Faker-上手" class="headerlink" title="1. Java Faker 上手"></a>1. Java Faker 上手</h3><p>　　在 Maven项目中添加 Java Faker 依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.javafaker&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;javafaker&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;0.18&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>　　使用前，创建一个 Faker 对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Faker faker = <span class="keyword">new</span> Faker();</span><br></pre></td></tr></table></figure></p><p>　　Faker 方法调用时会随机访问底层数据，因此不需要每次都创建一个实例。Java Faker 通过<code>/src/main/resources</code> 中的<code>.yml</code> 获取数据。</p><p>　　<br>　　使用 Faker 可以访问<strong>30多个不同的领域</strong>，为几乎每个用例创建随机数。可以使用流式 API 生成随机数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String firstName = faker.name().firstName();</span><br><span class="line">String appName = faker.app().name();</span><br><span class="line">String foodIngredient = faker.food().ingredient();</span><br></pre></td></tr></table></figure></p><p>　　包含的领域有：</p><ul><li>金融</li><li>视频</li><li>书籍</li><li>姓名</li><li>地址</li><li>商务</li><li>…</li></ul><p>　　此外还包含一些有趣的领域：</p><ul><li>尤达</li><li>查克·诺里斯</li><li>哈利·波特</li><li>指环王</li><li>…</li></ul><p>　　</p><h3 id="2-Java-Faker-使用示例"><a href="#2-Java-Faker-使用示例" class="headerlink" title="2. Java Faker 使用示例"></a>2. Java Faker 使用示例</h3><p>　　为了演示 Java Faker，这里通过一个 <strong>REST API</strong> 返回随机数量的 person、book 和 food 对象。虽然示例采用了 Spring Boot 2.1 和 Java 11，但是其他版本也可以正常工作。</p><p>　　示例应用提供了不同的 <strong>Endpoint</strong> 获取随机数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/random"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomDataEndpoint</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@GetMapping</span>(<span class="string">"/persons"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> JsonNode <span class="title">getRandomPersons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Faker faker = <span class="keyword">new</span> Faker();</span><br><span class="line">      ArrayNode persons = objectMapper.createArrayNode();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         persons.add(objectMapper.createObjectNode()</span><br><span class="line">               .put(<span class="string">"firstName"</span>, faker.name().firstName())</span><br><span class="line">               .put(<span class="string">"lastName"</span>, faker.name().lastName())</span><br><span class="line">               .put(<span class="string">"title"</span>, faker.name().title())</span><br><span class="line">               .put(<span class="string">"suffix"</span>, faker.name().suffix())</span><br><span class="line">               .put(<span class="string">"address"</span>, faker.address().streetAddress())</span><br><span class="line">               .put(<span class="string">"city"</span>, faker.address().cityName())</span><br><span class="line">               .put(<span class="string">"country"</span>, faker.address().country()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> persons;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="3-返回本地化随机数据"><a href="#3-返回本地化随机数据" class="headerlink" title="3. 返回本地化随机数据"></a>3. 返回本地化随机数据</h3><p>　　随机数据的默认 locale 是 <strong>EN</strong>。此外，Faker 库还支持返回本地化随机数据。如果指定了 locale 请确保在开发库的支持列表中。可以检查对应的 .yml 文件确认已经有对应的英文版本。</p><p>　　如果指定的 locale 没有对应的翻译，比如 beers，默认会切换到<strong>英文</strong>。</p><p>　　<br>　　Faker 构造函数参数默认为 locale：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Faker faker = <span class="keyword">new</span> Faker(<span class="keyword">new</span> Locale(<span class="string">"de"</span>));</span><br></pre></td></tr></table></figure></p><p>　　<br>　　上面的代码指定返回的随机数据为<strong>德语</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/foods"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonNode <span class="title">getRandomFoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Faker faker = <span class="keyword">new</span> Faker(<span class="keyword">new</span> Locale(<span class="string">"de"</span>));</span><br><span class="line">   ArrayNode foods = objectMapper.createArrayNode();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      foods.add(objectMapper.createObjectNode()</span><br><span class="line">               .put(<span class="string">"ingredients"</span> , faker.food().ingredient())</span><br><span class="line">               .put(<span class="string">"spices"</span>, faker.food().spice())</span><br><span class="line">               .put(<span class="string">"measurements"</span>, faker.food().measurement()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> foods;&#125;</span><br></pre></td></tr></table></figure></p><p>　　<br>　　也可以设为列出的其他 locale：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/books"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonNode <span class="title">getRandomBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Faker faker = <span class="keyword">new</span> Faker(<span class="keyword">new</span> Locale(<span class="string">"en-US"</span>));</span><br><span class="line">   ArrayNode books = objectMapper.createArrayNode();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      books.add(objectMapper.createObjectNode()</span><br><span class="line">            .put(<span class="string">"author"</span>, faker.book().author())</span><br><span class="line">            .put(<span class="string">"genre"</span>, faker.book().genre())</span><br><span class="line">            .put(<span class="string">"publisher"</span>, faker.book().publisher())</span><br><span class="line">            .put(<span class="string">"title"</span>, faker.book().title()));</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> books;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　<br>示例完整源代码可以在 GitHub 上找到：<br>github.com/rieckpil/blog-tutorials/tree/master/random-data-in-java-using-java-faker</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;原文地址：rieckpil.de/howto-generate-random-data-in-java-using-java-faker/&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java Optional实例介绍</title>
    <link href="https://mlone.top/2019/09/23/Java-Optional%E5%AE%9E%E4%BE%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://mlone.top/2019/09/23/Java-Optional实例介绍/</id>
    <published>2019-09-23T15:28:33.000Z</published>
    <updated>2019-09-23T15:51:49.161Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>原文地址：dzone.com/articles/java-optional</p><br><a id="more"></a><p></p><p>　　<br>　　<code>Optional</code> 是一种容器对象，可能包含也可能不含非 <code>null</code> 值。如果包含某个值 <code>isPresent()</code> 返回 <code>true</code>，调用<code>get()</code>返回该值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Package : java.util</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure></p><p>以下是 Optional 类中一些有用的方法列表：</p><p>　　</p><h3 id="1-创建-Optional-相关方法"><a href="#1-创建-Optional-相关方法" class="headerlink" title="1. 创建 Optional 相关方法"></a>1. 创建 Optional 相关方法</h3><p>方法：<code>Optional.of</code>、<code>Optional.ofNullable</code>、<code>Optional.empty()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">Optional&lt;String&gt; nonEmptyOptional = Optional.of(<span class="string">"name"</span>); <span class="comment">// 对 null 无效</span></span><br><span class="line">Optional&lt;String&gt; nonEmptyOptional = Optional.ofNullable(<span class="keyword">null</span>); <span class="comment">// 支持 null</span></span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="2-检查-Optional-值"><a href="#2-检查-Optional-值" class="headerlink" title="2. 检查 Optional 值"></a>2. 检查 Optional 值</h3><p>方法：<code>Optional.isPresent()</code>、<code>Optional.ifPresent()</code></p><p>　　</p><ul><li><strong>如果 <code>Optional</code>有值，<code>isPresent()</code> 返回 true</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; nonEmptyOptional = Optional.of(<span class="string">"name"</span>);</span><br><span class="line">assertTrue(nonEmptyOptional.isPresent());</span><br></pre></td></tr></table></figure><p>　　</p><ul><li><strong><code>ifPresent()</code> ： 如果值存在，则执行代码块</strong></li></ul><p>　　在 <code>Optional</code> 出现前，需要在方法内进行以下 null 检查：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data == <span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println( <span class="string">" data is "</span> + data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// data 是方法内部使用的对象</span></span><br></pre></td></tr></table></figure></p><p>　　由于无法确保data在使用前进行了 null 检查，可能会抛出 NullPointerException。</p><p>　　现在，引入<code>Optional</code> 后，可以用 <code>ifPresent</code>满足类似需求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; nonEmptyOptional = Optional.of(<span class="string">"name"</span>);</span><br><span class="line">nonEmptyOptional.ifPresent( x-&gt; &#123; System.out.println(x.length()); &#125; );</span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="3-通过-Optional-取值"><a href="#3-通过-Optional-取值" class="headerlink" title="3. 通过 Optional 取值"></a>3. 通过 Optional 取值</h3><ul><li><strong><code>get()</code> ： 返回值包含在 <code>Optional</code> 中返回</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; nonEmptyOptional = Optional.ofNullable(<span class="string">"orignal"</span>);</span><br><span class="line">String value = nonEmptyOptional.get();</span><br></pre></td></tr></table></figure><p>　　</p><ul><li><strong><code>orElse()</code>：如果值不存在，则返回默认值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optional 包含 null 时, 使用 orElse 值</span></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">String value = emptyOptional.orElse(<span class="string">"default Value"</span>);</span><br><span class="line">assertEquals(<span class="string">"default Value"</span>, value);</span><br><span class="line"><span class="comment">// Optional 不包含 null 时, 不使用 orElse 值</span></span><br><span class="line">Optional&lt;String&gt; nonEmptyOptional = Optional.ofNullable(<span class="string">"orginal"</span>);</span><br><span class="line">String value1 = nonEmptyOptional.orElse(<span class="string">"default Value"</span>);</span><br><span class="line">assertEquals(<span class="string">"orginal"</span>, value1);</span><br></pre></td></tr></table></figure><p>　　</p><ul><li><strong><code>orElseGet()</code> ：与 <code>orElse()</code> 类似，如果 <code>Optional</code> 不包含值，用函数作为返回值</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optional 包含 null 时, 使用 orElse</span></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">String value = emptyOptional.orElseGet(()-&gt;<span class="string">"default value"</span>);</span><br><span class="line">assertEquals(<span class="string">"default value"</span>, value);</span><br><span class="line"><span class="comment">// Optional 不包含 null 时, 不使用 orElse</span></span><br><span class="line">Optional&lt;String&gt; nonEmptyOptional = Optional.ofNullable(<span class="string">"orginal"</span>);</span><br><span class="line">String value1 = nonEmptyOptional.orElseGet(()-&gt;<span class="string">"default value"</span>);</span><br><span class="line">assertEquals(<span class="string">"orginal"</span>, value1);</span><br></pre></td></tr></table></figure><p>　　</p><ul><li><strong><code>orElseThrow()</code> ：与<code>orElseGet()</code> 类似，监测到值为<code>null</code> 时抛出异常</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = NullPointerException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OrElseThrowCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String nullName = <span class="keyword">null</span>;</span><br><span class="line">    String value = Optional.ofNullable(nullName).orElseThrow(NullPointerException::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="4-Optional-用法"><a href="#4-Optional-用法" class="headerlink" title="4. Optional 用法"></a>4. Optional 用法</h3><ul><li><strong>使用 <code>Optional</code> 作为返回值</strong></li></ul><p>　　<code>Optional</code> 的常见用法是作为方法返回值。定义方法时，可以根据实现逻辑返回 <code>null</code> 或对象。返回 <code>Optional</code> 对象是一种很好的方法，开发人员知道返回值可能是 <code>null</code>，迫使他们合理地处理返回的对象。<code>Optional</code> 的优点在于，能够引导开发者进行恰当的检查，从而避免 <code>NullPointerException</code>。</p><p>　　下面的例子定义了 <code>Optional&lt;Employee&gt;getEmployeeWithId(int id)</code> 方法，返回值类型为 <code>Optional&lt;Employee&gt;</code>。调用者需要通过 Optional 方法得到返回值。执行过程中可以避免 <code>NullPointerExceptions</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Employee&gt; employess = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> EmployeeNotFoundException </span>&#123;</span><br><span class="line">    employess.add(<span class="keyword">new</span> Employee(<span class="string">"emp1"</span>, <span class="number">1</span>, <span class="number">1000</span>));</span><br><span class="line">    employess.add(<span class="keyword">new</span> Employee(<span class="string">"emp2"</span>, <span class="number">2</span>, <span class="number">2000</span>));</span><br><span class="line">    employess.add(<span class="keyword">new</span> Employee(<span class="string">"emp1"</span>, <span class="number">3</span>, <span class="number">3000</span>));</span><br><span class="line">    Optional&lt;Employee&gt; employee = getEmployeeWithId(<span class="number">1</span>);</span><br><span class="line">    Employee e = employee.orElseThrow(() -&gt; <span class="keyword">new</span> EmployeeNotFoundException(<span class="string">"emp not found"</span>));</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Employee&gt; <span class="title">getEmployeeWithId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    Optional&lt;Employee&gt; employee = employess.stream().filter(e -&gt; (e.getId() == id)).findFirst();</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><ul><li><strong>使用<code>Optional</code> 作为方法参数</strong></li></ul><p><strong>不推荐</strong>使用<code>Optional</code> 作为方法参数。假设一个方法包含两个参数：一个类型是 <code>Optional</code>，另一个类型是非 <code>Optional</code>。背后的逻辑是，第一个参数值可能为 <code>null</code>。</p><p>　　<strong>这种情况，不要使用 <code>Optional</code> 作为参数，请进行方法重载。</strong></p><p>　　上面的例子最好定义重载方法，只接受一个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Employee&gt; <span class="title">getEmployee</span><span class="params">(<span class="keyword">int</span> id,Optional&lt;String&gt; name)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更好的方法: 重载方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Employee&gt; <span class="title">getEmployee</span><span class="params">(<span class="keyword">int</span> id,String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Employee&gt; <span class="title">getEmployee</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br></pre></td></tr></table></figure><p>　　</p><h3 id="5-Java-各版本新增的-Optional-方法列表"><a href="#5-Java-各版本新增的-Optional-方法列表" class="headerlink" title="5. Java 各版本新增的 Optional 方法列表"></a>5. Java 各版本新增的 Optional 方法列表</h3><ul><li><strong>Java 9</strong></li><li><ul><li><code>or()</code>：如果值存在，返回包含该值的 <code>Optional</code> 对象；否则，返回 <code>or()</code> 函数生成的 <code>Optional</code> 对象。</li></ul></li><li><ul><li><code>ifPresentOrElse(Consumer&lt;? super T&gt;action, Runnable emptyAction)</code>：如果值存在，使用该值执行指定调用，否则使用空值执行调用。</li></ul></li><li><ul><li><code>stream()</code>：如果值存在，返回该值的顺序流（Stream）；否则返回空流。</li></ul></li><li><p><strong>Java 10</strong></p></li><li><ul><li><code>orElseThrow()</code>：如果值存在，返回该值；否则抛出 <code>NoSuchElementException</code>。注意：与 Java 8 不同，不接受任何参数。</li></ul></li><li><p><strong>Java 11</strong></p></li><li><ul><li><code>isEmpty()</code>：如果值不存在，返回 true；否则返回 false。</li></ul></li></ul><p>　　<br>　　<strong>说明：</strong><code>Optional</code> 是基于值的类，应当避免对<code>Optional</code> 对象调用像引用相等性(==)、HashCode、同步等基于对象标识的操作，调用可能产生无法预测的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;原文地址：dzone.com/articles/java-optional&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题：MySQL读写分离</title>
    <link href="https://mlone.top/2019/09/23/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AMySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>https://mlone.top/2019/09/23/面试题：MySQL读写分离/</id>
    <published>2019-09-23T15:02:26.000Z</published>
    <updated>2019-09-23T15:09:41.117Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>原文来自 GitHub 开源社区 Doocs</p><br><a id="more"></a><p></p><p>　　</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><strong>面试题</strong></h3><p>　　你们有没有做 MySQL 读写分离？如何实现 MySQL 的读写分离？MySQL 主从复制原理的是啥？如何解决 MySQL 主从同步的延时问题？</p><p>　　</p><h3 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a><strong>面试官心理分析</strong></h3><p>　　高并发这个阶段，肯定是需要做读写分离的，啥意思？因为实际上大部分的互联网公司，一些网站，或者是 app，其实都是读多写少。所以针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，那不就可以支撑更高的读并发压力了吗？</p><p>　　</p><h3 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a><strong>面试题剖析</strong></h3><h4 id="如何实现-MySQL-的读写分离？"><a href="#如何实现-MySQL-的读写分离？" class="headerlink" title="如何实现 MySQL 的读写分离？"></a>如何实现 MySQL 的读写分离？</h4><p>　　其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p><p>　　</p><h4 id="MySQL-主从复制原理的是啥？"><a href="#MySQL-主从复制原理的是啥？" class="headerlink" title="MySQL 主从复制原理的是啥？"></a>MySQL 主从复制原理的是啥？</h4><p>　　主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p><p>　　这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行 SQL 的特点，在高并发场景下，从库的数据一定会比主库慢一些，是<strong>有延时</strong>的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。</p><p>　　<br>　　而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。</p><p>　　所以 MySQL 实际上在这一块有两个机制，一个是<strong>半同步复制</strong>，用来解决主库数据丢失问题；一个是<strong>并行复制</strong>，用来解决主从同步延时问题。</p><p>　　这个所谓<strong>半同步复制</strong>，也叫 <code>semi-sync</code> 复制，指的就是主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成了。</p><p>　　所谓<strong>并行复制</strong>，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是库级别的并行。</p><p>　　</p><h4 id="MySQL-主从同步延时问题（精华）"><a href="#MySQL-主从同步延时问题（精华）" class="headerlink" title="MySQL 主从同步延时问题（精华）"></a>MySQL 主从同步延时问题（精华）</h4><p>　　以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p><p>　　是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p><p>　　<br>我们通过 MySQL 命令：</p><pre><code>show status</code></pre><p>　　查看 <code>Seconds_Behind_Master</code>，可以看到从库复制主库的数据落后了几 ms。</p><p>　　<br>一般来说，如果主从延迟较为严重，有以下解决方案：</p><ul><li>分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可以忽略不计。</li><li>打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。</li><li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li><li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>。<strong>不推荐</strong>这种方法，你要是这么搞，读写分离的意义就丧失了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;原文来自 GitHub 开源社区 Doocs&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>使用类型重构</title>
    <link href="https://mlone.top/2019/09/23/%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E9%87%8D%E6%9E%84/"/>
    <id>https://mlone.top/2019/09/23/使用类型重构/</id>
    <published>2019-09-23T14:39:31.000Z</published>
    <updated>2019-09-23T14:56:04.336Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://dzone.com/articles/refactoring-with-types" target="_blank" rel="noopener">https://dzone.com/articles/refactoring-with-types</a><br><a id="more"></a></p><p>　　<br>　　在本文中，我们将介绍一些使用类型进行重构的技术。类型可以精确定义某个领域，还可以通过它在合并业务规则时保证代码的正确性。这样使得我们能够编写简单优雅的单元测试，验证代码是否正确。</p><p>　　</p><h3 id="使用类型重构"><a href="#使用类型重构" class="headerlink" title="使用类型重构"></a>使用类型重构</h3><p>最近在检查代码时，我遇到了下面这个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderLine</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line">  <span class="keyword">private</span> Double unitPrice;</span><br><span class="line">  <span class="keyword">private</span> Double listPrice;</span><br><span class="line">  <span class="keyword">private</span> Double tax;</span><br><span class="line">  <span class="keyword">private</span> Double charge;</span><br><span class="line">  <span class="comment">// 其余实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面是典型的“代码异味”，称为基本类型强迫症。</p><p>　　上面代码中，所有参数都用数字表示。但是，它们只是数字吗？<code>unitPrice</code>是否可以与 <code>listPrice</code> 或者 <code>tax</code>互换?</p><p>　　在领域驱动的设计中，这些的确是不同的东西，而不仅仅表示数字。理想情况下，我们希望用特定类型来表示这些概念。</p><p>　　<br>　　第一级重构是为这些类创建简单的封装类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListPrice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ListPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Getter</span> Double listPrice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListPrice</span><span class="params">(Double listPrice)</span> </span>&#123;</span><br><span class="line">        setListPrice(listPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setListPrice</span><span class="params">(Double listPrice)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(listPrice, <span class="string">"list price can not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (listPrice &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid list price: "</span>+listPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listPrice = listPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitPrice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UnitPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Getter</span> Double unitPrice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">unitPrice</span><span class="params">(Double unitPrice)</span> </span>&#123;</span><br><span class="line">        setUnitPrice(unitPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUnitPrice</span><span class="params">(Double unitPrice)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(unitPrice, <span class="string">"unit price can not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (unitPrice &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid unit price: "</span>+unitPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.unitPrice = unitPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这是一个很好的开始。现在，我们为他们定义了概念。可以把需要的业务规则加到这些结构中，不必在OrderLine容器类里实现。</p><p>　　但是，如果发现有检查listPrice和unitPrice是否为null或者非负数负数的重复代码，那么这些检查很可能也适用于quantity、tax和charge。</p><p>　　<br>　　因此，创建一个代表非负数的Type很有意义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonNegativeDouble</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Getter</span> Double value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonNegativeDouble</span><span class="params">(Double value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Double value)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(value,<span class="string">"Value cannot be null"</span>);</span><br><span class="line">        <span class="keyword">if</span>(value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Value has to be positive"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　现在，可以用 NonNegativeDouble 安全地重构UnitPrice和ListPrice类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitPrice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UnitPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    NonNegativeDouble unitPrice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnitPrice</span><span class="params">(NonNegativeDouble unitPrice)</span> </span>&#123;</span><br><span class="line">        setUnitPrice(unitPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUnitPrice</span><span class="params">(NonNegativeDouble unitPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unitPrice = unitPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　可以用一个简单的测试来验证UnitPrice为非负数，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Unroll</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnitPriceSpec</span> <span class="keyword">extends</span> <span class="title">Specification</span> </span>&#123;</span><br><span class="line">    def <span class="string">"#text creation of Unit Price object with value - (#unitPriceValue)"</span>() &#123;</span><br><span class="line">        given:</span><br><span class="line">        def unitPrice</span><br><span class="line">        when:</span><br><span class="line">        <span class="keyword">boolean</span> isExceptionThrown = <span class="keyword">false</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            unitPrice = <span class="keyword">new</span> UnitPrice(<span class="keyword">new</span> NonNegativeDouble(unitPriceValue))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            isExceptionThrown = <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        then:</span><br><span class="line">        <span class="keyword">assert</span> isExceptionThrown == isExceptionExpected</span><br><span class="line">        where:</span><br><span class="line">        text        |   unitPriceValue      |   isExceptionExpected</span><br><span class="line">        <span class="string">'Valid'</span>     |   <span class="number">120</span>                 |   <span class="keyword">false</span></span><br><span class="line">        <span class="string">'Valid'</span>     |   <span class="number">12.34</span>               |   <span class="keyword">false</span></span><br><span class="line">        <span class="string">'Valid'</span>     |   <span class="number">0.8989</span>              |   <span class="keyword">false</span></span><br><span class="line">        <span class="string">'Valid'</span>     |   <span class="number">12567652365.67667</span>   |   <span class="keyword">false</span></span><br><span class="line">        <span class="string">'Invalid'</span>   |   <span class="number">0</span>                   |   <span class="keyword">false</span></span><br><span class="line">        <span class="string">'Invalid'</span>   |   <span class="number">0.00000</span>             |   <span class="keyword">false</span></span><br><span class="line">        <span class="string">'Invalid'</span>   |   -<span class="number">23.5676</span>            |   <span class="keyword">true</span></span><br><span class="line">        <span class="string">'Invalid'</span>   |   -<span class="number">23478687</span>           |   <span class="keyword">true</span></span><br><span class="line">        <span class="string">'Invalid'</span>   |   <span class="keyword">null</span>                |   <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　尽管上面展示的重构用法很简单，但它同样适用于基本类型，例如Email、名字、货币、 范围以及日期和时间。</p><p>　　</p><h3 id="重构：使用类型让非法状态无处躲藏"><a href="#重构：使用类型让非法状态无处躲藏" class="headerlink" title="重构：使用类型让非法状态无处躲藏"></a>重构：使用类型让非法状态无处躲藏</h3><p>　　重构带来的另一个巨大价值是让非法状态在模型中无处躲藏。作为示例，请思考下面这个 Java 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerContact</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="meta">@Getter</span> EmailContactInfo emailContactInfo;</span><br><span class="line">   <span class="keyword">private</span> <span class="meta">@Getter</span> PostalContactInfo postalContactInfo;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CustomerContact</span><span class="params">(EmailContactInfo emailContactInfo, PostalContactInfo postalContactInfo)</span></span>&#123;</span><br><span class="line">      setEmailContactInfo(emailContactInfo);</span><br><span class="line">      setPostalContactInfo(postalContactInfo);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setEmailContactInfo</span><span class="params">(EmailContactInfo emailContactInfo)</span></span>&#123;</span><br><span class="line">      Objects.requireNonNull(emailContactInfo,<span class="string">"Email Contact Info cannot be null"</span>);</span><br><span class="line">      <span class="keyword">this</span>.emailContactInfo = emailContactInfo;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPostalContactInfo</span><span class="params">(PostalContactInfo postalContactInfo)</span></span>&#123;</span><br><span class="line">      Objects.requireNonNull(postalContactInfo,<span class="string">"Postal Contact Info cannot be null"</span>);</span><br><span class="line">      <span class="keyword">this</span>.postalContactInfo = postalContactInfo;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在之前重构基础上，我们已经提取了EmailContactInfo和PostalContactInfo。它们与strings不同，是真正的领域结构。</p><p>　　假设有这么一个简单的业务规则：“客户必须有 Email 信息或邮政地址。”</p><p>　　这意味着至少有一个EmailContactInfo或者CustomerContactInfo。也可以两个都有。但是，当前的实现要求两个同时存在。</p><p>　　<br>　　为了实现业务规则，第一次重构看起来像下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerContact</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Getter</span> Optional&lt;EmailContactInfo&gt; emailContactInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Getter</span> Optional&lt;PostalContactInfo&gt; postalContactInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerContact</span><span class="params">(PersonName name, Optional&lt;EmailContactInfo&gt; emailContactInfo, Optional&lt;PostalContactInfo&gt; postalContactInfo)</span></span>&#123;</span><br><span class="line">        setEmailContactInfo(emailContactInfo);</span><br><span class="line">        setPostalContactInfo(postalContactInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setEmailContactInfo</span><span class="params">(Optional&lt;EmailContactInfo&gt; emailContactInfo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.emailContactInfo = emailContactInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPostalContactInfo</span><span class="params">(Optional&lt;PostalContactInfo&gt; postalContactInfo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.postalContactInfo = postalContactInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　现在这个版本反而超出了规则要求。规则要求CustomerContact至少包含 Email 或者邮政地址。但是，当前的实现中，CustomerContact可能一个联系方式也没有。</p><p>　　这种简化的业务规则会导致下面的结果：<br>　　<strong>客户联系方式 = Email or 邮政地址 or Email和邮政地址都有</strong></p><p>　　在函数式语言中，可以用<code>sum types</code>满足这种条件。但是，像 Java 这样的语言没有把这种结构作为一等公民。尽管如此，还是有<code>JavaSealedUnions</code>这样的开发库为 Java 提供  Sum和Union支持。</p><p>　　<br>　　使用 JavaSealedUnions，实现业务规则：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerContact</span> <span class="keyword">implements</span> <span class="title">Union2</span>&lt;<span class="title">EmailContact</span>, <span class="title">PostalContact</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomerContact <span class="title">email</span><span class="params">(String emailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmailContact(emailAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomerContact <span class="title">postal</span><span class="params">(String postalAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostalContact(postalAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailContact</span> <span class="keyword">extends</span> <span class="title">CustomerContact</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String emailAddress;</span><br><span class="line">    EmailContact(String emailAddress) &#123;</span><br><span class="line">        <span class="keyword">this</span>.emailAddress = emailAddress;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/* 一些业务逻辑 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">continued</span><span class="params">(Consumer&lt;EmailContact&gt; continuationLeft, Consumer&lt;PostalContact&gt; continuationRight)</span> </span>&#123;</span><br><span class="line">        continuationLeft.call(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">join</span><span class="params">(Function&lt;EmailContact, T&gt; mapLeft, Function&lt;PostalContact, T&gt; mapRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapLeft.call(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostalContact</span> <span class="keyword">extends</span> <span class="title">CustomerContact</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">    PostalContact(String address) &#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/* 一些业务逻辑 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">continued</span><span class="params">(Consumer&lt;EmailContact&gt; continuationLeft, Consumer&lt;PostalContact&gt; continuationRight)</span> </span>&#123;</span><br><span class="line">        continuationRight.call(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">join</span><span class="params">(Function&lt;EmailContact, T&gt; mapLeft, Function&lt;PostalContact, T&gt; mapRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapRight.call(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">CustomerContact customerContact = getCustomerContact();</span><br><span class="line"><span class="keyword">if</span> (customerContact.valid()) &#123;</span><br><span class="line">    customerContact.continued(customerContactService::byEmail(), customerContactService::byPostalAddress())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　本文展示了如何使用类型让设计变得更简洁。使用类型还能够有助于避免业务规则本身的歧义。前文展示的方法也可以在其他情况下使用，例如得到允许使用、发生成功或失败的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://dzone.com/articles/refactoring-with-types&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dzone.com/articles/refactoring-with-types&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM内存结构面试题十道</title>
    <link href="https://mlone.top/2019/09/23/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8D%81%E9%81%93/"/>
    <id>https://mlone.top/2019/09/23/JVM内存结构面试题十道/</id>
    <published>2019-09-23T14:10:55.000Z</published>
    <updated>2019-09-23T14:37:42.995Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>文章转载自公众号 Hollis ， 作者 Hollis</p><br><a id="more"></a><p></p><p>　　<br>　　以下10道题，如果您可以全部准确无误的回答的话，那说明你真的很了解JVM的内存结构以及内存分配相关的知识了，如果有哪些知识点是不了解的，那么本文正好可以帮你答疑解惑。</p><blockquote><ol><li>JVM管理的内存结构是怎样的？ </li><li>不同的虚拟机在实现运行时内存的时候有什么区别？ </li><li>运行时数据区中哪些区域是线程共享的？哪些是独享的？ </li><li>除了JVM运行时内存以外，还有什么区域可以用吗？ </li><li>堆和栈的区别是什么？ </li><li>Java中的数组是存储在堆上还是栈上的？ </li><li>Java中的对象创建有多少种方式？ </li><li>Java中对象创建的过程是怎么样的？ </li><li>Java中的对象一定在堆上分配内存吗？ </li><li>如何获取堆和栈的dump文件？</li></ol></blockquote><p>　　</p><h3 id="Q1：JVM管理的内存结构是怎样的？"><a href="#Q1：JVM管理的内存结构是怎样的？" class="headerlink" title="Q1：JVM管理的内存结构是怎样的？"></a>Q1：JVM管理的内存结构是怎样的？</h3><p>　　Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。《Java虚拟机规范》中规定了JVM所管理的内存需要包括以下几个运行时区域：</p><p><img src="/blogImg/2019/9/23/2-1.png" alt></p><p>　　Java虚拟机运行时数据区域主要包含了PC寄存器（程序计数器）、Java虚拟机栈、本地方法栈、Java堆、方法区以及运行时常量池。</p><p>　　各个区域有各自不同的作用，关于各个区域的作用就不在本文中相信介绍了。</p><p>　　但是，需要注意的是，<span style="color: orange;">上面的区域划分只是逻辑区域，规范对于有些区域的限制是比较松的，所以不同的虚拟机厂商在实现上，甚至是同一款虚拟机的不同版本也是不尽相同的。</span></p><p>　　</p><h3 id="Q2：不同的虚拟机在实现运行时内存的时候有什么区别？"><a href="#Q2：不同的虚拟机在实现运行时内存的时候有什么区别？" class="headerlink" title="Q2：不同的虚拟机在实现运行时内存的时候有什么区别？"></a>Q2：不同的虚拟机在实现运行时内存的时候有什么区别？</h3><p>　　前面提到过《Java虚拟机规范》定义的JVM运行时所需的内存区域，不同的虚拟机实现上有所不同，而在这么多区域中，规范对于方法区的管理是最宽松的，规范中关于这部分的描述如下：</p><blockquote><p>　　方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。本版本的规范也不限定实现方法区的内存位置和代码编译的管理策略。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多的空间时自行收缩。方法区在实际内存空间站可以是不连续的。</p></blockquote><p>　　这一规定，可以说是给了虚拟机厂商很大的自由。</p><p>　　虚拟机规范对方法区实现的位置并没有明确要求，<span style="color: orange;">在最著名的HotSopt虚拟机实现中（在Java 8 之前），方法区仅是逻辑上的独立区域，在物理上并没有独立于堆而存在，而是位于永久代中。</span>所以，这时候方法区也是可以被垃圾回收的。</p><blockquote><p>实践证明，JVM中存在着大量的声明短暂的对象，还有一些生命周期比较长的对象。为了对他们采用不同的收集策略，采用了分代收集算法，所以HotSpot虚拟机把的根据对象的年龄不同，把堆分为新生代、老年代和永久代。</p></blockquote><p><span style="color: orange;">在Java 8中 ，HotSpot虚拟机移除了永久代，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）</span><br>　　<img src="/blogImg/2019/9/23/2-2.png" alt></p><p>　　</p><h3 id="Q3：运行时数据区中哪些区域是线程共享的？哪些是独享的？"><a href="#Q3：运行时数据区中哪些区域是线程共享的？哪些是独享的？" class="headerlink" title="Q3：运行时数据区中哪些区域是线程共享的？哪些是独享的？"></a>Q3：运行时数据区中哪些区域是线程共享的？哪些是独享的？</h3><p>　　在JVM运行时内存区域中，PC寄存器、虚拟机栈和本地方法栈是线程独享的。</p><p>　　而Java堆、方法区是线程共享的。但是值得注意的是，<span style="color: orange;">Java堆其实还为每一个线程单独分配了一块TLAB空间，这部分空间在分配时是线程独享的，在使用时是线程共享的。</span>（TLAB介绍）</p><p>　　</p><h3 id="Q4：除了JVM运行时内存以外，还有什么区域可以用吗？"><a href="#Q4：除了JVM运行时内存以外，还有什么区域可以用吗？" class="headerlink" title="Q4：除了JVM运行时内存以外，还有什么区域可以用吗？"></a>Q4：除了JVM运行时内存以外，还有什么区域可以用吗？</h3><p>　　除了我们前面介绍的虚拟机运行时数据区以外，还有一部分内存也被频繁使用，他不是运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，他就是——直接内存。</p><p>　　<span style="color: orange;">直接内存的分配不受Java堆大小的限制，但是他还是会收到服务器总内存的影响。</span></p><p>　　在JDK 1.4中引入的NIO中，引入了一种基于Channel和Buffer的I/O方式，他可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的应用进行操作。<br>　　<img src="/blogImg/2019/9/23/2-3.png" alt></p><p>　　</p><h3 id="Q5：堆和栈的区别是什么？"><a href="#Q5：堆和栈的区别是什么？" class="headerlink" title="Q5：堆和栈的区别是什么？"></a>Q5：堆和栈的区别是什么？</h3><p>　　堆和栈（虚拟机栈）是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的，二者之间最大的区别就是存储的内容不同：</p><ul><li>堆中主要存放对象实例。 </li><li>栈（局部变量表）中主要存放各种基本数据类型、对象的引用。</li></ul><p>　　</p><h3 id="Q6：Java中的数组是存储在堆上还是栈上的？"><a href="#Q6：Java中的数组是存储在堆上还是栈上的？" class="headerlink" title="Q6：Java中的数组是存储在堆上还是栈上的？"></a>Q6：Java中的数组是存储在堆上还是栈上的？</h3><p>　　在Java中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；</p><p>　　所以，<span style="color: orange;">数组的实例是保存在堆中，而数组的引用是保存在栈上的。</span><br>　　<img src="/blogImg/2019/9/23/2-4.png" alt></p><p>　　</p><h3 id="Q7：Java中的对象创建有多少种方式？"><a href="#Q7：Java中的对象创建有多少种方式？" class="headerlink" title="Q7：Java中的对象创建有多少种方式？"></a>Q7：Java中的对象创建有多少种方式？</h3><p>Java中共有5种方式可以创建一个对象：</p><ol><li><p>最简单的方式就是使用new关键字。</p><pre><code>User user = new User();</code></pre></li><li><p>使用反射机制创建对象：</p><pre><code>User user = User.class.newInstance();</code></pre></li><li><p>使用Constructor类的newInstance：</p><pre><code>Constructor&lt;User&gt; constructor = User.class.getConstructor();User user = constructor.newInstance();</code></pre></li><li><p>使用clone方法</p></li><li>使用反序列化的方式</li></ol><p>　　</p><h3 id="Q8：Java中对象创建的过程是怎么样的？"><a href="#Q8：Java中对象创建的过程是怎么样的？" class="headerlink" title="Q8：Java中对象创建的过程是怎么样的？"></a>Q8：Java中对象创建的过程是怎么样的？</h3><p>对于一个普通的Java对象的创建，大致过程如下：</p><ol><li>虚拟机遇到new指令，到常量池定位到这个类的符号引用。 </li><li>检查符号引用代表的类是否被加载、解析、初始化过。 </li><li>虚拟机为对象分配内存。 </li><li>虚拟机将分配到的内存空间都初始化为零值。 </li><li>虚拟机对对象进行必要的设置。 </li><li>执行方法，成员变量进行初始化。</li></ol><p>　　</p><h3 id="Q9：Java中的对象一定在堆上分配内存吗？"><a href="#Q9：Java中的对象一定在堆上分配内存吗？" class="headerlink" title="Q9：Java中的对象一定在堆上分配内存吗？"></a>Q9：Java中的对象一定在堆上分配内存吗？</h3><p>　　前面我们说过，Java堆中主要保存了对象实例，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>　　其实，在编译期间，JIT会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p><p>　　<span style="color: orange;">如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。</span>（关于逃逸分析和栈上分配可以参考：深入理解Java中的逃逸分析、对象并不一定都是在堆上分配内存的）<br>　　<img src="/blogImg/2019/9/23/2-5.png" alt></p><p>　　</p><h3 id="Q10：怎么如何获取堆和栈的dump文件？"><a href="#Q10：怎么如何获取堆和栈的dump文件？" class="headerlink" title="Q10：怎么如何获取堆和栈的dump文件？"></a>Q10：怎么如何获取堆和栈的dump文件？</h3><p>　　Java Dump，Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。</p><p>　　<span style="color: orange;">可以使用在服务器上使用jmap命令来获取堆dump，使用jstack命令来获取线程的调用栈dump。</span>（关于jmap和jstack可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=402312019&amp;idx=1&amp;sn=97736feb967ecbffb454fa037015ad6d&amp;chksm=7964d6724e135f64a5c0d65e41afbeac45700dd91149375f99071731954e855e13b11cd6c30b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Java命令学习系列（三）——Jmap</a>、<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=402296484&amp;idx=1&amp;sn=8e7fc8197a216afb590b17e15f9b721e&amp;chksm=796493854e131a932b3dd53839820eaba022cb87a601062b6bf6a574d742cd8e92a707432173&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Java命令学习系列（二）——Jstack</a>）</p><p>　　<br>　　以上，就是本文的全部内容，对于其中的很多知识点，作者并未逐一展开，感兴趣的朋友可以自行学习一下，关于Java虚拟机相关知识，推荐三本书：《深入理解Java虚拟机》、《HotSpot实战》以及《Java虚拟机规范（第8版）》，本文中内容也参考了这三本书中很多内容。希望对你有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;文章转载自公众号 Hollis ， 作者 Hollis&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>如何保证缓存与数据库的双写一致性？</title>
    <link href="https://mlone.top/2019/09/23/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/"/>
    <id>https://mlone.top/2019/09/23/如何保证缓存与数据库的双写一致性？/</id>
    <published>2019-09-22T16:40:45.000Z</published>
    <updated>2019-09-22T17:04:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/chang384915878/article/details/86756463" target="_blank" rel="noopener">https://blog.csdn.net/chang384915878/article/details/86756463</a><br><a id="more"></a></p><p>　　</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>如何保证缓存与数据库的双写一致性？</p></blockquote><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>　　你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>　　一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p><p>　　串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern：</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><blockquote><p><strong>为什么是删除缓存，而不是更新缓存？</strong></p></blockquote><p>　　原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</p><p>　　比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p><p>　　<br>　　另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于<strong>比较复杂的缓存数据计算的场景</strong>，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，<strong>这个缓存到底会不会被频繁访问到？</strong></p><p>　　举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有<strong>大量的冷数据</strong>。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用<strong>到缓存才去算缓存</strong>。</p><p>　　其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p><h3 id="最初级的缓存不一致问题及解决方案"><a href="#最初级的缓存不一致问题及解决方案" class="headerlink" title="最初级的缓存不一致问题及解决方案"></a>最初级的缓存不一致问题及解决方案</h3><p><strong>问题：</strong>先修改数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。<br><img src="/blogImg/2019/9/23/1-1.png" alt></p><p><strong>解决思路：</strong>先删除缓存，再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</p><h3 id="比较复杂的数据不一致问题分析"><a href="#比较复杂的数据不一致问题分析" class="headerlink" title="比较复杂的数据不一致问题分析"></a>比较复杂的数据不一致问题分析</h3><p>　　数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p><blockquote><p> <strong>为什么上亿流量高并发场景下，缓存会出现这个问题？</strong></p></blockquote><p>　　只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就<strong>可能会出现上述的数据库+缓存不一致的情况</strong>。</p><p>　　<br><strong>解决方案如下：</strong></p><p>　　更新数据的时候，根据<strong>数据的唯一标识</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部队列中。</p><p>　　一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p>　　这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><p>　　待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p><p>　　如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p><p>　　<br><strong>高并发的场景下，该解决方案要注意的问题：</strong></p><blockquote><ol><li>读请求长时阻塞</li></ol></blockquote><p>　　由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。</p><p>　　该解决方案，最大的风险点在于说，<strong>可能数据更新很频繁</strong>，导致队列中积压了大量更新操作在里面，然后<strong>读请求会发生大量的超时</strong>，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。</p><p>　　另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要<strong>部署多个服务</strong>，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每隔库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致<strong>读请求的长时阻塞</strong>。</p><p>　　一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。</p><p>　　<strong>如果一个内存队列中可能积压的更新操作特别多</strong>，那么你就要<strong>加机器</strong>，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。<br>　　<br>　　其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。</p><p>我们来<strong>实际粗略测算一下</strong>：</p><p>　　如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了。</p><p>　　经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。</p><p>　　</p><blockquote><ol start="2"><li>读请求并发量过高</li></ol></blockquote><p>　　这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。</p><p>　　但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。</p><p>　　</p><blockquote><ol start="3"><li>多服务实例部署的请求路由</li></ol></blockquote><p>　　可能这个服务部署了多个实例，那么必须<strong>保证</strong>说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器<strong>路由到相同的服务实例上</strong>。</p><p>　　比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。</p><p>　　</p><blockquote><ol start="4"><li>热点商品的路由问题，导致请求的倾斜</li></ol></blockquote><p>　　万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/chang384915878/article/details/86756463&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/chang384915878/article/details/86756463&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap与HashMap、Hashtable的区别</title>
    <link href="https://mlone.top/2019/09/22/ConcurrentHashMap%E4%B8%8EHashMap%E3%80%81Hashtable%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://mlone.top/2019/09/22/ConcurrentHashMap与HashMap、Hashtable的区别/</id>
    <published>2019-09-22T09:12:29.000Z</published>
    <updated>2019-09-22T09:53:39.788Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/" target="_blank" rel="noopener">https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/</a><br><a id="more"></a></p><p>　　</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　<code>ConcurrentHashMap</code>顾名思义就是同步的HashMap，也就是线程安全的HashMap，所以本篇介绍的ConcurrentHashMap和HashMap有着很重要的关系，所以建议之前没有了解过HashMap的可以先看看这篇关于HashMap的原理分析<a href="https://ddnd.cn/2019/03/07/jdk1.8-hashmap/" target="_blank" rel="noopener">《HashMap从认识到源码分析》</a>，本篇继续以<code>JDK1.8</code>版本的源码进行分析，最后在介绍完ConcurrentHashMap之后会对ConcurrentHashMap、Hashtable和HashMap做一个比较和总结。</p><p>　　</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>　　我们先看一下<code>ConcurrentHashMap</code>实现了哪些接口、继承了哪些类，对<code>ConcurrentHashMap</code>有一个整体认知。<br>　　<img src="/blogImg/2019/9/22/4-1.jpg" alt></p><p>　　ConcurrentHashMap<code>继承</code>AbstractMap<code>接口，这个和</code>HashMap<code>一样，然后实现了</code>ConcurrentMap<code>接口，这个和</code>HashMap<code>不一样，</code>HashMap<code>是直接实现的</code>Map`接口。</p><p>　　再细看<code>ConcurrentHashMap</code>的结构，这里列举几个重要的成员变量<code>table</code>、<code>nextTable</code>、<code>baseCount</code>、<code>sizeCtl</code>、<code>transferIndex</code>、<code>cellsBusy</code></p><ul><li><p><strong>table</strong>：数据类型是Node数组，这里的Node和HashMap的Node一样都是内部类且实现了<code>Map.Entry</code>接口</p></li><li><p><strong>nextTable</strong>：哈希表扩容时生成的数据，数组为扩容前的2倍</p></li><li><p><strong>sizeCtl</strong> ：多个线程的<strong>共享变量</strong>，是操作的控制标识符，它的作用不仅包括<code>threshold</code>的作用，在不同的地方有不同的值也有不同的用途：</p><ul><li><code>-1</code>代表正在<strong>初始化</strong></li><li><code>-N</code>代表有<code>N-1</code>个线程正在进行<strong>扩容</strong>操作</li><li><code>0</code>代表hash表还没有被初始化</li><li>正数表示下一次进行扩容的容量大小</li></ul></li><li><p><strong>ForwardingNode</strong>：一个特殊的Node节点，Hash地址为-1，存储着nextTable的引用，只有table发生扩用的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或者已被移动<br>　　<img src="/blogImg/2019/9/22/4-2.jpg" alt></p></li></ul><p>　　<code>ConcurrentHashMap</code>和<code>HashMap</code>一样都是采用<strong>拉链法</strong>处理哈希冲突，且都为了防止单链表过长影响查询效率，所以当链表长度超过某一个值时候将用红黑树代替链表进行存储，采用了<strong>数组+链表+红黑树</strong>的结构<br>　　<img src="/blogImg/2019/9/22/4-3.jpg" alt></p><p>　　所以从结构上看<code>HashMap</code>和<code>ConcurrentHashMap</code>还是很相似的，只是<code>ConcurrentHashMap</code>在某些操作上采用了<code>CAS</code> + <code>synchronized</code>来保证并发情况下的安全。<br>　　<br>　　说到<code>ConcurrentHashMap</code>处理并发情况下的线程安全问题，这不得不提到<code>Hashtable</code>，因为<code>Hashtable</code>也是线程安全的，那<code>ConcurrentHashMap</code>和<code>Hashtable</code>有什么区别或者有什么高明之处嘛？以至于官方都推荐使用<code>ConcurrentHashMap</code>来代替<code>Hashtable</code></p><ul><li><p><strong>线程安全的实现</strong>：<code>Hashtable</code>采用<strong>对象锁</strong>(synchronized修饰对象方法)来保证线程安全，也就是一个<code>Hashtable</code>对象只有一把锁，如果线程1拿了对象A的锁进行有<code>synchronized</code>修饰的<code>put</code>方法，其他线程是无法操作对象A中有<code>synchronized</code>修饰的方法的(如<code>get</code>方法、<code>remove</code>方法等)，竞争激烈所以效率低下。而<code>ConcurrentHashMap</code>采用<code>CAS</code> + <code>synchronized</code>来保证并发安全性，且<code>synchronized</code>关键字不是用在方法上而是用在了具体的对象上，实现了更小粒度的锁，等会源码分析的时候在细说这个SUN大师们的鬼斧神工</p></li><li><p>数据结构的实现：<code>Hashtable</code>采用的是<strong>数组 + 链表</strong>，当链表过长会影响查询效率，而<code>ConcurrentHashMap</code>采用<strong>数组 + 链表 + 红黑树</strong>，当链表长度超过某一个值，则将链表转成红黑树，提高查询效率。</p></li></ul><p>　　</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>　　<code>ConcurrentHashMap</code>的构造函数有5个，从数量上看就和<code>HashMap</code>、<code>Hashtable</code>(4个)的不同，多出的那个构造函数是<code>public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)</code>，即除了传入容量大小、负载因子之外还多传入了一个整型的<code>concurrencyLevel</code>，这个整型是我们预先估计的并发量，比如我们估计并发是<code>30</code>，那么就可以传入<code>30</code>。</p><p>　　其他的4个构造函数的参数和<code>HashMap</code>的一样，而具体的初始化过程却又不相同，<code>HashMap</code>和<code>Hashtable</code>传入的容量大小和负载因子都是为了计算出<strong>初始阈值</strong>(threshold)，而<code>ConcurrentHashMap</code>传入的容量大小和负载因子是为了计算出<strong>sizeCtl</strong>用于初始化<code>table</code>，这个sizeCtl即table数组的大小，不同的构造函数计算sizeCtl方法都不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造函数，什么也不做，table的初始化放在了第一次插入数据时，默认容量大小是16和HashMap的一样，默认sizeCtl为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小的构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的容量大小小于0 则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果传入的容量大小大于允许的最大容量值 则cap取允许的容量最大值 否则cap =</span></span><br><span class="line">    <span class="comment">//((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)，</span></span><br><span class="line">    <span class="comment">//即如果传入的容量大小是12 则 cap = 32(12 + (12 &gt;&gt;&gt; 1) + 1=19</span></span><br><span class="line">    <span class="comment">//向上取2的幂次方即32)，这里为啥一定要是2的幂次方，原因和HashMap的threshold一样，都是为</span></span><br><span class="line">    <span class="comment">//了让位运算和取模运算的结果一样。</span></span><br><span class="line">    <span class="comment">//MAXIMUM_CAPACITY即允许的最大容量值 为2^30。</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               <span class="comment">//tableSizeFor这个函数即实现了将一个整数取2的幂次方。</span></span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//将上面计算出的cap 赋值给sizeCtl，注意此时sizeCtl为正数，代表进行扩容的容量大小。</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含指定Map的构造函数。</span></span><br><span class="line"><span class="comment">//置sizeCtl为默认容量大小 即16。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小和负载因子的构造函数。</span></span><br><span class="line"><span class="comment">//默认并发数大小是1。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小、负载因子和并发数大小的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果传入的容量大小 小于 传入的并发数大小，</span></span><br><span class="line">    <span class="comment">//则容量大小取并发数大小，这样做的原因是确保每一个Node只会分配给一个线程，而一个线程则</span></span><br><span class="line">    <span class="comment">//可以分配到多个Node，比如当容量大小为64，并发数大</span></span><br><span class="line">    <span class="comment">//小为16时，则每个线程分配到4个Node。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//size = 1.0 + (long)initialCapacity / loadFactor 这里计算方法和上面的构造函数不一样。</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">//如果size大于允许的最大容量值则 sizeCtl = 允许的最大容量值 否则 sizeCtl =</span></span><br><span class="line">    <span class="comment">//size取2的幂次方。</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><ol><li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址，这个HashMap相似。</li><li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li><li>使用 <strong>容量大小-1 &amp; 哈希地址</strong> 计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li><li>如果该下标上的节点(头节点)的哈希地址为-1，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket，这个就是ConcurrentHashMap为什么高效的原因之一。</li><li>进入到bucket里面，首先判断这个bucket存储的是红黑树(哈希地址小于0，原因后面分析)还是链表。</li><li>如果是<strong>链表</strong>，则遍历链表看看是否有哈希地址和键key相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>结束加锁</strong>。</li><li>最后判断该bucket上的链表长度是否大于<strong>链表转红黑树的阈值(8)</strong>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树，以免链表过长影响效率。</li><li>调用<code>addCount()</code>方法，作用是将ConcurrentHashMap的键值对数量+1，还有另一个作用是检查ConcurrentHashMap是否需要扩容。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不允许键值为null，这点与线程安全的Hashtable保持一致，和HashMap不同。</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//取键key的hashCode()和HashMap、Hashtable都一样，然后再执行spread()方法计算得到哈希地</span></span><br><span class="line">    <span class="comment">//址，这个spread()方法和HashMap的hash()方法一样，都是将hashCode()做无符号右移16位，只不</span></span><br><span class="line">    <span class="comment">//过spread()加多了 &amp;0x7fffffff，让结果为正数。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果table数组为空或者长度为0(未初始化)，则调用initTable()初始化table，初始化函数</span></span><br><span class="line">        <span class="comment">//下面介绍。</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//调用实现了CAS原子性操作的tabAt方法</span></span><br><span class="line">        <span class="comment">//tabAt方法的第一个参数是Node数组的引用，第二个参数在Node数组的下标，实现的是在Nod</span></span><br><span class="line">        <span class="comment">//e数组中查找指定下标的Node，如果找到则返回该Node节点(链表头节点)，否则返回null，</span></span><br><span class="line">        <span class="comment">//这里的i = (n - 1)&amp;hash即是计算待插入的节点在table的下标，即table容量-1的结果和哈</span></span><br><span class="line">        <span class="comment">//希地址做与运算，和HashMap的算法一样。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果该下标上并没有节点(即链表为空)，则直接调用实现了CAS原子性操作的</span></span><br><span class="line">            <span class="comment">//casTable()方法，</span></span><br><span class="line">            <span class="comment">//casTable()方法的第一个参数是Node数组的引用，第二个参数是待操作的下标，第三</span></span><br><span class="line">            <span class="comment">//个参数是期望值，第四个参数是待操作的Node节点，实现的是将Node数组下标为参数二</span></span><br><span class="line">            <span class="comment">//的节点替换成参数四的节点，如果期望值和实际值不符返回false，否则参数四的节点成</span></span><br><span class="line">            <span class="comment">//功替换上去，返回ture，即插入成功。注意这里：如果插入成功了则跳出for循环，插入</span></span><br><span class="line">            <span class="comment">//失败的话(其他线程抢先插入了)，那么会执行到下面的代码。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该下标上的节点的哈希地址为-1(即链表的头节点为ForwardingNode节点)，则表示</span></span><br><span class="line">        <span class="comment">//table需要扩容，值得注意的是ConcurrentHashMap初始化和扩容不是用同一个方法，而</span></span><br><span class="line">        <span class="comment">//HashMap和Hashtable都是用同一个方法，当前线程会去协助扩容，扩容过程后面介绍。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//如果该下标上的节点既不是空也不是需要扩容，则表示这个链表可以插入值，将进入到链表</span></span><br><span class="line">        <span class="comment">//中，将新节点插入或者覆盖旧值。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//通过关键字synchroized对该下标上的节点加锁(相当于锁住锁住</span></span><br><span class="line">            <span class="comment">//该下标上的链表)，其他下标上的节点并没有加锁，所以其他线程</span></span><br><span class="line">            <span class="comment">//可以安全的获得其他下标上的链表进行操作，也正是因为这个所</span></span><br><span class="line">            <span class="comment">//以提高了ConcurrentHashMap的效率，提高了并发度。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果该下标上的节点的哈希地址大于等于0，则表示这是</span></span><br><span class="line">                    <span class="comment">//个链表。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果哈希地址、键key相同 或者 键key不为空</span></span><br><span class="line">                            <span class="comment">//且键key相同，则表示存在键key和待插入的键</span></span><br><span class="line">                            <span class="comment">//key相同，则执行更新值value的操作。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//如果找到了链表的最后一个节点都没有找到相</span></span><br><span class="line">                            <span class="comment">//同键Key的，则是插入操作，将插入的键值新建</span></span><br><span class="line">                            <span class="comment">//个节点并且添加到链表尾部，这个和HashMap一</span></span><br><span class="line">                            <span class="comment">//样都是插入到尾部。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果该下标上的节点的哈希地址小于0 且为树节点</span></span><br><span class="line">                    <span class="comment">//则将带插入键值新增到红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//如果插入的结果不为null，则表示为替换</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash,</span><br><span class="line">                        key,value)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断链表的长度是否大于等于链表的阈值(8)，大于则将链表转成</span></span><br><span class="line">            <span class="comment">//红黑树，提高效率。这点和HashMap一样。</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ol><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li><li>计算出键key所在的下标，算法是(n - 1) &amp; h，如果table不为空，且下标上的bucket不为空，则到bucket中查找。</li><li>如果bucket的头节点的哈希地址小于0，则代表这个bucket存储的是红黑树，否则是链表。</li><li>到红黑树或者链表中查找，找到则返回该键key的值，找不到则返回null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//运用键key的hashCode()计算出哈希地址</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//如果table不为空 且 table长度大于0 且 计算出的下标上bucket不为空，</span></span><br><span class="line">    <span class="comment">//则代表这个bucket存在，进入到bucket中查找，</span></span><br><span class="line">    <span class="comment">//其中(n - 1) &amp; h为计算出键key相对应的数组下标的算法。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果哈希地址、键key相同则表示查找到，返回value，这里查找到的是头节点。</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果bucket头节点的哈希地址小于0，则代表bucket为红黑树，在红黑树中查找。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，在链表中查找。</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ol><li>调用<code>spread()</code>方法计算出键key的哈希地址。</li><li>计算出键key所在的数组下标，如果table为空或者bucket为空，则返回<code>null</code>。</li><li>判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。</li><li>如果table和bucket都不为空，table也不处于在扩容状态，则<strong>锁住当前bucket</strong>，对bucket进行操作。</li><li>根据bucket的头结点判断bucket是链表还是红黑树。</li><li>在链表或者红黑树中移除哈希地址、键key相同的节点。</li><li>调用<code>addCount</code>方法，将当前table存储的键值对数量-1。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算需要移除的键key的哈希地址。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//遍历table。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//table为空，或者键key所在的bucket为空，则跳出循环返回。</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//如果当前table正在扩容，则调用helpTransfer方法，去协助扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//将键key所在的bucket加锁。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//bucket头节点的哈希地址大于等于0，为链表。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//遍历链表。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//找到哈希地址、键key相同的节点，进行移除。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果bucket的头节点小于0，即为红黑树。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="comment">//找到节点，并且移除。</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用addCount方法，将当前ConcurrentHashMap存储的键值对数量-1。</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="initTable初始化方法"><a href="#initTable初始化方法" class="headerlink" title="initTable初始化方法"></a>initTable初始化方法</h3><p>　　<code>table</code>的初始化主要由initTable()方法实现的，initTable()方法初始化一个合适大小的数组，然后设置sizeCtl。 我们知道<code>ConcurrentHashMap</code>是线程安全的，即支持多线程的，那么一开始很多个线程同时执行<code>put()</code>方法，而<code>table</code>又没初始化，那么就会很多个线程会去执行initTable()方法尝试初始化table，而<code>put</code>方法和<code>initTable</code>方法都是没有加锁的(synchronize)，那SUN的大师们是怎么保证线程安全的呢？<br>　　通过源码可以看得出，table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。</p><ol><li>判断table是否为<code>null</code>，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li><li>如果table为<code>null</code>，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li><li>如果table为<code>null</code>且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则再次判断table是否为空，不为空则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的，sizeCtl = ((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//如果table为null或者长度为0， //则一直循环试图初始化table(如果某一时刻别的线程将table初始化好了，那table不为null，该//线程就结束while循环)。</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl小于0，</span></span><br><span class="line">        <span class="comment">//即有其他线程正在初始化或者扩容，执行Thread.yield()将当前线程挂起，让出CPU时间，</span></span><br><span class="line">        <span class="comment">//该线程从运行态转成就绪态。</span></span><br><span class="line">        <span class="comment">//如果该线程从就绪态转成运行态了，此时table可能已被别的线程初始化完成，table不为</span></span><br><span class="line">        <span class="comment">//null，该线程结束while循环。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//如果此时sizeCtl不小于0，即没有别的线程在做table初始化和扩容操作，</span></span><br><span class="line">        <span class="comment">//那么该线程就会调用Unsafe的CAS操作compareAndSwapInt尝试将sizeCtl的值修改成</span></span><br><span class="line">        <span class="comment">//-1(sizeCtl=-1表示table正在初始化，别的线程如果也进入了initTable方法则会执行</span></span><br><span class="line">        <span class="comment">//Thread.yield()将它的线程挂起 让出CPU时间)，</span></span><br><span class="line">        <span class="comment">//如果compareAndSwapInt将sizeCtl=-1设置成功 则进入if里面，否则继续while循环。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//再次确认当前table为null即还未初始化，这个判断不能少。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果sc(sizeCtl)大于0，则n=sc，否则n=默认的容量大</span></span><br><span class="line">                    小<span class="number">16</span>，</span><br><span class="line">                    <span class="comment">//这里的sc=sizeCtl=0，即如果在构造函数没有指定容量</span></span><br><span class="line">                    大小，</span><br><span class="line">                    <span class="comment">//否则使用了有参数的构造函数，sc=sizeCtl=指定的容量大小。</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">//创建指定容量的Node数组(table)。</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算阈值，n - (n &gt;&gt;&gt; 2) = 0.75n当ConcurrentHashMap储存的键值对数量</span></span><br><span class="line">                    <span class="comment">//大于这个阈值，就会发生扩容。</span></span><br><span class="line">                    <span class="comment">//这里的0.75相当于HashMap的默认负载因子，可以发现HashMap、Hashtable如果</span></span><br><span class="line">                    <span class="comment">//使用传入了负载因子的构造函数初始化的话，那么每次扩容，新阈值都是=新容</span></span><br><span class="line">                    <span class="comment">//量 * 负载因子，而ConcurrentHashMap不管使用的哪一种构造函数初始化，</span></span><br><span class="line">                    <span class="comment">//新阈值都是=新容量 * 0.75。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="transfer扩容方法"><a href="#transfer扩容方法" class="headerlink" title="transfer扩容方法"></a>transfer扩容方法</h3><p>　　<code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持多线程扩容，而且也没有进行加锁，所以实现会变得有点儿复杂。整个扩容操作分为两步：</p><ol><li>构建一个nextTable，其大小为原来大小的<strong>两倍</strong>，这个步骤是在单线程环境下完成的</li><li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协助扩容方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//如果当前table不为null 且 f为ForwardingNode节点 且 //新的table即nextTable存在的情况下才能协助扩容，该方法的作用是让线程参与扩容的复制。</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//更新sizeCtl的值，+1，代表新增一个线程参与扩容</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//根据服务器CPU数量来决定每个线程负责的bucket数量，避免因为扩容的线程过多反而影响性能。</span></span><br><span class="line">    <span class="comment">//如果CPU数量为1，则stride=1，否则将需要迁移的bucket数量(table大小)除以CPU数量，平分给</span></span><br><span class="line">    <span class="comment">//各个线程，但是如果每个线程负责的bucket数量小于限制的最小是(16)的话，则强制给每个线程</span></span><br><span class="line">    <span class="comment">//分配16个bucket数。</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果nextTable还未初始化，则初始化nextTable，这个初始化和iniTable初始化一样，只能由</span></span><br><span class="line">    <span class="comment">//一个线程完成。</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//分配任务和控制当前线程的任务进度，这部分是transfer()的核心逻辑，描述了如何与其他线</span></span><br><span class="line">    <span class="comment">//程协同工作。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//迁移过程（对当前指向的bucket），这部分的逻辑与HashMap类似，拿旧数组的容量当做一</span></span><br><span class="line">        <span class="comment">//个掩码，然后与节点的hash进行与操作，可以得出该节点的新增有效位，如果新增有效位为</span></span><br><span class="line">        <span class="comment">//0就放入一个链表A，如果为1就放入另一个链表B，链表A在新数组中的位置不变（跟在旧数</span></span><br><span class="line">        <span class="comment">//组的索引一致），链表B在新数组中的位置为原索引加上旧数组容量。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="addCount、sumCount方法"><a href="#addCount、sumCount方法" class="headerlink" title="addCount、sumCount方法"></a>addCount、sumCount方法</h3><p>　　<code>addCount()</code>做的工作是更新table的size，也就是table存储的键值对数量，在使用<code>put()</code>和<code>remove()</code>方法的时候都会在执行成功之后调用<code>addCount()</code>来更新table的size。对于<code>ConcurrentHashMap</code>来说，它到底有储存有多少个键值对，谁也不知道，因为他是支持并发的，储存的数量无时无刻都在变化着，所以说<code>ConcurrentHashMap</code>也只是统计一个大概的值，为了统计出这个值也是大费周章才统计出来的。<br>　　<img src="/blogImg/2019/9/22/4-4.jpg" alt></p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//如果计算盒子不是空，或者修改baseCount的值+x失败,则放弃对baseCount的修改。</span></span><br><span class="line">    <span class="comment">//这里的大概意思就是首先尝试直接修改baseCount，达到计数的目的，如果修改baseCount失败(</span></span><br><span class="line">    <span class="comment">//多个线程同时修改，则失败)</span></span><br><span class="line">    <span class="comment">//则使用CounterCell数组来达到计数的目的。</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果计数盒子是空的 或者随机取余一个数组为空 或者修改这个槽位的变量失败，</span></span><br><span class="line">        <span class="comment">//即表示出现了并发，则执行fullAddCount()方法进行死循环插入，同时返回，</span></span><br><span class="line">        <span class="comment">//否则代表修改这个槽位的变量成功了，继续往下执行，不进入if。</span></span><br><span class="line">        <span class="comment">//每个线程都会通过ThreadLocalRandom.getProbe() &amp; m寻址找到属于它的CounterCell，</span></span><br><span class="line">        <span class="comment">//然后进行计数。ThreadLocalRandom是一个线程私有的伪随机数生成器，</span></span><br><span class="line">        <span class="comment">//每个线程的probe都是不同的。CounterCell数组的大小永远是一个2的n次方，初始容量</span></span><br><span class="line">        <span class="comment">//为2，每次扩容的新容量都是之前容量乘以二，处于性能考虑，它的最大容量上限是机器</span></span><br><span class="line">        <span class="comment">//的CPU数量，所以说CounterCell数组的碰撞冲突是很严重的。</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">             <span class="comment">//并发过大，使用CAS修改CounterCell失败时候执行fullAddCount，</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果上面对盒子的赋值成功，且check&lt;=1，则直接返回，否则调用sumConut()方法计算</span></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果check&gt;=0，则检查是否需要扩容。</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="size、mappingCount方法"><a href="#size、mappingCount方法" class="headerlink" title="size、mappingCount方法"></a>size、mappingCount方法</h3><p>　　<code>size</code>和<code>mappingCount</code>方法都是用来统计table的size的，这两者不同的地方在<code>size</code>返回的是一个<code>int</code>类型，即可以表示size的范围是[-2^31，2^31-1]，超过这个范围就返回int能表示的最大值，<code>mappingCount</code>返回的是一个<code>long</code>类型，即可以表示size的范围是[-2^63，2^63-1]。<br>　　这两个方法都是调用的sumCount()方法实现统计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="HashMap、Hashtable、ConcurrentHashMap三者对比"><a href="#HashMap、Hashtable、ConcurrentHashMap三者对比" class="headerlink" title="HashMap、Hashtable、ConcurrentHashMap三者对比"></a>HashMap、Hashtable、ConcurrentHashMap三者对比</h3><table><thead><tr><th><strong>\</strong></th><th><strong>HashMap</strong></th><th><strong>Hashtable</strong></th><th><strong>ConcurrentHashMap</strong></th></tr></thead><tbody><tr><td>是否线程安全</td><td>否</td><td>是</td><td>是</td></tr><tr><td>线程安全采用的方式</td><td></td><td>采用<code>synchronized</code>类锁，效率低</td><td>采用<code>CAS</code> + <code>synchronized</code>，锁住的只有当前操作的<strong>bucket</strong>，不影响其他线程对其他bucket的操作，效率高</td></tr><tr><td>数据结构</td><td>数组+链表+红黑树(链表长度超过8则转红黑树)</td><td>数组+链表</td><td>数组+链表+红黑树(链表长度超过8则转红黑树)</td></tr><tr><td>是否允许<code>null</code>键值</td><td>是</td><td>否</td><td>否</td></tr><tr><td>哈希地址算法</td><td>(key的hashCode)^(key的hashCode无符号右移16位)</td><td>key的hashCode</td><td>( (key的hashCode)^(key的hashCode无符号右移16位) )&amp;0x7fffffff</td></tr><tr><td>定位算法</td><td>哈希地址&amp;(容量大小-1)</td><td>(哈希地址&amp;0x7fffffff)%容量大小</td><td>哈希地址&amp;(容量大小-1)</td></tr><tr><td>扩容算法</td><td>当键值对数量大于阈值，则容量扩容到原来的2倍</td><td>当键值对数量大于等于阈值，则容量扩容到原来的2倍+1</td><td>当键值对数量大于等于sizeCtl，<strong>单线程创建新哈希表，多线程复制bucket到新哈希表</strong>，容量扩容到原来的2倍</td></tr><tr><td>链表插入</td><td>将新节点插入到链表<strong>尾部</strong></td><td>将新节点插入到链表<strong>头部</strong></td><td>将新节点插入到链表<strong>尾部</strong></td></tr><tr><td>继承的类</td><td>继承<code>abstractMap</code>抽象类</td><td>继承<code>Dictionary</code>抽象类</td><td>继承<code>abstractMap</code>抽象类</td></tr><tr><td>实现的接口</td><td>实现<code>Map</code>接口</td><td>实现<code>Map</code>接口</td><td>实现<code>ConcurrentMap</code>接口</td></tr><tr><td>默认容量大小</td><td>16</td><td>11</td><td>16</td></tr><tr><td>默认负载因子</td><td>0.75</td><td>0.75</td><td>0.75</td></tr><tr><td>统计size方式</td><td>直接返回成员变量<code>size</code></td><td>直接返回成员变量<code>count</code></td><td>遍历<code>CounterCell</code>数组的值进行累加，最后加上<code>baseCount</code>的值即为<code>size</code></td></tr></tbody></table><p>　　</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://cmsblogs.com/?p=2283" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentHashMap</a><br><a href="http://www.importnew.com/29832.html" target="_blank" rel="noopener">Map 大家族的那点事儿 ( 7 ) ：ConcurrentHashMap</a><br><a href="http://www.importnew.com/28263.html?tdsourcetag=s_pcqq_aiomsg&amp;replytocom=667559#respond" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a><br><a href="https://juejin.im/entry/59fc786d518825297f3fa968" target="_blank" rel="noopener">Java 8 ConcurrentHashMap源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>常见OOM原因及解决方案</title>
    <link href="https://mlone.top/2019/09/22/%E5%B8%B8%E8%A7%81OOM%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://mlone.top/2019/09/22/常见OOM原因及解决方案/</id>
    <published>2019-09-22T08:14:54.000Z</published>
    <updated>2019-09-22T08:43:20.249Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>来自微信公众号：java深度理解</p><br><a id="more"></a><p></p><p>　　<br>　　当 JVM 内存严重不足时，就会抛出 java.lang.OutOfMemoryError 错误。本文总结了常见的 OOM 原因及其解决方法，如下图所示：<br>　　<img src="/blogImg/2019/9/22/3-1.png" alt></p><p>　　</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>Java heap space</li><li>GC overhead limit exceeded</li><li>Permgen spaceMetaspace</li><li>Unable to create new native thread</li><li>Out of swap space？</li><li>Kill process or sacrifice child</li><li>Requested array size exceeds VM limit</li><li>Direct buffer memory</li><li>推荐工具&amp;产品</li></ul><p>　　</p><h3 id="1-Java-heap-space"><a href="#1-Java-heap-space" class="headerlink" title="1. Java heap space"></a>1. Java heap space</h3><p>　　当堆内存（Heap Space）没有足够空间存放新创建的对象时，就会抛出 <code>java.lang.OutOfMemoryError: Java heap space</code>错误（根据实际生产经验，可以对程序日志中的 <code>OutOfMemoryError</code> 配置关键字告警，一经发现，立即处理）。</p><p><strong>原因分析：</strong><br>　　Java heap space 错误产生的常见原因可以分为以下几类：</p><ul><li>请求创建一个超大对象，通常是一个大数组。</li><li>超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。</li><li>过度使用终结器（Finalizer），该对象没有立即被 GC。</li><li>内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。</li></ul><p><strong>解决方案：</strong><br>　　针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理：</p><pre><code>* 如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。* 如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。* 如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。</code></pre><p>　　</p><h3 id="2-GC-overhead-limit-exceeded"><a href="#2-GC-overhead-limit-exceeded" class="headerlink" title="2. GC overhead limit exceeded"></a>2. GC overhead limit exceeded</h3><p>　　当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，就会抛出 java.lang.OutOfMemoryError:GC overhead limit exceeded 错误。简单地说，就是应用程序已经基本耗尽了所有可用内存， GC 也无法回收。</p><p>　　此类问题的原因与解决方案跟 Java heap space 非常类似，可以参考上文。</p><p>　　</p><h3 id="3-Permgen-space"><a href="#3-Permgen-space" class="headerlink" title="3. Permgen space"></a>3. Permgen space</h3><p>　　该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。</p><p><strong> 原因分析：</strong><br>　　永久代存储对象主要包括以下几类：</p><ul><li>加载/缓存到内存中的 class 定义，包括类的名称，字段，方法和字节码；</li><li>常量池；</li><li>对象数组/类型数组所关联的 class；</li><li>JIT 编译器优化后的 class 信息。</li></ul><p>　　PermGen 的使用量与加载到内存的 class 的数量/大小正相关。</p><p><strong>解决方案：</strong><br>　　根据 Permgen space 报错的时机，可以采用不同的解决方案，如下所示：</p><pre><code>* 程序启动报错，修改 -XX:MaxPermSize 启动参数，调大永久代空间。* 应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份 class 信息，只需重启 JVM 即可解决。* 运行时报错，应用程序可能会动态创建大量 class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，可以设置 `-XX:+CMSClassUnloadingEnabled `和 `-XX:+UseConcMarkSweepGC` 这两个参数允许 JVM 卸载 class。</code></pre><p>　　如果上述方法无法解决，可以通过 jmap 命令 dump 内存对象 jmap -dump:format=b,file=dump.hprof <process-id> ，然后利用 Eclipse MAT 功能逐一分析开销最大的 classloader 和重复 class。</process-id></p><p>　　</p><h3 id="4-Metaspace"><a href="#4-Metaspace" class="headerlink" title="4. Metaspace"></a>4. Metaspace</h3><p>　　JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），该错误表示 Metaspace 已被用满，通常是因为加载的 class 数目太多或体积太大。<br>此类问题的原因与解决方法跟 Permgen space 非常类似，可以参考上文。需要特别注意的是调整 Metaspace 空间大小的启动参数为<code>-XX:MaxMetaspaceSize</code>。</p><p>　　</p><h3 id="5-Unable-to-create-new-native-thread"><a href="#5-Unable-to-create-new-native-thread" class="headerlink" title="5. Unable to create new native thread"></a>5. Unable to create new native thread</h3><p>　　每个 Java 线程都需要占用一定的内存空间，当 JVM 向底层操作系统请求创建一个新的 native 线程时，如果没有足够的资源分配就会报此类错误。</p><p><strong> 原因分析：</strong><br>　　JVM 向 OS 请求创建 native 线程失败，就会抛出 Unable to create new native thread，常见的原因包括以下几类：</p><ul><li>线程数超过操作系统最大线程数 ulimit 限制。</li><li>线程数超过 kernel.pid_max（只能重启）。</li><li>native 内存不足。</li></ul><p>该问题发生的常见过程主要包括以下几步：</p><pre><code>1. JVM 内部的应用程序请求创建一个新的 Java 线程；2. JVM native 方法代理了该次请求，并向操作系统请求创建一个 native 线程；3. 操作系统尝试创建一个新的 native 线程，并为其分配内存；4. 如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次 native 内存分配；5. JVM 将抛出 java.lang.OutOfMemoryError: Unable to create new native thread 错误。</code></pre><p><strong>解决方案：</strong></p><pre><code>* 升级配置，为机器提供更多的内存；* 降低 Java Heap Space 大小；* 修复应用程序的线程泄漏问题；* 限制线程池大小；* 使用 -Xss 参数减少线程栈的大小；* 调高 OS 层面的线程最大数：执行 ulimia -a 查看最大线程数限制，使用 ulimit -u xxx 调整最大线程数限制。</code></pre><hr><pre><code>ulimit -a.... 省略部分内容 .....max user processes              (-u) 16384</code></pre><p>　　</p><h3 id="6-Out-of-swap-space？"><a href="#6-Out-of-swap-space？" class="headerlink" title="6. Out of swap space？"></a>6. Out of swap space？</h3><p>　　该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。当运行时程序请求的虚拟内存溢出时就会报 Out of swap space? 错误。</p><p><strong>原因分析：</strong><br>　　该错误出现的常见原因包括以下几类：</p><pre><code>* 地址空间不足；* 物理内存已耗光；* 应用程序的本地内存泄漏（native leak），例如不断申请本地内存，却不释放。* 执行 jmap -histo:live 命令，强制执行 Full GC；如果几次执行后内存明显下降，则基本确认为 Direct ByteBuffer 问题。</code></pre><p><strong>解决方案：</strong></p><p>　　根据错误原因可以采取如下解决方案：</p><pre><code>* 升级地址空间为 64 bit；* 使用 Arthas 检查是否为 Inflater/Deflater 解压缩问题，如果是，则显式调用 end 方法。* Direct ByteBuffer 问题可以通过启动参数 -XX:MaxDirectMemorySize 调低阈值。* 升级服务器配置/隔离部署，避免争用。</code></pre><p>　　</p><h3 id="7-Kill-process-or-sacrifice-child"><a href="#7-Kill-process-or-sacrifice-child" class="headerlink" title="7. Kill process or sacrifice child"></a>7. Kill process or sacrifice child</h3><p>　　有一种内核作业（Kernel Job）名为 Out of Memory Killer，它会在可用内存极低的情况下“杀死”（kill）某些进程。OOM Killer 会对所有进程进行打分，然后将评分较低的进程“杀死”，具体的评分规则可以参考 Surviving the Linux OOM Killer。<br>不同于其他的 OOM 错误，Kill process or sacrifice child 错误不是由 JVM 层面触发的，而是由操作系统层面触发的。</p><p><strong>原因分析：</strong><br>　　默认情况下，Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。</p><p>　　然而，这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。</p><p><strong>解决方案：</strong></p><pre><code>* 升级服务器配置/隔离部署，避免争用。* OOM Killer 调优。</code></pre><p>　　</p><h3 id="8-Requested-array-size-exceeds-VM-limit"><a href="#8-Requested-array-size-exceeds-VM-limit" class="headerlink" title="8. Requested array size exceeds VM limit"></a>8. Requested array size exceeds VM limit</h3><p>　　JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。<br>　　JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为 <code>Integer.MAX_VALUE - 2</code>。<br>　　此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。</p><p>　　</p><h3 id="9-Direct-buffer-memory"><a href="#9-Direct-buffer-memory" class="headerlink" title="9. Direct buffer memory"></a>9. Direct buffer memory</h3><p>　　Java 允许应用程序通过 Direct ByteBuffer 直接访问堆外内存，许多高性能程序通过 Direct ByteBuffer 结合内存映射文件（Memory Mapped File）实现高速 IO。</p><p><strong>原因分析：</strong><br>　　Direct ByteBuffer 的默认大小为 64 MB，一旦使用超出限制，就会抛出 Direct buffer memory 错误。</p><p><strong>解决方案：</strong></p><pre><code>* Java 只能通过 ByteBuffer.allocateDirect 方法使用 Direct ByteBuffer，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查。* 检查是否直接或间接使用了 NIO，如 netty，jetty 等。* 通过启动参数 -XX:MaxDirectMemorySize 调整 Direct ByteBuffer 的上限值。* 检查 JVM 参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc() 失效。* 检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用 sun.misc.Cleaner 的 clean() 方法来主动释放被 Direct ByteBuffer 持有的内存空间。* 内存容量确实不足，升级配置。</code></pre><p>　　</p><h3 id="推荐工具-amp-产品"><a href="#推荐工具-amp-产品" class="headerlink" title="推荐工具&amp;产品"></a>推荐工具&amp;产品</h3><ul><li>Eclipse Memory Analyzer —— JVM 内存分析工具</li><li>ARMS —— 阿里云 APM 产品，支持 OOM 异常关键字告警</li><li>Arthas —— Java 在线诊断工具</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;来自微信公众号：java深度理解&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>ArrayList源码分析（扩容机制jdk8）</title>
    <link href="https://mlone.top/2019/09/22/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6jdk8%EF%BC%89/"/>
    <id>https://mlone.top/2019/09/22/ArrayList源码分析（扩容机制jdk8）/</id>
    <published>2019-09-22T07:41:52.000Z</published>
    <updated>2019-09-22T08:10:52.205Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://juejin.im/post/5d42ab5e5188255d691bc8d6" target="_blank" rel="noopener">https://juejin.im/post/5d42ab5e5188255d691bc8d6</a><br><a id="more"></a></p><p>　　</p><h3 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h3><hr><p>（1）<code>ArrayList</code> 是一种变长的集合类，基于定长数组实现。</p><p>（2）<code>ArrayList</code> 允许空值和重复元素，当往 ArrayList 中添加的元素数量大于其底层数组容量时，其会通过<strong>扩容</strong>机制重新生成一个更大的数组。</p><p>（3）由于 <code>ArrayList</code> 底层基于数组实现，所以其可以保证在 <code>O(1)</code> 复杂度下完成随机查找操作。</p><p>（4）<code>ArrayList</code> 是非线程安全类，并发环境下，多个线程同时操作 ArrayList，会引发不可预知的异常或错误。</p><p>　　</p><h3 id="ArrayList的成员属性"><a href="#ArrayList的成员属性" class="headerlink" title="ArrayList的成员属性"></a>ArrayList的成员属性</h3><hr><p>　　在介绍关于ArrayList的各种方法之前先看一下基础属性成员。其中<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA与EMPTY_ELEMENTDATA的区别是：当我们向数组中添加第一个元素时，DEFAULTCAPACITY_EMPTY_ELEMENTDATA将会知道数组该扩充多少</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的空的数组，这个主要是在构造方法初始化一个空数组的时候使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认size大小的空数组实例，和EMPTY_ELEMENTDATA区分开来，</span></span><br><span class="line"><span class="comment">//这样可以知道当第一个元素添加的时候进行扩容至多少</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList底层存储数据就是通过数组的形式，ArrayList长度就是数组的长度。</span></span><br><span class="line"><span class="comment">//一个空的实例elementData为上面的DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当添加第一个元素的时候</span></span><br><span class="line"><span class="comment">//会进行扩容，扩容大小就是上面的默认容量DEFAULT_CAPACITY</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//arrayList的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p><p>　　static修饰的<code>EMPTY_ELEMENTDATA</code>和<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code><br>　　<img src="/blogImg/2019/9/22/2-1.png" alt></p><p>　　</p><h3 id="ArrayList构造方法"><a href="#ArrayList构造方法" class="headerlink" title="ArrayList构造方法"></a>ArrayList构造方法</h3><hr><p>（1）带有初始化容量的构造方法</p><ul><li>参数大于0，elementData初始化为initialCapacity大小的数组</li><li>参数小于0，elementData初始化为空数组</li><li>参数小于0，抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数为初始化容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断容量的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//elementData才是实际存放元素的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果传递的长度为0，就是直接使用自己已经定义的成员变量(一个空数组)</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<br>（2）无参构造</p><ul><li>构造方法中将elementData初始化为空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA</li><li>当调用add方法添加第一个元素的时候，会进行扩容</li><li>扩容至大小为DEFAULT_CAPACITY=10</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造，使用默认的size为10的空数组，在构造方法中没有对数组长度进行设置，会在后续调用add方法的时候进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<br>（3）参数为Collection类型的构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个参数为Collection的集合转变为ArrayList（实际上就是将集合中的元素换为了数组的形式）。如果</span></span><br><span class="line"><span class="comment">//传入的集合为null会抛出空指针异常（调用c.toArray()方法的时候）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//c.toArray()可能不会正确地返回一个 Object[]数组，那么使用Arrays.copyOf()方法</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果集合转换为数组之后数组长度为0，就直接使用自己的空成员变量初始化elementData</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面的这些构造方法理解起来比较简单，关注前两个构造方法做的事情，目的都是<strong>初始化底层数组 elementData(this.elementData=XXX)</strong>。区别在于<code>无参构造方法会将 elementData 初始化一个空数组，插入元素时，扩容将会按默认值重新初始化数组</code>。而<code>有参的构造方法则会将 elementData 初始化为参数值大小（&gt;= 0）的数组</code>。一般情况下，我们用默认的构造方法即可。倘若在可知道将会向 ArrayList 插入多少元素的情况下，可以使用有参构造方法。</p><p>　　<br>　　上面说到了使用无参构造的时候，在调用add方法的时候会进行扩容，所以下面我们就看看add方法以及扩容的细节</p><h3 id="ArrayList的add方法"><a href="#ArrayList的add方法" class="headerlink" title="ArrayList的add方法"></a>ArrayList的add方法</h3><hr><h4 id="add方法大致流程"><a href="#add方法大致流程" class="headerlink" title="add方法大致流程"></a>add方法大致流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将指定元素添加到list的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为要添加元素，所以添加之后可能导致容量不够，所以需要在添加之前进行判断（扩容）</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!（待会会介绍到fast-fail）</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　我们看到add方法中在添加元素之前，会先判断size的大小，所以我们来看看ensureCapacityInternal方法的细节</p><p>　　</p><h4 id="ensureCapacityInternal方法分析"><a href="#ensureCapacityInternal方法分析" class="headerlink" title="ensureCapacityInternal方法分析"></a>ensureCapacityInternal方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里就是判断elementData数组是不是为空数组</span></span><br><span class="line">    <span class="comment">//（使用的无参构造的时候，elementData=DEFAULTCAPACITY_EMPTY_ELEMENTDATA）</span></span><br><span class="line">    <span class="comment">//如果是，那么比较size+1(第一次调用add的时候size+1=1)和DEFAULT_CAPACITY，</span></span><br><span class="line">    <span class="comment">//那么显然容量为10</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<strong>当 要 add 进第1个元素时，minCapacity为(size+1=0+1=)1，在Math.max()方法比较后，minCapacity 为10。</strong>然后紧接着调用ensureExplicitCapacity更新modCount的值，并判断是否需要扩容</p><p>　　</p><h4 id="ensureExplicitCapacity方法分析"><a href="#ensureExplicitCapacity方法分析" class="headerlink" title="ensureExplicitCapacity方法分析"></a>ensureExplicitCapacity方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++; <span class="comment">//这里就是add方法中注释的Increments modCount</span></span><br><span class="line">    <span class="comment">//溢出</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);<span class="comment">//这里就是执行扩容的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<br>　　下面来看一下扩容的主要方法grow。</p><h4 id="grow方法分析"><a href="#grow方法分析" class="headerlink" title="grow方法分析"></a>grow方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧数组的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// newCapacity为新数组的容量（oldCap+oldCap/2:即更新为旧容量的1.5倍）</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 检查新容量的大小是否小于最小需要容量，如果小于那旧将最小容量最为数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果新容量大于MAX_ARRAY_SIZE，使用hugeCapacity比较二者</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 将原数组中的元素拷贝</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h4 id="hugeCapacity方法"><a href="#hugeCapacity方法" class="headerlink" title="hugeCapacity方法"></a>hugeCapacity方法</h4><p>这里简单看一下hugeCapacity方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h4 id="add方法执行流程总结"><a href="#add方法执行流程总结" class="headerlink" title="add方法执行流程总结"></a>add方法执行流程总结</h4><p>　　我们用一幅图来简单梳理一下，当使用无参构造的时候，在第一次调用add方法之后的执行流程<br>　　<img src="/blogImg/2019/9/22/2-2.png" alt></p><p>这是第一次调用add方法的过程，当扩容值capacity为10之后，</p><ul><li>继续添加第2个元素（先注意调用<code>ensureCapacityInternal</code>方法传递的参数为<code>size+1=1+1=2</code>）</li><li>在<code>ensureCapacityInternal</code>方法中，<code>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>不成立，所以直接执行<code>ensureExplicitCapacity</code>方法</li><li><code>ensureExplicitCapacity</code>方法中<code>minCapacity</code>为刚刚传递的2，所以第二个if判断<code>（2-10=-8）</code>不会成立，即<code>newCapacity</code> 不比 <code>MAX_ARRAY_SIZE</code>大，则不会进入 <code>grow</code> 方法。数组容量为10，<code>add</code>方法中<code>return true</code>, size增为1。</li><li>假设又添加3、4……10个元素（其中过程类似，但是不会执行grow扩容方法）</li><li>当add第11个元素时候，会进入<code>grow</code>方法时，计算<code>newCapacity</code>为15，比<code>minCapacity</code>（为10+1=11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入<code>hugeCapacity</code>方法。数组容量扩为15，<code>add</code>方法中<code>return true</code>,size增为11。</li></ul><p>　　</p><h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index,E element)方法"></a>add(int index,E element)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在元素序列 index 位置处插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index); <span class="comment">//校验传递的index参数是不是合法</span></span><br><span class="line">    <span class="comment">// 1. 检测是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2. 将 index 及其之后的所有元素都向后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 3. 将新元素插入至 index 处</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>) <span class="comment">//这里判断的index&gt;size（保证数组的连续性），index小于0</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>add(int index, E element)</code>方法（在元素序列指定位置（<code>假设该位置合理</code>）插入）的过程大概是下面这些</p><ol><li>检测数组是否有足够的空间(这里的实现和上面的)</li><li>将 index 及其之后的所有元素向后移一位</li><li>将新元素插入至 index 处.</li></ol><p>　　将新元素插入至序列指定位置，需要先将该位置及其之后的元素都向后移动一位，为新元素腾出位置。这个操作的时间复杂度为<code>O(N)</code>，频繁移动元素可能会导致效率问题，特别是集合中元素数量较多时。在日常开发中，若非所需，我们应当尽量避免在大集合中调用第二个插入方法。</p><p>　　</p><h3 id="ArrayList的remove方法"><a href="#ArrayList的remove方法" class="headerlink" title="ArrayList的remove方法"></a>ArrayList的remove方法</h3><hr><p>ArrayList支持两种删除元素的方式：<br>1、remove(int index) 按照下标删除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//校验下标是否合法（如果index&gt;size，旧抛出IndexOutOfBoundsException异常）</span></span><br><span class="line">    modCount++;<span class="comment">//修改list结构，就需要更新这个值</span></span><br><span class="line">    E oldValue = elementData(index); <span class="comment">//直接在数组中查找这个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//这里计算所需要移动的数目</span></span><br><span class="line">    <span class="comment">//如果这个值大于0 说明后续有元素需要左移(size=index+1)</span></span><br><span class="line">    <span class="comment">//如果是0说明被移除的对象就是最后一位元素(不需要移动别的元素)</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//索引index只有的所有元素左移一位  覆盖掉index位置上的元素</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//移动之后，原数组中size位置null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">//返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//src:源数组   </span></span><br><span class="line"><span class="comment">//srcPos:从源数组的srcPos位置处开始移动</span></span><br><span class="line"><span class="comment">//dest:目标数组</span></span><br><span class="line"><span class="comment">//desPos:源数组的srcPos位置处开始移动的元素，这些元素从目标数组的desPos处开始填充</span></span><br><span class="line"><span class="comment">//length:移动源数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p><p> 删除过程如下图所示<br>　　<img src="/blogImg/2019/9/22/2-3.png" alt></p><p>　　<br>2、remove(Object o) 按照元素删除，会删除和参数匹配的第一个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果元素是null 遍历数组移除第一个null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历找到第一个null元素的下标 调用下标移除元素的方法</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到元素对应的下标 调用下标移除元素的方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照下标移除元素（通过数组元素的位置移动来达到删除的效果）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="ArrayList的其他方法"><a href="#ArrayList的其他方法" class="headerlink" title="ArrayList的其他方法"></a>ArrayList的其他方法</h3><hr><h4 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a>ensureCapacity方法</h4><p><strong>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量从新分配的次数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="ArrayList总结"><a href="#ArrayList总结" class="headerlink" title="ArrayList总结"></a>ArrayList总结</h3><hr><p>（1）<code>ArrayList</code> 是一种变长的集合类，基于定长数组实现，使用默认构造方法初始化出来的容量是10（1.7之后都是延迟初始化，即第一次调用add方法添加元素的时候才将elementData容量初始化为10）。</p><p>（2）<code>ArrayList</code> 允许空值和重复元素，当往 ArrayList 中添加的元素数量大于其底层数组容量时，其会通过<strong>扩容</strong>机制重新生成一个更大的数组。<code>ArrayList</code>扩容的长度是原长度的1.5倍</p><p>（3）由于 <code>ArrayList</code> 底层基于数组实现，所以其可以保证在 <code>O(1)</code> 复杂度下完成随机查找操作。</p><p>（4）<code>ArrayList</code> 是非线程安全类，并发环境下，多个线程同时操作 ArrayList，会引发不可预知的异常或错误。</p><p>（5）顺序添加很方便</p><p>（6）删除和插入需要复制数组，性能差（可以使用LinkindList）</p><p>（7）Integer.MAX_VALUE - 8 ：主要是考虑到不同的JVM,有的JVM会在加入一些数据头,当扩容后的容量大于MAX_ARRAY_SIZE,我们会去比较最小需要容量和MAX_ARRAY_SIZE做比较,如果比它大, 只能取Integer.MAX_VALUE,否则是Integer.MAX_VALUE -8。 这个是从jdk1.7开始才有的</p><p>　　</p><h3 id="fast-fail机制"><a href="#fast-fail机制" class="headerlink" title="fast-fail机制"></a>fast-fail机制</h3><hr><p>fail-fast的解释：</p><blockquote><p>在系统设计中，快速失效系统一种可以立即报告任何可能表明故障的情况的系统。快速失效系统通常设计用于停止正常操作，而不是试图继续可能存在缺陷的过程。这种设计通常会在操作中的多个点检查系统的状态，因此可以及早检测到任何故障。快速失败模块的职责是检测错误，然后让系统的下一个最高级别处理错误。</p></blockquote><p>　　就是在做系统设计的时候先考虑异常情况，一旦发生异常，直接停止并上报，比如下面的这个简单的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的代码是一个对两个整数做除法的方法，在fast_fail_method方法中，我们对被除数做了个简单的检查，如果其值为0，那么就直接抛出一个异常，并明确提示异常原因。这其实就是fail-fast理念的实际应用。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fast_fail_method</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">int</span> arg2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg2 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't be zero"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arg1/arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在Java集合类中很多地方都用到了该机制进行设计，一旦使用不当，触发fail-fast机制设计的代码，就会发生非预期情况。我们通常说的Java中的fail-fast机制，<strong>默认指的是Java集合的一种错误检测机制</strong>。当多个线程对部分集合进行结构上的改变的操作时，有可能会触发该机制时，之后就会抛出并发修改异常<strong><code>ConcurrentModificationException</code></strong>.当然如果不在多线程环境下，如果在foreach遍历的时候使用add/remove方法，也可能会抛出该异常。参考<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F3542" target="_blank" rel="noopener">fast-fail机制</a>，这里简单做个总结</p><p>　　<code>之所以会抛出ConcurrentModificationException异常，是因为我们的代码中使用了增强for循环，而在增强for循环中，集合遍历是通过iterator进行的，但是元素的add/remove却是直接使用的集合类自己的方法。这就导致iterator在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被删除/添加了，就会抛出一个异常，用来提示可能发生了并发修改！所以，在使用Java的集合类的时候，如果发生ConcurrentModificationException，优先考虑fail-fast有关的情况，实际上这可能并没有真的发生并发，只是Iterator使用了fail-fast的保护机制，只要他发现有某一次修改是未经过自己进行的，那么就会抛出异常。</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://juejin.im/post/5d42ab5e5188255d691bc8d6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5d42ab5e5188255d691bc8d6&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring WebClient与RestTemplate比较</title>
    <link href="https://mlone.top/2019/09/22/Spring-WebClient%E4%B8%8ERestTemplate%E6%AF%94%E8%BE%83/"/>
    <id>https://mlone.top/2019/09/22/Spring-WebClient与RestTemplate比较/</id>
    <published>2019-09-22T07:27:10.000Z</published>
    <updated>2019-09-22T07:35:45.234Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://www.baeldung.com/spring-webclient-resttemplate" target="_blank" rel="noopener">https://www.baeldung.com/spring-webclient-resttemplate</a><br><a id="more"></a></p><p>　　</p><h3 id="1-导读"><a href="#1-导读" class="headerlink" title="1. 导读"></a><strong>1. 导读</strong></h3><p>　　在这篇教程中，我们将对比两种 Spring Web 客户端实现，RestTemplate 和新的 Spring 5 Reactive WebClient。</p><p>　　</p><h3 id="2-阻塞式客户端-vs-非阻塞客户端"><a href="#2-阻塞式客户端-vs-非阻塞客户端" class="headerlink" title="2. 阻塞式客户端 vs 非阻塞客户端"></a><strong>2. 阻塞式客户端 vs 非阻塞客户端</strong></h3><p>　　在 Web 应用程序中，向其他服务发起 HTTP 调用是常见需求。因此，需要一个 Web 客户端工具。</p><p>　　</p><h4 id="2-1-RestTemplate-阻塞式客户端"><a href="#2-1-RestTemplate-阻塞式客户端" class="headerlink" title="2.1. RestTemplate 阻塞式客户端"></a><strong>2.1. RestTemplate 阻塞式客户端</strong></h4><p>　　长期以来，Spring 一直把 RestTemplate 作为默认 Web 客户端。<strong>RestTemplate 使用 Java Servlet API，这种模型在底层会为每个请求分配处理线程</strong>。</p><p>　　这意味着线程会一直保持阻塞，直到 Web 客户端收到响应。阻塞式模型的问题在于每个线程都会消耗大量内存和 CPU 资源。</p><p>　　让我们考虑这样的情况：系统收到大批请求时，等待某些服务返回结果，而这些服务本身执行缓慢。</p><p>　　结果，等待的请求会发生堆积。<strong>应用程序将创建许多线程，耗尽线程池并占掉所有可用内存</strong>。还可能因为 CPU 上下文（线程）频繁切换导致性能下降。</p><p>　　</p><h4 id="2-2-WebClient-非阻塞客户端"><a href="#2-2-WebClient-非阻塞客户端" class="headerlink" title="2.2. WebClient 非阻塞客户端"></a><strong>2.2. WebClient 非阻塞客户端</strong></h4><p>　　另一种 WebClient 方案，利用 Spring Reactive 框架提供异步、非阻塞式解决方案。</p><p>　　RestTemplate 为每个事件（HTTP 调用）创建一个新线程，而 WebClient 为每个事件创建类似 task 的结构。Reactive 框架会在后台对这些 task 进行排队，且只在响应结果就绪后才开始执行。</p><p>　　Reactive 框架采用事件驱动，通过Reactive Streams API 实现异步逻辑。相比同步阻塞式调用，Reactive 方法用更少的线程和系统资源处理了更多业务逻辑。</p><p>　　Webclient 是 Spring WebFlux 开发库的一部分。因此，<strong>写客户端代码时，还可以应用函数式编程与流式 API，支持 Reactive 类型（Mono 和 Flux）</strong>。</p><p>　　</p><h3 id="3-实例比较"><a href="#3-实例比较" class="headerlink" title="3. 实例比较"></a>3. 实例比较</h3><p>　　为了展示两种方法差异，需要多客户端并行请求进行性能测试。可以看到，收到多个客户端请求后，阻塞方法的性能显著下降。</p><p>　　而 Reactive 非阻塞方法的表现应该与请求数量无关，性能稳定。</p><p>　　这里会实现两个 REST Endpoint：一个用 RestTemplate，另一个用 WebClient。它们的任务是调用另一个耗时的 REST Web 服务，返回推文列表。</p><p>首先，需要添加 Spring Boot WebFlux Starter 依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>下面 REST Endpoint，比较耗时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/slow-service-tweets"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Tweet&gt; <span class="title">getAllTweets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>); *<span class="comment">// 延迟*</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Tweet(<span class="string">"RestTemplate rules"</span>, <span class="string">"@user1"</span>),</span><br><span class="line">      <span class="keyword">new</span> Tweet(<span class="string">"WebClient is better"</span>, <span class="string">"@user2"</span>),</span><br><span class="line">      <span class="keyword">new</span> Tweet(<span class="string">"OK, both are useful"</span>, <span class="string">"@user1"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h4 id="3-1-RestTemplate-调用耗时服务"><a href="#3-1-RestTemplate-调用耗时服务" class="headerlink" title="3.1. RestTemplate 调用耗时服务"></a><strong>3.1. RestTemplate 调用耗时服务</strong></h4><p>　　接着实现 REST Endpoint，通过 WebClient 调用耗时服务。</p><p>　　先使用 RestTemplate：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/tweets-blocking"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Tweet&gt; <span class="title">getTweetsBlocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Starting BLOCKING Controller!"</span>);</span><br><span class="line">    <span class="keyword">final</span> String uri = getSlowServiceUri();</span><br><span class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    ResponseEntity&lt;List&lt;Tweet&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">      uri, HttpMethod.GET, <span class="keyword">null</span>,</span><br><span class="line">      <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;Tweet&gt;&gt;()&#123;&#125;);</span><br><span class="line">    List&lt;Tweet&gt; result = response.getBody();</span><br><span class="line">    result.forEach(tweet -&gt; log.info(tweet.toString()));</span><br><span class="line">    log.info(<span class="string">"Exiting BLOCKING Controller!"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　由于 RestTemplate 是同步调用，调用 Endpoint 时代码将进入阻塞等待被调用的耗时服务响应。只有在收到响应后，才会执行方法中的后续代码。通过日志可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Starting BLOCKING Controller!</span><br><span class="line">Tweet(text=RestTemplate rules, username=@user1)</span><br><span class="line">Tweet(text=WebClient is better, username=@user2)</span><br><span class="line">Tweet(text=OK, both are useful, username=@user1)</span><br><span class="line">Exiting BLOCKING Controller!</span><br></pre></td></tr></table></figure></p><p>　　</p><h4 id="3-2-WebClient-调用耗时服务"><a href="#3-2-WebClient-调用耗时服务" class="headerlink" title="3.2. WebClient 调用耗时服务"></a><strong>3.2. WebClient 调用耗时服务</strong></h4><p>　　接下来用 WebClient 调用耗时服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/tweets-non-blocking"</span>,</span><br><span class="line">            produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;Tweet&gt; <span class="title">getTweetsNonBlocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Starting NON-BLOCKING Controller!"</span>);</span><br><span class="line">    Flux&lt;Tweet&gt; tweetFlux = WebClient.create()</span><br><span class="line">      .get()</span><br><span class="line">      .uri(getSlowServiceUri())</span><br><span class="line">      .retrieve()</span><br><span class="line">      .bodyToFlux(Tweet.class);</span><br><span class="line">    tweetFlux.subscribe(tweet -&gt; log.info(tweet.toString()));</span><br><span class="line">    log.info(<span class="string">"Exiting NON-BLOCKING Controller!"</span>);</span><br><span class="line">    <span class="keyword">return</span> tweetFlux;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面的情况，WebClient 返回 Flux publisher 后就执行完成了。结果就绪时，publisher 会向订阅者发送推文列表。注意：客户端（这里指 Web 浏览器）调用 /tweets-non-blocking Endpoint 也可以订阅 Flux 对象。</p><p>这次的日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Starting NON-BLOCKING Controller!</span><br><span class="line">Exiting NON-BLOCKING Controller!</span><br><span class="line">Tweet(text=RestTemplate rules, username=@user1)</span><br><span class="line">Tweet(text=WebClient is better, username=@user2)</span><br><span class="line">Tweet(text=OK, both are useful, username=@user1)</span><br></pre></td></tr></table></figure></p><p>　　请注意：这个 Endpoint 方法在收到响应前就已执行完成。</p><p>　　</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>　　这篇文章讨论了 Spring 中使用 Web Client 的两种不同方式。</p><p>　　RestTemplate 采用 Java Servlet API，因而是阻塞式同步调用。相反，WebClient 是异步的，等待响应的同时不会阻塞正在执行的线程。只有在响应结果准备就绪时，才会发起通知。</p><p>　　RestTemplate 仍然有用武之地。非阻塞模式在某些场景下比阻塞方法占用系统资源要少得多，这时 WebClient 是一种更好的选择。</p><p>　　本文所有源代码可以在 GitHub 上找到：<br>github.com/eugenp/tutorials/tree/master/spring-5-reactive-2</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://www.baeldung.com/spring-webclient-resttemplate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.baeldung.com/spring-webclient-resttemplate&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
      <category term="Spring" scheme="https://mlone.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring如何解决循环依赖的问题</title>
    <link href="https://mlone.top/2019/09/22/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://mlone.top/2019/09/22/Spring如何解决循环依赖的问题/</id>
    <published>2019-09-22T06:59:26.000Z</published>
    <updated>2019-09-22T07:21:12.649Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://my.oschina.net/zhangxufeng/blog/3096394" target="_blank" rel="noopener">https://my.oschina.net/zhangxufeng/blog/3096394</a><br><a id="more"></a></p><p>　　<br>　　在关于Spring的面试中，我们经常会被问到一个问题，就是Spring是如何解决循环依赖的问题的。这个问题算是关于Spring的一个高频面试题，因为如果不刻意研读，相信即使读过源码，面试者也不一定能够一下子思考出个中奥秘。本文主要针对这个问题，从源码的角度对其实现原理进行讲解。</p><p>　　</p><h3 id="1-过程演示"><a href="#1-过程演示" class="headerlink" title="1. 过程演示"></a>1. 过程演示</h3><p>　　关于Spring bean的创建，其本质上还是一个对象的创建，既然是对象，读者朋友一定要明白一点就是，一个完整的对象包含两部分：当前对象实例化和对象属性的实例化。在Spring中，对象的实例化是通过反射实现的，而对象的属性则是在对象实例化之后通过一定的方式设置的。这个过程可以按照如下方式进行理解：<br>　　<img src="/blogImg/2019/9/22/1-1.jpg" alt></p><p>　　理解这一个点之后，对于循环依赖的理解就已经帮助一大步了，我们这里以两个类A和B为例进行讲解，如下是A和B的声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以看到，这里A和B中各自都以对方为自己的全局属性。这里首先需要说明的一点是，Spring实例化bean是通过<code>pplicationContext.getBean()</code>法来进行的。如果要获取的对象依赖了另一个对象，那么其首先会创建当前对象，然后通过递归的调用<code>pplicationContext.getBean()</code>法来获取所依赖的对象，最后将获取到的对象注入到当前对象中。<br>　　<br>　　这里我们以上面的首先初始化A对象实例为例进行讲解。首先Spring尝试通过<code>pplicationContext.getBean()</code>法获取A对象的实例，由于Spring容器中还没有A对象实例，因而其会创建一个A对象，然后发现其依赖了B对象，因而会尝试递归的通过<code>pplicationContext.getBean()</code>法获取B对象的实例，但是Spring容器中此时也没有B对象的实例，因而其还是会先创建一个B对象的实例。读者需要注意这个时间点，此时A对象和B对象都已经创建了，并且保存在Spring容器中了，只不过A对象的属性b和B对象的属性a都还没有设置进去。在前面Spring创建B对象之后，Spring发现B对象依赖了属性A，因而此时还是会尝试递归的调用<code>pplicationContext.getBean()</code>法获取A对象的实例，因为Spring中已经有一个A对象的实例，虽然只是半成品（其属性b还未初始化），但其也还是目标bean，因而会将该A对象的实例返回。此时，B对象的属性a就设置进去了，然后还是<code>pplicationContext.getBean()</code>法递归的返回，也就是将B对象的实例返回，此时就会将该实例设置到A对象的属性b中。这个时候，注意A对象的属性b和B对象的属性a都已经设置了目标对象的实例了。<br>　　<br>　　读者朋友可能会比较疑惑的是，前面在为对象B设置属性a的时候，这个A类型属性还是个半成品。但是需要注意的是，这个A是一个引用，其本质上还是最开始就实例化的A对象。而在上面这个递归过程的最后，Spring将获取到的B对象实例设置到了A对象的属性b中了，这里的A对象其实和前面设置到实例B中的半成品A对象是同一个对象，其引用地址是同一个，这里为A对象的b属性设置了值，其实也就是为那个半成品的a属性设置了值。下面我们通过一个流程图来对这个过程进行讲解：<br>　　<img src="/blogImg/2019/9/22/1-2.jpg" alt></p><p>　　图中<code>getBean()</code>表示调用Spring的<code>ApplicationContext.getBean()</code>方法，而该方法中的参数，则表示我们要尝试获取的目标对象。图中的黑色箭头表示一开始的方法调用走向，走到最后，返回了Spring中缓存的A对象之后，表示递归调用返回了，此时使用绿色的箭头表示。从图中我们可以很清楚的看到，B对象的a属性是在第三步中注入的半成品A对象，而A对象的b属性是在第二步中注入的成品B对象，此时半成品的A对象也就变成了成品的A对象，因为其属性已经设置完成了。</p><p>　　</p><h3 id="2-源码讲解"><a href="#2-源码讲解" class="headerlink" title="2. 源码讲解"></a>2. 源码讲解</h3><p>　　对于Spring处理循环依赖问题的方式，我们这里通过上面的流程图其实很容易就可以理解，需要注意的一个点就是，Spring是如何标记开始生成的A对象是一个半成品，并且是如何保存A对象的。这里的标记工作Spring是使用ApplicationContext的属性<code>Set&lt;String&gt; singletonsCurrentlyInCreation</code>来保存的，而半成品的A对象则是通过<code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code>来保存的，这里的<code>ObjectFactory</code>是一个工厂对象，可通过调用其<code>getObject()</code>方法来获取目标对象。在<code>AbstractBeanFactory.doGetBean()</code>方法中获取对象的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试通过bean名称获取目标bean对象，比如这里的A对象</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 我们这里的目标对象都是单例的</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    <span class="comment">// 这里就尝试创建目标对象，第二个参数传的就是一个ObjectFactory类型的对象，这里是使用Java8的lamada</span></span><br><span class="line">    <span class="comment">// 表达式书写的，只要上面的getSingleton()方法返回值为空，则会调用这里的getSingleton()方法来创建</span></span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试创建目标对象</span></span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这里的<code>doGetBean()</code>方法是非常关键的一个方法（中间省略了其他代码），上面也主要有两个步骤，第一个步骤的<code>getSingleton()</code>方法的作用是尝试从缓存中获取目标对象，如果没有获取到，则尝试获取半成品的目标对象；如果第一个步骤没有获取到目标对象的实例，那么就进入第二个步骤，第二个步骤的<code>getSingleton()</code>方法的作用是尝试创建目标对象，并且为该对象注入其所依赖的属性。</p><p>　　<br>　　这里其实就是主干逻辑，我们前面图中已经标明，在整个过程中会调用三次<code>doGetBean()</code>方法，第一次调用的时候会尝试获取A对象实例，此时走的是第一个<code>getSingleton()</code>方法，由于没有已经创建的A对象的成品或半成品，因而这里得到的是null，然后就会调用第二个<code>getSingleton()</code>方法，创建A对象的实例，然后递归的调用<code>doGetBean()</code>方法，尝试获取B对象的实例以注入到A对象中，此时由于Spring容器中也没有B对象的成品或半成品，因而还是会走到第二个<code>getSingleton()</code>方法，在该方法中创建B对象的实例，创建完成之后，尝试获取其所依赖的A的实例作为其属性，因而还是会递归的调用<code>doGetBean()</code>方法，此时需要注意的是，在前面由于已经有了一个半成品的A对象的实例，因而这个时候，再尝试获取A对象的实例的时候，会走第一个<code>getSingleton()</code>方法，在该方法中会得到一个半成品的A对象的实例。然后将该实例返回，并且将其注入到B对象的属性a中，此时B对象实例化完成。然后将实例化完成的B对象递归的返回，此时就会将该实例注入到A对象中，这样就得到了一个成品的A对象。我们这里可以阅读上面的第一个<code>getSingleton()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试从缓存中获取成品的目标对象，如果存在，则直接返回</span></span><br><span class="line">  Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="comment">// 如果缓存中不存在目标对象，则判断当前对象是否已经处于创建过程中，在前面的讲解中，第一次尝试获取A对象</span></span><br><span class="line">  <span class="comment">// 的实例之后，就会将A对象标记为正在创建中，因而最后再尝试获取A对象的时候，这里的if判断就会为true</span></span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        <span class="comment">// 这里的singletonFactories是一个Map，其key是bean的名称，而值是一个ObjectFactory类型的</span></span><br><span class="line">        <span class="comment">// 对象，这里对于A和B而言，调用图其getObject()方法返回的就是A和B对象的实例，无论是否是半成品</span></span><br><span class="line">        ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取目标对象的实例</span></span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">          <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这里我们会存在一个问题就是A的半成品实例是如何实例化的，然后是如何将其封装为一个ObjectFactory类型的对象，并且将其放到上面的singletonFactories属性中的。这主要是在前面的第二个getSingleton()方法中，其最终会通过其传入的第二个参数，从而调用createBean()方法，该方法的最终调用是委托给了另一个doCreateBean()方法进行的，这里面有如下一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化当前尝试获取的bean对象，比如A对象和B对象都是在这里实例化的</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断Spring是否配置了支持提前暴露目标bean，也就是是否支持提前暴露半成品的bean</span></span><br><span class="line">  <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences </span><br><span class="line">    &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 如果支持，这里就会将当前生成的半成品的bean放到singletonFactories中，这个singletonFactories</span></span><br><span class="line">    <span class="comment">// 就是前面第一个getSingleton()方法中所使用到的singletonFactories属性，也就是说，这里就是</span></span><br><span class="line">    <span class="comment">// 封装半成品的bean的地方。而这里的getEarlyBeanReference()本质上是直接将放入的第三个参数，也就是</span></span><br><span class="line">    <span class="comment">// 目标bean直接返回</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在初始化实例之后，这里就是判断当前bean是否依赖了其他的bean，如果依赖了，</span></span><br><span class="line">    <span class="comment">// 就会递归的调用getBean()方法尝试获取目标bean</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　到这里，Spring整个解决循环依赖问题的实现思路已经比较清楚了。对于整体过程，读者朋友只要理解两点：</p><ul><li>Spring是通过递归的方式获取目标bean及其所依赖的bean的；</li><li>Spring实例化一个bean的时候，是分两步进行的，首先实例化目标bean，然后为其注入属性。</li></ul><p>　　结合这两点，也就是说，Spring在实例化一个bean的时候，是首先递归的实例化其所依赖的所有bean，直到某个bean没有依赖其他bean，此时就会将该实例返回，然后反递归的将获取到的bean设置为各个上层bean的属性的。</p><p>　　</p><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>　　本文首先通过图文的方式对Spring是如何解决循环依赖的问题进行了讲解，然后从源码的角度详细讲解了Spring是如何实现各个bean的装配工作的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://my.oschina.net/zhangxufeng/blog/3096394&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.oschina.net/zhangxufeng/blog/3096394&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
  </entry>
  
  <entry>
    <title>16个超级实用的java工具类</title>
    <link href="https://mlone.top/2019/09/22/16%E4%B8%AA%E8%B6%85%E7%BA%A7%E5%AE%9E%E7%94%A8%E7%9A%84java%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://mlone.top/2019/09/22/16个超级实用的java工具类/</id>
    <published>2019-09-22T06:11:48.000Z</published>
    <updated>2019-09-22T06:30:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://juejin.im/post/5d4a25b351882505c105cc6e" target="_blank" rel="noopener">排名前16的Java工具类</a><br><a id="more"></a></p><p>　　<br>　　在Java中，工具类定义了一组公共方法，这篇文章将介绍Java中使用最频繁及最通用的Java工具类。以下工具类、方法按使用流行度排名，参考数据来源于Github上随机选取的5万个开源项目源码。</p><p>　　</p><h3 id="一-org-apache-commons-io-IOUtils"><a href="#一-org-apache-commons-io-IOUtils" class="headerlink" title="一. org.apache.commons.io.IOUtils"></a>一. org.apache.commons.io.IOUtils</h3><ul><li>closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在finally块</li><li>toString：转换IO流、 Uri、 byte[]为String</li><li>copy：IO流数据复制，从输入流写到输出流中，最大支持2GB</li><li>toByteArray：从输入流、URI获取byte[]</li><li>write：把字节. 字符等写入输出流</li><li>toInputStream：把字符转换为输入流</li><li>readLines：从输入流中读取多行数据，返回List<string></string></li><li>copyLarge：同copy，支持2GB以上数据的复制</li><li>lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败</li></ul><p>　　</p><h3 id="二-org-apache-commons-io-FileUtils"><a href="#二-org-apache-commons-io-FileUtils" class="headerlink" title="二. org.apache.commons.io.FileUtils"></a>二. org.apache.commons.io.FileUtils</h3><ul><li>deleteDirectory：删除文件夹</li><li>readFileToString：以字符形式读取文件内容</li><li>deleteQueitly：删除文件或文件夹且不会抛出异常</li><li>copyFile：复制文件</li><li>writeStringToFile：把字符写到目标文件，如果文件不存在，则创建</li><li>forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级</li><li>write：把字符写到指定文件中</li><li>listFiles：列举某个目录下的文件(根据过滤器)</li><li>copyDirectory：复制文件夹</li><li>forceDelete：强制删除文件</li></ul><p>　　</p><h3 id="三-org-apache-commons-lang-StringUtils"><a href="#三-org-apache-commons-lang-StringUtils" class="headerlink" title="三. org.apache.commons.lang.StringUtils"></a>三. org.apache.commons.lang.StringUtils</h3><ul><li>isBlank：字符串是否为空 (trim后判断)</li><li>isEmpty：字符串是否为空 (不trim并判断)</li><li>equals：字符串是否相等</li><li>join：合并数组为单一字符串，可传分隔符</li><li>split：分割字符串</li><li>EMPTY：返回空字符串</li><li>trimToNull：trim后为空字符串则转换为null</li><li>replace：替换字符串</li></ul><p>　　</p><h3 id="四-org-apache-http-util-EntityUtils"><a href="#四-org-apache-http-util-EntityUtils" class="headerlink" title="四. org.apache.http.util.EntityUtils"></a>四. org.apache.http.util.EntityUtils</h3><ul><li>toString：把Entity转换为字符串</li><li>consume：确保Entity中的内容全部被消费。可以看到源码里又一次消费了Entity的内容，假如用户没有消费，那调用Entity时候将会把它消费掉</li><li>toByteArray：把Entity转换为字节流</li><li>consumeQuietly：和consume一样，但不抛异常</li><li>getContentCharset：获取内容的编码</li></ul><p>　　</p><h3 id="五-org-apache-commons-lang3-StringUtils"><a href="#五-org-apache-commons-lang3-StringUtils" class="headerlink" title="五. org.apache.commons.lang3.StringUtils"></a>五. org.apache.commons.lang3.StringUtils</h3><ul><li>isBlank：字符串是否为空 (trim后判断)</li><li>isEmpty：字符串是否为空 (不trim并判断)</li><li>equals：字符串是否相等</li><li>join：合并数组为单一字符串，可传分隔符</li><li>split：分割字符串</li><li>EMPTY：返回空字符串</li><li>replace：替换字符串</li><li>capitalize：首字符大写</li></ul><p>　　</p><h3 id="六-org-apache-commons-io-FilenameUtils"><a href="#六-org-apache-commons-io-FilenameUtils" class="headerlink" title="六. org.apache.commons.io.FilenameUtils"></a>六. org.apache.commons.io.FilenameUtils</h3><ul><li>getExtension：返回文件后缀名</li><li>getBaseName：返回文件名，不包含后缀名</li><li>getName：返回文件全名</li><li>concat：按命令行风格组合文件路径(详见方法注释)</li><li>removeExtension：删除后缀名</li><li>normalize：使路径正常化</li><li>wildcardMatch：匹配通配符</li><li>seperatorToUnix：路径分隔符改成unix系统格式的，即/</li><li>getFullPath：获取文件路径，不包括文件名</li><li>isExtension：检查文件后缀名是不是传入参数(List<string>)中的一个</string></li></ul><p>　　</p><h3 id="七-org-springframework-util-StringUtils"><a href="#七-org-springframework-util-StringUtils" class="headerlink" title="七. org.springframework.util.StringUtils"></a>七. org.springframework.util.StringUtils</h3><ul><li>hasText：检查字符串中是否包含文本</li><li>hasLength：检测字符串是否长度大于0</li><li>isEmpty：检测字符串是否为空（若传入为对象，则判断对象是否为null）</li><li>commaDelimitedStringToArray：逗号分隔的String转换为数组</li><li>collectionToDelimitedString：把集合转为CSV格式字符串</li><li>replace 替换字符串</li><li>delimitedListToStringArray：相当于split</li><li>uncapitalize：首字母小写</li><li>collectionToDelimitedCommaString：把集合转为CSV格式字符串</li><li>tokenizeToStringArray：和split基本一样，但能自动去掉空白的单词</li></ul><p>　　</p><h3 id="八-org-apache-commons-lang-ArrayUtils"><a href="#八-org-apache-commons-lang-ArrayUtils" class="headerlink" title="八. org.apache.commons.lang.ArrayUtils"></a>八. org.apache.commons.lang.ArrayUtils</h3><ul><li>contains：是否包含某字符串</li><li>addAll：添加整个数组</li><li>clone：克隆一个数组</li><li>isEmpty：是否空数组</li><li>add：向数组添加元素</li><li>subarray：截取数组</li><li>indexOf：查找某个元素的下标</li><li>isEquals：比较数组是否相等</li><li>toObject：基础类型数据数组转换为对应的Object数组</li></ul><p>　　</p><h3 id="九-org-apache-commons-lang-StringEscapeUtils"><a href="#九-org-apache-commons-lang-StringEscapeUtils" class="headerlink" title="九. org.apache.commons.lang.StringEscapeUtils"></a>九. org.apache.commons.lang.StringEscapeUtils</h3><ul><li><p>参考十五：</p><p>org.apache.commons.lang3.StringEscapeUtils</p></li></ul><p>　　</p><h3 id="十-org-apache-http-client-utils-URLEncodedUtils"><a href="#十-org-apache-http-client-utils-URLEncodedUtils" class="headerlink" title="十. org.apache.http.client.utils.URLEncodedUtils"></a>十. org.apache.http.client.utils.URLEncodedUtils</h3><ul><li>format：格式化参数，返回一个HTTP POST或者HTTP PUT可用application/x-www-form-urlencoded字符串</li><li>parse：把String或者URI等转换为List<namevaluepair><code></code></namevaluepair></li></ul><p>　　</p><h3 id="十一-org-apache-commons-codec-digest-DigestUtils"><a href="#十一-org-apache-commons-codec-digest-DigestUtils" class="headerlink" title="十一. org.apache.commons.codec.digest.DigestUtils"></a>十一. org.apache.commons.codec.digest.DigestUtils</h3><ul><li>md5Hex：MD5加密，返回32位字符串</li><li>sha1Hex：SHA-1加密</li><li>sha256Hex：SHA-256加密</li><li>sha512Hex：SHA-512加密</li><li>md5：MD5加密，返回16位字符串</li></ul><p>　　</p><h3 id="十二-org-apache-commons-collections-CollectionUtils"><a href="#十二-org-apache-commons-collections-CollectionUtils" class="headerlink" title="十二. org.apache.commons.collections.CollectionUtils"></a>十二. org.apache.commons.collections.CollectionUtils</h3><ul><li>isEmpty：是否为空</li><li>select：根据条件筛选集合元素</li><li>transform：根据指定方法处理集合元素，类似List的map()</li><li>filter：过滤元素，雷瑟List的filter()</li><li>find：基本和select一样</li><li>collect：和transform 差不多一样，但是返回新数组</li><li>forAllDo：调用每个元素的指定方法</li><li>isEqualCollection：判断两个集合是否一致</li></ul><p>　　</p><h3 id="十三-org-apache-commons-lang3-ArrayUtils"><a href="#十三-org-apache-commons-lang3-ArrayUtils" class="headerlink" title="十三. org.apache.commons.lang3.ArrayUtils"></a>十三. org.apache.commons.lang3.ArrayUtils</h3><ul><li>contains：是否包含某个字符串</li><li>addAll：添加整个数组</li><li>clone：克隆一个数组</li><li>isEmpty：是否空数组</li><li>add：向数组添加元素</li><li>subarray：截取数组</li><li>indexOf：查找某个元素的下标</li><li>isEquals：比较数组是否相等</li><li>toObject：基础类型数据数组转换为对应的Object数组</li></ul><p>　　</p><h3 id="十四-org-apache-commons-beanutils-PropertyUtils"><a href="#十四-org-apache-commons-beanutils-PropertyUtils" class="headerlink" title="十四. org.apache.commons.beanutils.PropertyUtils"></a>十四. org.apache.commons.beanutils.PropertyUtils</h3><ul><li>getProperty：获取对象属性值</li><li>setProperty：设置对象属性值</li><li>getPropertyDiscriptor：获取属性描述器</li><li>isReadable：检查属性是否可访问</li><li>copyProperties：复制属性值，从一个对象到另一个对象</li><li>getPropertyDiscriptors：获取所有属性描述器</li><li>isWriteable：检查属性是否可写</li><li>getPropertyType：获取对象属性类型</li></ul><p>　　</p><h3 id="十五-org-apache-commons-lang3-StringEscapeUtils"><a href="#十五-org-apache-commons-lang3-StringEscapeUtils" class="headerlink" title="十五. org.apache.commons.lang3.StringEscapeUtils"></a>十五. org.apache.commons.lang3.StringEscapeUtils</h3><ul><li>unescapeHtml4：转义html</li><li>escapeHtml4：反转义html</li><li>escapeXml：转义xml</li><li>unescapeXml：反转义xml</li><li>escapeJava：转义unicode编码</li><li>escapeEcmaScript：转义EcmaScript字符</li><li>unescapeJava：反转义unicode编码</li><li>escapeJson：转义json字符</li><li>escapeXml10：转义Xml10</li></ul><p>这个现在已经废弃了，建议使用commons-text包里面的方法。</p><p>　　</p><h3 id="十六-org-apache-commons-beanutils-BeanUtils"><a href="#十六-org-apache-commons-beanutils-BeanUtils" class="headerlink" title="十六. org.apache.commons.beanutils.BeanUtils"></a>十六. org.apache.commons.beanutils.BeanUtils</h3><ul><li>copyPeoperties：复制属性值，从一个对象到另一个对象</li><li>getProperty：获取对象属性值</li><li>setProperty：设置对象属性值</li><li>populate：根据Map给属性复制</li><li>copyPeoperty：复制单个值，从一个对象到另一个对象</li><li>cloneBean：克隆bean实例</li></ul><p>　　现在你只要了解了以上16种最流行的工具类方法，你就不必要再自己写工具类了，不必重复造轮子。大部分工具类方法通过其名字就能明白其用途，如果不清楚的，可以看下别人是怎么用的，或者去网上查询其用法。</p><p>　　另外，根据阿里开发手册，工具类所在的包名如果要使用”util”则不能带”s”，而且工具类要命名为 <code>XxxUtils</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://juejin.im/post/5d4a25b351882505c105cc6e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;排名前16的Java工具类&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Lambda表达式有何用处？如何使用？</title>
    <link href="https://mlone.top/2019/09/21/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9C%89%E4%BD%95%E7%94%A8%E5%A4%84%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F/"/>
    <id>https://mlone.top/2019/09/21/Lambda表达式有何用处？如何使用？/</id>
    <published>2019-09-21T12:38:40.000Z</published>
    <updated>2019-09-21T13:21:54.233Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://www.zhihu.com/question/20125256/answer/324121308" target="_blank" rel="noopener">https://www.zhihu.com/question/20125256/answer/324121308</a><br><a id="more"></a></p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt></p><h3 id="什么是Lambda"><a href="#什么是Lambda" class="headerlink" title="什么是Lambda?"></a>什么是Lambda?</h3><p>　　我们知道，对于一个Java变量，我们可以赋给其一个<strong>“值”</strong>。<br>　　<img src="/blogImg/2019/9/21/3-1.png" alt></p><p>　　如果你想把<strong>“一块代码”</strong>赋给一个Java变量，应该怎么做呢？</p><p>　　比如，我想把右边那块代码，赋给一个叫做aBlockOfCode的Java变量：<br>　　<img src="/blogImg/2019/9/21/3-2.png" alt></p><p>　　在Java 8之前，这个是做不到的。但是Java 8问世之后，利用Lambda特性，就可以做到了。<br>　　<img src="/blogImg/2019/9/21/3-3.png" alt></p><p>　　当然，这个并不是一个很简洁的写法。所以，为了使这个赋值操作更加elegant, 我们可以移除一些没用的声明。<br>　　<img src="/blogImg/2019/9/21/3-4.png" alt></p><p>　　这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。<strong>而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式</strong>。</p><blockquote><p>但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？</p></blockquote><p>　　在Java 8里面，<strong>所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。</strong>这是我认为理解Lambda的一个关键所在，简而言之就是，<strong>Lambda表达式本身就是一个接口的实现</strong>。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：<br>　　<img src="/blogImg/2019/9/21/3-5.png" alt></p><p>　　这种只有<strong>一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。</strong>为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：<br>　　<img src="/blogImg/2019/9/21/3-6.png" alt></p><p>　　这样，我们就得到了一个完整的Lambda表达式声明：<br>　　<img src="/blogImg/2019/9/21/3-7.png" alt></p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt></p><h3 id="Lambda表达式有什么作用"><a href="#Lambda表达式有什么作用" class="headerlink" title="Lambda表达式有什么作用?"></a>Lambda表达式有什么作用?</h3><p>　　<strong>最直观的作用就是使得代码变得异常简洁。</strong></p><p>　　我们可以对比一下Lambda表达式和传统的Java对同一个接口的实现：<br>　　<img src="/blogImg/2019/9/21/3-8.png" alt></p><p>　　这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，<strong>我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：</strong><br>　　<img src="/blogImg/2019/9/21/3-9.png" alt></p><p>　　有些情况下，这个接口实现只需要用到一次。传统的Java 7必须要求你定义一个“污染环境”的接口实现MyInterfaceImpl，而相较之下Java 8的Lambda, 就显得干净很多。</p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt></p><h3 id="Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！"><a href="#Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！" class="headerlink" title="Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！"></a>Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！</h3><p>直接上例子，假设Person的定义和List<person>的值都给定：</person></p><p>　　<img src="/blogImg/2019/9/21/3-10.png" alt></p><p>　　现在需要你打印出guiltyPersons List里面所有LastName以”Z”开头的人的FirstName。</p><p>　　<strong>原生态Lambda写法</strong>：定义两个函数式接口，定义一个静态函数，调用静态函数并给参数赋值Lambda表达式。<br>　　<img src="/blogImg/2019/9/21/3-11.png" alt></p><blockquote><p><strong>这个代码实际上已经比较简洁了，但是我们还可以更简洁么？</strong></p></blockquote><p>　　当然可以。在Java 8中有一个函数式接口的包，里面定义了大量可能用到的函数式接口（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">java.util.function (Java Platform SE 8 )</a>）。所以，我们在这里压根都不需要定义NameChecker和Executor这两个函数式接口，直接用Java 8函数式接口包里的Predicate<t>和Consumer<t>就可以了——因为他们这一对的接口定义和NameChecker/Executor其实是一样的。<br>　　<img src="/blogImg/2019/9/21/3-12.png" alt></t></t></p><p><strong>第一步简化 - 利用函数式接口包：</strong><br>　　<img src="/blogImg/2019/9/21/3-13.png" alt></p><p>　　静态函数里面的for each循环其实是非常碍眼的。这里可以利用Iterable自带的forEach()来替代。forEach()本身可以接受一个Consumer<t> 参数。</t></p><p><strong>第二步简化 - 用Iterable.forEach()取代foreach loop：</strong><br>　　<img src="/blogImg/2019/9/21/3-14.png" alt></p><p>　　**由于静态函数其实只是对List进行了一通操作，这里我们可以甩掉静态函数，直接使用stream()特性来完成。stream()的几个方法都是接受Predicate<t>，Consumer<t>等参数的（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">java.util.stream (Java Platform SE 8 )</a>）。你理解了上面的内容，stream()这里就非常好理解了，并不需要多做解释。</t></t></p><p><strong>第三步简化 - 利用stream()替代静态函数：</strong><br>　　<img src="/blogImg/2019/9/21/3-15.png" alt></p><p>　　对比最开始的Lambda写法，这里已经非常非常简洁了。但是如果，我们的要求变一下，变成print这个人的全部信息，及p -&gt; System.out.println(p); 那么还可以利用Method reference来继续简化。所谓Method reference, 就是用已经写好的别的Object/Class的method来代替Lambda expression。格式如下：<br>　　<img src="/blogImg/2019/9/21/3-16.png" alt></p><p><strong>第四步简化 - 如果是println(p)，则可以利用Method reference代替forEach中的Lambda表达式：</strong><br>　　<img src="/blogImg/2019/9/21/3-17.png" alt></p><p>　　这基本上就是能写的最简洁的版本了。</p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt></p><h3 id="Lambda配合Optional可以使Java对于null的处理变的异常优雅"><a href="#Lambda配合Optional可以使Java对于null的处理变的异常优雅" class="headerlink" title="Lambda配合Optional可以使Java对于null的处理变的异常优雅"></a>Lambda配合Optional<t>可以使Java对于null的处理变的异常优雅</t></h3><p>　　这里假设我们有一个person object，以及一个person object的Optional wrapper:<br>　　<img src="/blogImg/2019/9/21/3-18.png" alt></p><p>　　Optional<t>如果不结合Lambda使用的话，并不能使原来繁琐的null check变的简单。<br>　　<img src="/blogImg/2019/9/21/3-19.png" alt></t></p><p>　　<strong>只有当Optional<t>结合Lambda一起使用的时候，才能发挥出其真正的威力！</t></strong></p><p>　　我们现在就来对比一下下面四种常见的null处理中，Java 8的Lambda+Optional<t>和传统Java两者之间对于null的处理差异。</t></p><p><strong>情况一 - 存在则开干</strong><br>　　<img src="/blogImg/2019/9/21/3-20.png" alt></p><p><strong>情况二 - 存在则返回，无则返回屁</strong><br>　　<img src="/blogImg/2019/9/21/3-21.png" alt></p><p><strong>情况三 - 存在则返回，无则由函数产生</strong><br>　　<img src="/blogImg/2019/9/21/3-22.png" alt></p><p><strong>情况四 - 夺命连环null检查</strong><br>　　<img src="/blogImg/2019/9/21/3-23.png" alt></p><p>　　由上述四种情况可以清楚地看到，Optional<t>+Lambda可以让我们少写很多ifElse块。尤其是对于情况四那种夺命连环null检查，传统java的写法显得冗长难懂，而新的Optional<t>+Lambda则清新脱俗，清楚简洁。</t></t></p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt><br>　　关于Java的Lambda, 还有东西需要讨论和学习。比如如何handle lambda exception，如何利用Lambda的特性来进行parallel processing等。总之，我只是一如既往地介绍个大概，让你大概知道，哦！原来是这样子就OK了。网上关于Lambda有很多相关的教程，多看多练。假以时日，必定有所精益。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://www.zhihu.com/question/20125256/answer/324121308&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/20125256/answer/324121308&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题|多线程篇(一)</title>
    <link href="https://mlone.top/2019/09/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87-%E4%B8%80/"/>
    <id>https://mlone.top/2019/09/21/面试题-多线程篇-一/</id>
    <published>2019-09-21T09:28:47.000Z</published>
    <updated>2019-09-21T10:08:51.944Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;mid=2247483976&amp;idx=1&amp;sn=cc3fef354be2f4db951ab48eb30c9fd6&amp;chksm=ec294261db5ecb77f2b52a5c007cfc46878fdf161eeae7817259ee83d41c50a0567c988bf45e&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568038989685&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">每日3分钟技术干货 | 面试题+答案 |多线程篇(一)</a><br><a id="more"></a></p><p>　　</p><h4 id="1-为什么要使用线程池"><a href="#1-为什么要使用线程池" class="headerlink" title="1. 为什么要使用线程池"></a><strong>1. 为什么要使用线程池</strong></h4><p>　　避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><p>　　</p><h4 id="2-java中如何获取到线程dump文件"><a href="#2-java中如何获取到线程dump文件" class="headerlink" title="2. java中如何获取到线程dump文件"></a><strong>2. java中如何获取到线程dump文件</strong></h4><p>　　死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>　　另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。</p><p>　　</p><h4 id="3-怎么检测一个线程是否持有对象监视器"><a href="#3-怎么检测一个线程是否持有对象监视器" class="headerlink" title="3. 怎么检测一个线程是否持有对象监视器"></a><strong>3. 怎么检测一个线程是否持有对象监视器</strong></h4><p>　　我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p><p>　　</p><h4 id="4-synchronized和ReentrantLock的区别"><a href="#4-synchronized和ReentrantLock的区别" class="headerlink" title="4. synchronized和ReentrantLock的区别"></a><strong>4. synchronized和ReentrantLock的区别</strong></h4><p>　　synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>　　另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><p>　　</p><h4 id="5-ConcurrentHashMap的并发度是什么"><a href="#5-ConcurrentHashMap的并发度是什么" class="headerlink" title="5. ConcurrentHashMap的并发度是什么"></a><strong>5. ConcurrentHashMap的并发度是什么</strong></h4><p>　　ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p>　　</p><h4 id="6-ReentrantLock是什么"><a href="#6-ReentrantLock是什么" class="headerlink" title="6. ReentrantLock是什么"></a><strong>6. ReentrantLock是什么</strong></h4><p>　　首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>　　因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p>　　</p><h4 id="7-FutureTask是什么"><a href="#7-FutureTask是什么" class="headerlink" title="7. FutureTask是什么"></a><strong>7. FutureTask是什么</strong></h4><p>　　这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p>　　</p><h4 id="8-Linux环境下如何查找哪个线程使用CPU最长"><a href="#8-Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="8. Linux环境下如何查找哪个线程使用CPU最长"></a><strong>8. Linux环境下如何查找哪个线程使用CPU最长</strong></h4><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><ul><li><p>（1）获取项目的pid，<code>jps</code>或者<code>ps -ef | grep java</code>，这个前面有讲过</p></li><li><p>（2）<code>top -H -p pid</code>，顺序不能改变</p></li></ul><p>　　这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>　　使用<code>top -H -p pid</code>+<code>jps pid</code>可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>　　最后提一点，<code>top -H -p pid</code>打出来的LWP是十进制的，<code>jps pid</code>打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><p>　　</p><h4 id="9-一个线程如果出现了运行时异常会怎么样"><a href="#9-一个线程如果出现了运行时异常会怎么样" class="headerlink" title="9. 一个线程如果出现了运行时异常会怎么样"></a><strong>9. 一个线程如果出现了运行时异常会怎么样</strong></h4><p>　　如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><p>　　</p><h4 id="10-如何在两个线程之间共享数据"><a href="#10-如何在两个线程之间共享数据" class="headerlink" title="10. 如何在两个线程之间共享数据"></a><strong>10. 如何在两个线程之间共享数据</strong></h4><p>　　通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><p>　　</p><h4 id="11-线程和进程的区别？"><a href="#11-线程和进程的区别？" class="headerlink" title="11.  线程和进程的区别？"></a><strong>11.  线程和进程的区别？</strong></h4><p>　　一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><p>　　</p><h4 id="12-守护线程是什么？"><a href="#12-守护线程是什么？" class="headerlink" title="12. 守护线程是什么？"></a><strong>12. 守护线程是什么？</strong></h4><p>　　守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><p>　　</p><h4 id="13-创建线程有哪几种方式？"><a href="#13-创建线程有哪几种方式？" class="headerlink" title="13. 创建线程有哪几种方式？"></a><strong>13. 创建线程有哪几种方式？</strong></h4><p>创建线程有三种方式：</p><ul><li>继承 Thread 重新 run 方法；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口。</li></ul><p>　　</p><h4 id="14-说一下-runnable-和-callable-有什么区别？"><a href="#14-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="14. 说一下 runnable 和 callable 有什么区别？"></a><strong>14. 说一下 runnable 和 callable 有什么区别？</strong></h4><p>　　runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><p>　　</p><h4 id="15-线程有哪些状态？"><a href="#15-线程有哪些状态？" class="headerlink" title="15. 线程有哪些状态？"></a><strong>15. 线程有哪些状态？</strong></h4><blockquote><p>线程的状态：</p></blockquote><ul><li><code>NEW</code> 尚未启动</li><li><code>RUNNABLE</code> 正在执行中</li><li><code>BLOCKED</code> 阻塞的（被同步锁或者IO锁阻塞）</li><li><code>WAITING</code> 永久等待状态</li><li><code>TIMED_WAITING</code> 等待指定的时间重新被唤醒的状态</li><li><code>TERMINATED</code> 执行完成</li></ul><p>　　</p><h4 id="16-sleep-和-wait-有什么区别？"><a href="#16-sleep-和-wait-有什么区别？" class="headerlink" title="16. sleep() 和 wait() 有什么区别？"></a><strong>16. sleep() 和 wait() 有什么区别？</strong></h4><ul><li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li><li>释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</li></ul><p>　　</p><h4 id="17-notify-和-notifyAll-有什么区别？"><a href="#17-notify-和-notifyAll-有什么区别？" class="headerlink" title="17. notify()和 notifyAll()有什么区别？"></a><strong>17. notify()和 notifyAll()有什么区别？</strong></h4><ul><li>notifyAll()会唤醒所有的线程，而notify()只会唤醒一个线程。</li><li>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。<br>　　而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</li></ul><p>　　</p><h4 id="18-线程的-run-和-start-有什么区别？"><a href="#18-线程的-run-和-start-有什么区别？" class="headerlink" title="18. 线程的 run() 和 start() 有什么区别？"></a><strong>18. 线程的 run() 和 start() 有什么区别？</strong></h4><p>　　start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><p>　　</p><h4 id="19-创建线程池有哪几种方式？"><a href="#19-创建线程池有哪几种方式？" class="headerlink" title="19. 创建线程池有哪几种方式？"></a><strong>19. 创建线程池有哪几种方式？</strong></h4><p>线程池创建有七种方式，最核心的是最后一种：</p><ul><li><p><code>newSingleThreadExecutor()</code>：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</p></li><li><p><code>newCachedThreadPool()</code>：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</p></li><li><p><code>newFixedThreadPool(int nThreads)</code>：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</p></li><li><p><code>newSingleThreadScheduledExecutor()</code>：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</p></li><li><p><code>newScheduledThreadPool(int corePoolSize)</code>：和<code>newSingleThreadScheduledExecutor()</code>类似，创建的是个 <code>ScheduledExecutorService</code>，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</p></li><li><p><code>newWorkStealingPool(int parallelism)</code>：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</p></li><li><p><code>ThreadPoolExecutor()</code>：是最原始的线程池创建，上面1-3创建方式都是对<code>ThreadPoolExecutor</code>的封装。</p></li></ul><p>　　</p><h4 id="20-线程池都有哪些状态？"><a href="#20-线程池都有哪些状态？" class="headerlink" title="20. 线程池都有哪些状态？"></a><strong>20. 线程池都有哪些状态？</strong></h4><ul><li><code>RUNNING</code>：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li><code>SHUTDOWN</code>：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li><code>STOP</code>：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li><code>TIDYING</code>：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li><code>TERMINATED</code>：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><p>　　</p><h4 id="21-线程池中-submit-和-execute-方法有什么区别？"><a href="#21-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="21. 线程池中 submit() 和 execute() 方法有什么区别？"></a><strong>21. 线程池中 submit() 和 execute() 方法有什么区别？</strong></h4><ul><li><code>execute()</code>：只能执行 Runnable 类型的任务。</li><li><code>submit()</code>：可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</li></ul><p>　　</p><h4 id="22-在-Java-程序中怎么保证多线程的运行安全？"><a href="#22-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="22. 在 Java 程序中怎么保证多线程的运行安全？"></a><strong>22. 在 Java 程序中怎么保证多线程的运行安全？</strong></h4><ul><li>方法一：使用安全类，比如 Java. util. concurrent 下的类。</li><li>方法二：使用自动锁 synchronized。</li><li>方法三：使用手动锁 Lock。</li></ul><p>手动锁 Java 示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   System. out. println(<span class="string">"获得锁"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   System. out. println(<span class="string">"释放锁"</span>);</span><br><span class="line">   lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h4 id="23-多线程中-synchronized-锁升级的原理是什么？"><a href="#23-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="23. 多线程中 synchronized 锁升级的原理是什么？"></a><strong>23. 多线程中 synchronized 锁升级的原理是什么？</strong></h4><p>　　<strong>synchronized锁升级原理：</strong>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>　　<strong>锁的升级的目的：</strong>锁升级是为了减低了锁带来的性能消耗。在Java6之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><p>　　</p><h4 id="24-什么是死锁？"><a href="#24-什么是死锁？" class="headerlink" title="24. 什么是死锁？"></a><strong>24. 什么是死锁？</strong></h4><p>　　当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><p>　　</p><h4 id="25-怎么防止死锁？"><a href="#25-怎么防止死锁？" class="headerlink" title="25. 怎么防止死锁？"></a><strong>25. 怎么防止死锁？</strong></h4><ul><li>尽量使用 <code>tryLock(long timeout, TimeUnit unit)</code>的方法<code>(ReentrantLock、ReentrantReadWriteLock)</code>，设置超时时间，超时可以退出防止死锁。</li><li>尽量使用 <code>Java.util.concurrent</code> 并发类代替自己手写锁。</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>尽量减少同步的代码块。</li></ul><p>　　</p><h4 id="26-ThreadLocal是什么？有哪些使用场景？"><a href="#26-ThreadLocal是什么？有哪些使用场景？" class="headerlink" title="26. ThreadLocal是什么？有哪些使用场景？"></a><strong>26. ThreadLocal是什么？有哪些使用场景？</strong></h4><p>　　ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>　　ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><p>　　</p><h4 id="27-说一下-synchronized-底层实现原理？"><a href="#27-说一下-synchronized-底层实现原理？" class="headerlink" title="27. 说一下 synchronized 底层实现原理？"></a><strong>27. 说一下 synchronized 底层实现原理？</strong></h4><p>　　synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><p>　　</p><h4 id="28-synchronized-和-volatile-的区别是什么？"><a href="#28-synchronized-和-volatile-的区别是什么？" class="headerlink" title="28. synchronized 和 volatile 的区别是什么？"></a><strong>28. synchronized 和 volatile 的区别是什么？</strong></h4><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul><p>　　</p><h4 id="29-synchronized-和-Lock-有什么区别？"><a href="#29-synchronized-和-Lock-有什么区别？" class="headerlink" title="29. synchronized 和 Lock 有什么区别？"></a><strong>29. synchronized 和 Lock 有什么区别？</strong></h4><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><p>　　</p><h4 id="30-synchronized-和-ReentrantLock-区别是什么？"><a href="#30-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="30. synchronized 和 ReentrantLock 区别是什么？"></a><strong>30. synchronized 和 ReentrantLock 区别是什么？</strong></h4><p>　　synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul><p>　　</p><h4 id="31-说一下-atomic-的原理？"><a href="#31-说一下-atomic-的原理？" class="headerlink" title="31. 说一下 atomic 的原理？"></a><strong>31. 说一下 atomic 的原理？</strong></h4><p>　　atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>　　</p><h4 id="32-线程类的构造方法，静态块是哪个线程调用的"><a href="#32-线程类的构造方法，静态块是哪个线程调用的" class="headerlink" title="32.线程类的构造方法，静态块是哪个线程调用的"></a><strong>32.线程类的构造方法，静态块是哪个线程调用的</strong></h4><p>　　这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>　　如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><ul><li>1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</li><li>2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</li></ul><p>　　</p><h4 id="33-同步方法和同步块，哪个是更好的选择"><a href="#33-同步方法和同步块，哪个是更好的选择" class="headerlink" title="33. 同步方法和同步块，哪个是更好的选择"></a><strong>33. 同步方法和同步块，哪个是更好的选择</strong></h4><p>　　同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：<strong>同步的范围越小越好。</strong></p><p>　　借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p>　　</p><h4 id="34-高并发、任务执行时间短的业务怎样使用线程池？-并发不高、任务执行时间长的业务怎样使用线程池？-并发高、业务执行时间长的业务怎样使用线程池？"><a href="#34-高并发、任务执行时间短的业务怎样使用线程池？-并发不高、任务执行时间长的业务怎样使用线程池？-并发高、业务执行时间长的业务怎样使用线程池？" class="headerlink" title="34. 高并发、任务执行时间短的业务怎样使用线程池？**并发不高、任务执行时间长的业务怎样使用线程池？**并发高、业务执行时间长的业务怎样使用线程池？"></a><strong>34. 高并发、任务执行时间短的业务怎样使用线程池？**</strong>并发不高、任务执行时间长的业务怎样使用线程池？<strong>**并发高、业务执行时间长的业务怎样使用线程池？</strong></h4><p>　　这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><ul><li><p>1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p></li><li><p>2）并发不高、任务执行时间长的业务要区分开看：</p></li><li><ul><li>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</li></ul></li><li><ul><li>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li></ul></li><li><ul><li>c）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考其他有关线程池的文章。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;amp;mid=2247483976&amp;amp;idx=1&amp;amp;sn=cc3fef354be2f4db951ab48eb30c9fd6&amp;amp;chksm=ec294261db5ecb77f2b52a5c007cfc46878fdf161eeae7817259ee83d41c50a0567c988bf45e&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1568038989685&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每日3分钟技术干货 | 面试题+答案 |多线程篇(一)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题|MyBatis篇(一)</title>
    <link href="https://mlone.top/2019/09/21/%E9%9D%A2%E8%AF%95%E9%A2%98-MyBatis%E7%AF%87-%E4%B8%80/"/>
    <id>https://mlone.top/2019/09/21/面试题-MyBatis篇-一/</id>
    <published>2019-09-21T06:57:11.000Z</published>
    <updated>2019-09-21T07:13:34.348Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;mid=2247483985&amp;idx=2&amp;sn=f39c83232616fd3f1f41872cf5cd821b&amp;chksm=ec294278db5ecb6ea40b263c482699aa8fe8fd37e2bd052cc5b7833e718d2a6e1173110089fc&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568038876476&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">每日3分钟技术干货 | 面试题+答案 | MyBatis篇(一)</a><br><a id="more"></a></p><h4 id="1-MyBatis-中-和-的区别是什么？"><a href="#1-MyBatis-中-和-的区别是什么？" class="headerlink" title="1. MyBatis 中 #{}和 ${}的区别是什么？"></a><strong>1. MyBatis 中 #{}和 ${}的区别是什么？</strong></h4><p>　　#{}是预编译处理，${}是字符替换。在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p><p>　　</p><h4 id="2-MyBatis-有几种分页方式？"><a href="#2-MyBatis-有几种分页方式？" class="headerlink" title="2. MyBatis 有几种分页方式？"></a><strong>2. MyBatis 有几种分页方式？</strong></h4><ul><li><p><strong>分页方式：</strong>逻辑分页和物理分页。</p></li><li><p><strong>逻辑分页：</strong>使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p></li><li><p><strong>物理分页：</strong>自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p></li></ul><p>　　</p><h4 id="3-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#3-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="3. RowBounds 是一次性查询全部结果吗？为什么？"></a><strong>3. RowBounds 是一次性查询全部结果吗？为什么？</strong></h4><p>　　RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p><p>　　</p><h4 id="4-MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#4-MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="4. MyBatis 逻辑分页和物理分页的区别是什么？"></a><strong>4. MyBatis 逻辑分页和物理分页的区别是什么？</strong></h4><p>　　逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</p><p>　　物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p><p>　　</p><h4 id="5-MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#5-MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="5. MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a><strong>5. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</strong></h4><p>　　MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p><p>　　延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p><p>　　</p><h4 id="6-说一下-MyBatis-的一级缓存和二级缓存？"><a href="#6-说一下-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="6. 说一下 MyBatis 的一级缓存和二级缓存？"></a><strong>6. 说一下 MyBatis 的一级缓存和二级缓存？</strong></h4><p><strong>一级缓存：</strong>基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 　　SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</p><p><strong>二级缓存：</strong>也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</p><blockquote><p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p></blockquote><p><strong>缓存更新机制：</strong>当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><p>　　</p><h4 id="7-MyBatis-和-hibernate-的区别有哪些？"><a href="#7-MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="7. MyBatis 和 hibernate 的区别有哪些？"></a><strong>7. MyBatis 和 hibernate 的区别有哪些？</strong></h4><ul><li><p><strong>灵活性：</strong>MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</p></li><li><p><strong>可移植性：</strong>MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</p></li><li><p><strong>学习和使用门槛：</strong>MyBatis 入门比较简单，使用门槛也更低。</p></li><li><p><strong>二级缓存：</strong>hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p></li></ul><p>　　</p><h4 id="8-MyBatis-有哪些执行器（Executor）？"><a href="#8-MyBatis-有哪些执行器（Executor）？" class="headerlink" title="8. MyBatis 有哪些执行器（Executor）？"></a><strong>8. MyBatis 有哪些执行器（Executor）？</strong></h4><p>MyBatis 有三种基本的Executor执行器：</p><ul><li><p><strong>SimpleExecutor：</strong>每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</p></li><li><p><strong>ReuseExecutor：</strong>执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</p></li><li><p><strong>BatchExecutor：</strong>执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</p></li></ul><p>　　</p><h4 id="9-MyBatis-分页插件的实现原理是什么？"><a href="#9-MyBatis-分页插件的实现原理是什么？" class="headerlink" title="9. MyBatis 分页插件的实现原理是什么？"></a><strong>9. MyBatis 分页插件的实现原理是什么？</strong></h4><p>　　分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><p>　　</p><h4 id="10-MyBatis-如何编写一个自定义插件？"><a href="#10-MyBatis-如何编写一个自定义插件？" class="headerlink" title="10. MyBatis 如何编写一个自定义插件？"></a><strong>10. MyBatis 如何编写一个自定义插件？</strong></h4><p><strong>自定义插件实现原理</strong></p><p>　　MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p><ul><li>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</li><li>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；</li><li>ParameterHandler：拦截参数的处理；</li><li>ResultSetHandler：拦截结果集的处理。</li></ul><p>　　<br><strong>自定义插件实现关键</strong><br>　　MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</li><li>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；</li><li>intercept 方法就是要进行拦截的时候要执行的方法。</li></ul><p>　　<br><strong>自定义插件实现示例</strong><br>　　官方插件实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor. <span class="class"><span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>,</span><br><span class="line">args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">      Object target = invocation. getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line"></span><br><span class="line">      Method method = invocation. getMethod(); <span class="comment">//代理方法</span></span><br><span class="line"></span><br><span class="line">      Object[] args = invocation. getArgs(); <span class="comment">//方法参数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// do something . . . . . .  方法拦截前执行代码块</span></span><br><span class="line"></span><br><span class="line">      Object result = invocation. proceed();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// do something . . . . . . . 方法拦截后执行代码块</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Plugin. wrap(target, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;amp;mid=2247483985&amp;amp;idx=2&amp;amp;sn=f39c83232616fd3f1f41872cf5cd821b&amp;amp;chksm=ec294278db5ecb6ea40b263c482699aa8fe8fd37e2bd052cc5b7833e718d2a6e1173110089fc&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1568038876476&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每日3分钟技术干货 | 面试题+答案 | MyBatis篇(一)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
      <category term="mybatis" scheme="https://mlone.top/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>synchronized与volatile</title>
    <link href="https://mlone.top/2019/09/21/synchronized%E4%B8%8Evolatile/"/>
    <id>https://mlone.top/2019/09/21/synchronized与volatile/</id>
    <published>2019-09-21T06:35:43.000Z</published>
    <updated>2019-09-21T06:54:45.479Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650124577&amp;idx=1&amp;sn=4f471855e58d2ded0c9044a3a7e9c698&amp;chksm=f36bac00c41c25166ec3ca43e5811984e4977e8cbbd5f14947fb4d0bc9c67b4a80c726699ff2&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1566351934675&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">既生synchronized，何生volatile</a><br><a id="more"></a></p><blockquote><p>之前的文章中我们介绍过了两个在Java并发编程中比较重要的两个关键字：synchronized和volatile</p></blockquote><p>简单回顾一下相关内容：</p><p>1、Java语言为了解决并发编程中存在的原子性、可见性和有序性问题，提供了一系列和并发处理相关的关键字，比如synchronized、volatile、final、concurren包等。(<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121599&amp;idx=1&amp;sn=42b2cfabfb3057ac6c09026a8b9656cd&amp;chksm=f36bb85ec41c31489e461a53e78f2959f0224c87c312724f420265b70e67e4efdae2331155aa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">再有人问你Java内存模型是什么，就把这篇文章发给他</a>)</p><p>2、synchronized通过加锁的方式，使得其在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121805&amp;idx=1&amp;sn=8aea8c329a018c82a7ebfe80ec604226&amp;chksm=f36bbb6cc41c327acc23d3d7cdf0b785e318d8e970d564ba9ce8b28a1ae6b41499d351497af3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">再有人问你synchronized是什么，就把这篇文章发给他</a>）</p><p>3、volatile通过在volatile变量的操作前后插入内存屏障的方式，保证了变量在并发场景下的可见性和有序性。（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121952&amp;idx=1&amp;sn=5fd25ca48e2005379bffae1608027b59&amp;chksm=f36bbbc1c41c32d781ca24cfa3373660516a50f8b89772260ea247bfb89a0e9a215317e509a4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">再有人问你volatile是什么，把这篇文章也发给他</a>）</p><p>4、volatile关键字是无法保证原子性的，而synchronized通过monitorenter和monitorexit两个指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，即可保证不会出现CPU时间片在多个线程间切换，即可保证原子性。（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121739&amp;idx=1&amp;sn=7b60f56d408457f34d5fc0b200ed32bb&amp;chksm=f36bbb2ac41c323c000e2a51e76c627d17f4759d3a54c520a073506ef3de0c46e196f11cd287&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Java的并发编程中的多线程问题到底是怎么回事儿</a>）<br>　　<br>　　那么，我们知道，synchronized和volatile两个关键字是Java并发编程中经常用到的两个关键字，而且，通过前面的回顾，我们知道synchronized可以保证并发编程中不会出现原子性、可见性和有序性问题，而volatile只能保证可见性和有序性，那么，<strong>既生synchronized、何生volatile？</strong></p><p>　　接下来，本文就来论述一下，为什么Java中已经有了synchronized关键字，还要提供volatile关键字。</p><h2 id="1-synchronized的问题"><a href="#1-synchronized的问题" class="headerlink" title="1. synchronized的问题"></a>1. synchronized的问题</h2><p>我们都知道synchronized其实是一种加锁机制，那么既然是锁，天然就具备以下几个缺点：</p><h3 id="1、有性能损耗"><a href="#1、有性能损耗" class="headerlink" title="1、有性能损耗"></a><strong>1、有性能损耗</strong></h3><p>　　虽然在JDK 1.6中对synchronized做了很多优化，如如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121186&amp;idx=1&amp;sn=248d37be27d3bbeb103464b2a96a0ae4&amp;chksm=f36bbec3c41c37d59277ac8539a616b65ec44637f341325056e98323e8780e09c6e4f7cc7a85&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解多线程（五）—— Java虚拟机的锁优化技术</a>），但是他毕竟还是一种锁。</p><p>　　以上这几种优化，都是尽量想办法避免对Monitor（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120784&amp;idx=1&amp;sn=3436c978f0d7ab3bb672d03689518902&amp;chksm=f36bbf71c41c36672a3a6a7edebe0b913f2f5cf33d75d594d228f086ec7bdb9e253ab0beeae4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解多线程（四）—— Moniter的实现原理</a>）进行加锁，但是，并不是所有情况都可以优化的，况且就算是经过优化，优化的过程也是有一定的耗时的。</p><p>　　所以，无论是使用同步方法还是同步代码块，在同步操作之前还是要进行加锁，同步操作之后需要进行解锁，这个加锁、解锁的过程是要有性能损耗的。</p><p>　　关于二者的性能对比，由于虚拟机对锁实行的许多消除和优化，使得我们很难量化这两者之间的性能差距，但是我们可以确定的一个基本原则是：volatile变量的读操作的性能小号普通变量几乎无差别，但是写操作由于需要插入内存屏障所以会慢一些，即便如此，volatile在大多数场景下也比锁的开销要低。</p><h3 id="2、产生阻塞"><a href="#2、产生阻塞" class="headerlink" title="2、产生阻塞"></a><strong>2、产生阻塞</strong></h3><p>　　我们在<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120537&amp;idx=1&amp;sn=f56201217c0ca6fde45ee12965b56296&amp;chksm=f36bbc78c41c356ee363367addcdc0b311afb2f9df86a7ee20d21348b3332fd64f273d6028ca&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>中介绍过关于synchronize的实现原理，无论是同步方法还是同步代码块，无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的。</p><p>　　基于Monitor对象，当多个线程同时访问一段同步代码时，首先会进入Entry Set，当有一个线程获取到对象的锁之后，才能进行The Owner区域，其他线程还会继续在Entry Set等待。并且当某个线程调用了wait方法后，会释放锁并进入Wait Set等待。<br>　　<img src="/blogImg/2019/9/21/2-1.png" alt></p><p>　　<span style="color: orange;">所以，synchronize实现的锁本质上是一种阻塞锁，也就是说多个线程要排队访问同一个共享对象。</span></p><p>　　而volatile是Java虚拟机提供的一种轻量级同步机制，他是基于内存屏障实现的。说到底，他并不是锁，所以他不会有synchronized带来的阻塞和性能损耗的问题。</p><h2 id="2-volatile的附加功能"><a href="#2-volatile的附加功能" class="headerlink" title="2. volatile的附加功能"></a>2. volatile的附加功能</h2><p>　　除了前面我们提到的volatile比synchronized性能好以外，<span style="color: orange;">volatile其实还有一个很好的附加功能，那就是禁止指令重排</span>。</p><p>　　我们先来举一个例子，看一下如果只使用synchronized而不使用volatile会发生什么问题，就拿我们比较熟悉的单例模式来看。</p><p>　　我们通过双重校验锁的方式实现一个单例，这里不使用volatile关键字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　以上代码，我们通过使用synchronized对Singleton.class进行加锁，可以保证同一时间只有一个线程可以执行到同步代码块中的内容，也就是说singleton = new Singleton()这个操作只会执行一次，这就是实现了一个单例。</p><p>　　<strong>但是，当我们在代码中使用上述单例对象的时候有可能发生空指针异常。这是一个比较诡异的情况。</strong></p><p>我们假设Thread1 和 Thread2两个线程同时请求Singleton.getSingleton方法的时候：<br>　　<img src="/blogImg/2019/9/21/2-2.png" alt></p><ul><li>Step1 ,Thread1执行到第8行，开始进行对象的初始化。</li><li>Step2 ,Thread2执行到第5行，判断singleton == null。 </li><li>Step3 ,Thread2经过判断发现singleton ！= null，所以执行第12行，返回singleton。 </li><li>Step4 ,Thread2拿到singleton对象之后，开始执行后续的操作，比如调用singleton.call()。</li></ul><p>　　以上过程，看上去并没有什么问题，但是，其实，在Step4，Thread2在调用singleton.call()的时候，是有可能抛出空指针异常的。</p><p>　　之所有会有NPE抛出，是因为在Step3，Thread2拿到的singleton对象并不是一个完整的对象。<br>　　<br><strong>什么叫做不完整对象，这个怎么理解呢？</strong></p><p>我们这里来先来看一下，<code>singleton = new Singleton();</code>这行代码到底做了什么事情，大致过程如下：</p><ul><li>1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。 </li><li>2、检查符号引用代表的类是否被加载、解析、初始化过。 </li><li>3、虚拟机为对象分配内存。 </li><li>4、虚拟机将分配到的内存空间都初始化为零值。 </li><li>5、虚拟机对对象进行必要的设置。 </li><li>6、执行方法，成员变量进行初始化。</li><li>7、将对象的引用指向这个内存区域。</li></ul><p>　　<br>我们把这个过程简化一下，简化成3个步骤：</p><ul><li>a、JVM为对象分配一块内存M </li><li>b、在内存M上为对象进行初始化 </li><li>c、将内存M的地址复制给singleton变量</li></ul><p>如下图：<br>　　<img src="/blogImg/2019/9/21/2-3.png" alt></p><p>　　因为将内存的地址赋值给singleton变量是最后一步，所以Thread1在这一步骤执行之前，Thread2在对singleton==null进行判断一直都是true的，那么他会一直阻塞，直到Thread1将这一步骤执行完。<br>　　<br>　　但是，问题就出在以上过程并不是一个原子操作，并且编译器可能会进行重排序，如果以上步骤被重排成：</p><ul><li>a、JVM为对象分配一块内存M </li><li>c、将内存的地址复制给singleton变量 </li><li>b、在内存M上为对象进行初始化</li></ul><p>如下图：<br>　　<img src="/blogImg/2019/9/21/2-4.png" alt></p><p>　　这样的话，Thread1会先执行内存分配，在执行变量赋值，最后执行对象的初始化，那么，也就是说，在Thread1还没有为对象进行初始化的时候，Thread2进来判断singleton==null就可能提前得到一个false，则会返回一个不完整的sigleton对象，因为他还未完成初始化操作。</p><p>　　这种情况一旦发生，我们拿到了一个不完整的singleton对象，当尝试使用这个对象的时候就极有可能发生NPE异常。<br>　　<br>　　那么，怎么解决这个问题呢？因为指令重排导致了这个问题，那就避免指令重排就行了。</p><p>　　所以，volatile就派上用场了，因为<span style="color: orange;">volatile可以避免指令重排</span>。只要将代码改成以下代码，就可以解决这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　对singleton使用volatile约束，保证他的初始化过程不会被指令重排。这样就可以保Thread2 要不然就是拿不到对象，要不然就是拿到一个完整的对象。</p><h2 id="3-synchronized的有序性保证呢？"><a href="#3-synchronized的有序性保证呢？" class="headerlink" title="3. synchronized的有序性保证呢？"></a>3. synchronized的有序性保证呢？</h2><p>　　看到这里可能有朋友会问了，说到底上面问题是发生了指令重排，其实还是个有序性的问题，<strong>不是说synchronized是可以保证有序性的么，这里为什么就不行了呢？</strong></p><p>　　首先，可以明确的一点是：<span style="color: orange;">synchronized是无法禁止指令重排和处理器优化的。</span>那么他是如何保证的有序性呢？</p><p>　　这就要再把有序性的概念扩展一下了。Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。</p><p>　　以上这句话也是《深入理解Java虚拟机》中的原句，但是怎么理解呢？周志明并没有详细的解释。这里我简单扩展一下，这其实和as-if-serial语义有关。</p><p>　　as-if-serial语义的意思指：不管怎么重排序，单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。</p><p>　　这里不对as-if-serial语义详细展开了，<span style="color: orange;">简单说就是，as-if-serial语义保证了单线程中，不管指令怎么重排，最终的执行结果是不能被改变的。</span></p><p>　　那么，我们回到刚刚那个双重校验锁的例子，站在单线程的角度，也就是只看Thread1的话，因为编译器会遵守as-if-serial语义，所以这种优化不会有任何问题，对于这个线程的执行结果也不会有任何影响。</p><p>　　但是，Thread1内部的指令重排却对Thread2产生了影响。</p><p>　　那么，我们可以说，<span style="color: orange;">synchronized保证的有序性是多个线程之间的有序性，即被加锁的内容要按照顺序被多个线程执行。但是其内部的同步代码还是会发生重排序，只不过由于编译器和处理器都遵循as-if-serial语义，所以我们可以认为这些重排序在单线程内部可忽略。</span></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文从两方面论述了volatile的重要性以及不可替代性：</p><p>　　<strong>一方面是因为synchronized是一种锁机制，存在阻塞问题和性能问题，而volatile并不是锁，所以不存在阻塞和性能问题。</strong></p><p>　　另外一方面，因为<strong>volatile借助了内存屏障来帮助其解决可见性和有序性问题，而内存屏障的使用还为其带来了一个禁止指令重排的附件功能，所以在有些场景中是可以避免发生指令重排的问题的。</strong></p><p>　　所以，在日后需要做并发控制的时候，如果不涉及到原子性的问题，可以优先考虑使用volatile关键字。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650124577&amp;amp;idx=1&amp;amp;sn=4f471855e58d2ded0c9044a3a7e9c698&amp;amp;chksm=f36bac00c41c25166ec3ca43e5811984e4977e8cbbd5f14947fb4d0bc9c67b4a80c726699ff2&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1566351934675&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;既生synchronized，何生volatile&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个TCP连接上面能发多少个HTTP请求</title>
    <link href="https://mlone.top/2019/09/21/%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E4%B8%8A%E9%9D%A2%E8%83%BD%E5%8F%91%E5%A4%9A%E5%B0%91%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82/"/>
    <id>https://mlone.top/2019/09/21/一个TCP连接上面能发多少个HTTP请求/</id>
    <published>2019-09-21T06:09:28.000Z</published>
    <updated>2019-09-21T06:31:03.589Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://zhuanlan.zhihu.com/p/61423830" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61423830</a><br><a id="more"></a></p><p>　　一道经典的面试题是从 URL 在浏览器被被输入到页面展现的过程中发生了什么，大多数回答都是说请求响应之后 DOM 怎么被构建，被绘制出来。但是你有没有想过，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</p><p>要搞懂这个问题，我们需要先解决下面五个问题：</p><ol><li>现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</li><li>一个 TCP 连接可以对应几个 HTTP 请求？</li><li>一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</li><li>为什么有的时候刷新页面不需要重新建立 SSL 连接？</li><li>浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</li></ol><p>　　<strong>先来谈谈第一个问题：现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</strong></p><p>　　在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 <code>Connection: keep-alive</code> 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是我短时间内两次访问 <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a> 的时间统计：<br>　　<img src="/blogImg/2019/9/21/1-1.png" alt><br>　　头一次访问，有初始化连接和 SSL 开销<br>　　<img src="/blogImg/2019/9/21/1-2.png" alt><br>　　初始化连接和 SSL 开销消失了，说明使用的是同一个 TCP 连接<br>　　<br>　　持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。</p><p>　　所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。（详细文档见下面的链接）</p><p>　　<a href="https://tools.ietf.org/html/rfc2616#section-8.1" target="_blank" rel="noopener">Hypertext Transfer Protocol – HTTP/1.1</a><br>　　<br><strong>第二个问题：一个 TCP 连接可以对应几个 HTTP 请求？</strong></p><p>　　了解了第一个问题之后，其实这个问题已经有了答案，如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。<br>　　<br><strong>第三个问题：一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</strong></p><p>　　HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。</p><p>　　虽然 HTTP/1.1 规范中规定了 <a href="https://tools.ietf.org/html/rfc2616#section-8.1.2.2" target="_blank" rel="noopener">Pipelining</a> 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。</p><p>先来看一下 Pipelining 是什么，RFC 2616 中规定了：</p><blockquote><p>A client that supports persistent connections MAY “pipeline” its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received.<br>一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。</p></blockquote><p>　　至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 <code>GET /query?q=A</code> 和 <code>GET /query?q=B</code>，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。<br>　　<br>Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：</p><ul><li>一些代理服务器不能正确的处理 HTTP Pipelining。</li><li>正确的流水线实现是复杂的。详见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x#HTTP_%E6%B5%81%E6%B0%B4%E7%BA%BF" target="_blank" rel="noopener">HTTP/1.x的连接管理</a></li><li>Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。</li></ul><p>　　所以现代浏览器默认是不开启 HTTP Pipelining 的。<br>　　<br>　　但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果：<br>　　<img src="/blogImg/2019/9/21/1-3.png" alt><br>　　绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个 Connection，并行完成的<br>　　<br>　　所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。</p><p>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：</p><ol><li>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。</li><li>和服务器建立多个 TCP 连接。</li></ol><p>　　<br><strong>第四个问题：为什么有的时候刷新页面不需要重新建立 SSL 连接？</strong></p><p>　　在第一个问题的讨论中已经有答案了，TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。</p><p>　　<br><strong>第五个问题：浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</strong></p><p>　　假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。</p><p>　　所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。<a href="https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requests" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome…</a><br>　　<br>　　<strong>那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</strong></p><p>　　如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。</p><p>　　如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/61423830&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/61423830&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://mlone.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="https://mlone.top/tags/http/"/>
    
  </entry>
  
</feed>
