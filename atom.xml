<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Easygo_Space</title>
  
  <subtitle>The quick brown fox jumps over the lazy dog.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mlone.top/"/>
  <updated>2019-09-22T17:04:41.621Z</updated>
  <id>https://mlone.top/</id>
  
  <author>
    <name>easy go</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何保证缓存与数据库的双写一致性？</title>
    <link href="https://mlone.top/2019/09/23/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F/"/>
    <id>https://mlone.top/2019/09/23/如何保证缓存与数据库的双写一致性？/</id>
    <published>2019-09-22T16:40:45.000Z</published>
    <updated>2019-09-22T17:04:41.621Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/chang384915878/article/details/86756463" target="_blank" rel="noopener">https://blog.csdn.net/chang384915878/article/details/86756463</a><br><a id="more"></a></p><p>　　</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><blockquote><p>如何保证缓存与数据库的双写一致性？</p></blockquote><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>　　你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>　　一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p><p>　　串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern：</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><blockquote><p><strong>为什么是删除缓存，而不是更新缓存？</strong></p></blockquote><p>　　原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。</p><p>　　比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。</p><p>　　<br>　　另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于<strong>比较复杂的缓存数据计算的场景</strong>，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，<strong>这个缓存到底会不会被频繁访问到？</strong></p><p>　　举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有<strong>大量的冷数据</strong>。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用<strong>到缓存才去算缓存</strong>。</p><p>　　其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。</p><h3 id="最初级的缓存不一致问题及解决方案"><a href="#最初级的缓存不一致问题及解决方案" class="headerlink" title="最初级的缓存不一致问题及解决方案"></a>最初级的缓存不一致问题及解决方案</h3><p><strong>问题：</strong>先修改数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。<br><img src="/blogImg/2019/9/23/1-1.png" alt></p><p><strong>解决思路：</strong>先删除缓存，再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。</p><h3 id="比较复杂的数据不一致问题分析"><a href="#比较复杂的数据不一致问题分析" class="headerlink" title="比较复杂的数据不一致问题分析"></a>比较复杂的数据不一致问题分析</h3><p>　　数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了…</p><blockquote><p> <strong>为什么上亿流量高并发场景下，缓存会出现这个问题？</strong></p></blockquote><p>　　只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就<strong>可能会出现上述的数据库+缓存不一致的情况</strong>。</p><p>　　<br><strong>解决方案如下：</strong></p><p>　　更新数据的时候，根据<strong>数据的唯一标识</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个 jvm 内部队列中。</p><p>　　一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p>　　这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><p>　　待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p><p>　　如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p><p>　　<br><strong>高并发的场景下，该解决方案要注意的问题：</strong></p><blockquote><ol><li>读请求长时阻塞</li></ol></blockquote><p>　　由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。</p><p>　　该解决方案，最大的风险点在于说，<strong>可能数据更新很频繁</strong>，导致队列中积压了大量更新操作在里面，然后<strong>读请求会发生大量的超时</strong>，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。</p><p>　　另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要<strong>部署多个服务</strong>，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每隔库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致<strong>读请求的长时阻塞</strong>。</p><p>　　一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。</p><p>　　<strong>如果一个内存队列中可能积压的更新操作特别多</strong>，那么你就要<strong>加机器</strong>，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。<br>　　<br>　　其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。</p><p>我们来<strong>实际粗略测算一下</strong>：</p><p>　　如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了。</p><p>　　经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。</p><p>　　</p><blockquote><ol start="2"><li>读请求并发量过高</li></ol></blockquote><p>　　这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。</p><p>　　但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。</p><p>　　</p><blockquote><ol start="3"><li>多服务实例部署的请求路由</li></ol></blockquote><p>　　可能这个服务部署了多个实例，那么必须<strong>保证</strong>说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器<strong>路由到相同的服务实例上</strong>。</p><p>　　比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。</p><p>　　</p><blockquote><ol start="4"><li>热点商品的路由问题，导致请求的倾斜</li></ol></blockquote><p>　　万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/chang384915878/article/details/86756463&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/chang384915878/article/details/86756463&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap与HashMap、Hashtable的区别</title>
    <link href="https://mlone.top/2019/09/22/ConcurrentHashMap%E4%B8%8EHashMap%E3%80%81Hashtable%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://mlone.top/2019/09/22/ConcurrentHashMap与HashMap、Hashtable的区别/</id>
    <published>2019-09-22T09:12:29.000Z</published>
    <updated>2019-09-22T09:53:39.788Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/" target="_blank" rel="noopener">https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/</a><br><a id="more"></a></p><p>　　</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　<code>ConcurrentHashMap</code>顾名思义就是同步的HashMap，也就是线程安全的HashMap，所以本篇介绍的ConcurrentHashMap和HashMap有着很重要的关系，所以建议之前没有了解过HashMap的可以先看看这篇关于HashMap的原理分析<a href="https://ddnd.cn/2019/03/07/jdk1.8-hashmap/" target="_blank" rel="noopener">《HashMap从认识到源码分析》</a>，本篇继续以<code>JDK1.8</code>版本的源码进行分析，最后在介绍完ConcurrentHashMap之后会对ConcurrentHashMap、Hashtable和HashMap做一个比较和总结。</p><p>　　</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>　　我们先看一下<code>ConcurrentHashMap</code>实现了哪些接口、继承了哪些类，对<code>ConcurrentHashMap</code>有一个整体认知。<br>　　<img src="/blogImg/2019/9/22/4-1.jpg" alt></p><p>　　ConcurrentHashMap<code>继承</code>AbstractMap<code>接口，这个和</code>HashMap<code>一样，然后实现了</code>ConcurrentMap<code>接口，这个和</code>HashMap<code>不一样，</code>HashMap<code>是直接实现的</code>Map`接口。</p><p>　　再细看<code>ConcurrentHashMap</code>的结构，这里列举几个重要的成员变量<code>table</code>、<code>nextTable</code>、<code>baseCount</code>、<code>sizeCtl</code>、<code>transferIndex</code>、<code>cellsBusy</code></p><ul><li><p><strong>table</strong>：数据类型是Node数组，这里的Node和HashMap的Node一样都是内部类且实现了<code>Map.Entry</code>接口</p></li><li><p><strong>nextTable</strong>：哈希表扩容时生成的数据，数组为扩容前的2倍</p></li><li><p><strong>sizeCtl</strong> ：多个线程的<strong>共享变量</strong>，是操作的控制标识符，它的作用不仅包括<code>threshold</code>的作用，在不同的地方有不同的值也有不同的用途：</p><ul><li><code>-1</code>代表正在<strong>初始化</strong></li><li><code>-N</code>代表有<code>N-1</code>个线程正在进行<strong>扩容</strong>操作</li><li><code>0</code>代表hash表还没有被初始化</li><li>正数表示下一次进行扩容的容量大小</li></ul></li><li><p><strong>ForwardingNode</strong>：一个特殊的Node节点，Hash地址为-1，存储着nextTable的引用，只有table发生扩用的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或者已被移动<br>　　<img src="/blogImg/2019/9/22/4-2.jpg" alt></p></li></ul><p>　　<code>ConcurrentHashMap</code>和<code>HashMap</code>一样都是采用<strong>拉链法</strong>处理哈希冲突，且都为了防止单链表过长影响查询效率，所以当链表长度超过某一个值时候将用红黑树代替链表进行存储，采用了<strong>数组+链表+红黑树</strong>的结构<br>　　<img src="/blogImg/2019/9/22/4-3.jpg" alt></p><p>　　所以从结构上看<code>HashMap</code>和<code>ConcurrentHashMap</code>还是很相似的，只是<code>ConcurrentHashMap</code>在某些操作上采用了<code>CAS</code> + <code>synchronized</code>来保证并发情况下的安全。<br>　　<br>　　说到<code>ConcurrentHashMap</code>处理并发情况下的线程安全问题，这不得不提到<code>Hashtable</code>，因为<code>Hashtable</code>也是线程安全的，那<code>ConcurrentHashMap</code>和<code>Hashtable</code>有什么区别或者有什么高明之处嘛？以至于官方都推荐使用<code>ConcurrentHashMap</code>来代替<code>Hashtable</code></p><ul><li><p><strong>线程安全的实现</strong>：<code>Hashtable</code>采用<strong>对象锁</strong>(synchronized修饰对象方法)来保证线程安全，也就是一个<code>Hashtable</code>对象只有一把锁，如果线程1拿了对象A的锁进行有<code>synchronized</code>修饰的<code>put</code>方法，其他线程是无法操作对象A中有<code>synchronized</code>修饰的方法的(如<code>get</code>方法、<code>remove</code>方法等)，竞争激烈所以效率低下。而<code>ConcurrentHashMap</code>采用<code>CAS</code> + <code>synchronized</code>来保证并发安全性，且<code>synchronized</code>关键字不是用在方法上而是用在了具体的对象上，实现了更小粒度的锁，等会源码分析的时候在细说这个SUN大师们的鬼斧神工</p></li><li><p>数据结构的实现：<code>Hashtable</code>采用的是<strong>数组 + 链表</strong>，当链表过长会影响查询效率，而<code>ConcurrentHashMap</code>采用<strong>数组 + 链表 + 红黑树</strong>，当链表长度超过某一个值，则将链表转成红黑树，提高查询效率。</p></li></ul><p>　　</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>　　<code>ConcurrentHashMap</code>的构造函数有5个，从数量上看就和<code>HashMap</code>、<code>Hashtable</code>(4个)的不同，多出的那个构造函数是<code>public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)</code>，即除了传入容量大小、负载因子之外还多传入了一个整型的<code>concurrencyLevel</code>，这个整型是我们预先估计的并发量，比如我们估计并发是<code>30</code>，那么就可以传入<code>30</code>。</p><p>　　其他的4个构造函数的参数和<code>HashMap</code>的一样，而具体的初始化过程却又不相同，<code>HashMap</code>和<code>Hashtable</code>传入的容量大小和负载因子都是为了计算出<strong>初始阈值</strong>(threshold)，而<code>ConcurrentHashMap</code>传入的容量大小和负载因子是为了计算出<strong>sizeCtl</strong>用于初始化<code>table</code>，这个sizeCtl即table数组的大小，不同的构造函数计算sizeCtl方法都不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造函数，什么也不做，table的初始化放在了第一次插入数据时，默认容量大小是16和HashMap的一样，默认sizeCtl为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小的构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的容量大小小于0 则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果传入的容量大小大于允许的最大容量值 则cap取允许的容量最大值 否则cap =</span></span><br><span class="line">    <span class="comment">//((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)，</span></span><br><span class="line">    <span class="comment">//即如果传入的容量大小是12 则 cap = 32(12 + (12 &gt;&gt;&gt; 1) + 1=19</span></span><br><span class="line">    <span class="comment">//向上取2的幂次方即32)，这里为啥一定要是2的幂次方，原因和HashMap的threshold一样，都是为</span></span><br><span class="line">    <span class="comment">//了让位运算和取模运算的结果一样。</span></span><br><span class="line">    <span class="comment">//MAXIMUM_CAPACITY即允许的最大容量值 为2^30。</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               <span class="comment">//tableSizeFor这个函数即实现了将一个整数取2的幂次方。</span></span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//将上面计算出的cap 赋值给sizeCtl，注意此时sizeCtl为正数，代表进行扩容的容量大小。</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含指定Map的构造函数。</span></span><br><span class="line"><span class="comment">//置sizeCtl为默认容量大小 即16。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小和负载因子的构造函数。</span></span><br><span class="line"><span class="comment">//默认并发数大小是1。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入容量大小、负载因子和并发数大小的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//如果传入的容量大小 小于 传入的并发数大小，</span></span><br><span class="line">    <span class="comment">//则容量大小取并发数大小，这样做的原因是确保每一个Node只会分配给一个线程，而一个线程则</span></span><br><span class="line">    <span class="comment">//可以分配到多个Node，比如当容量大小为64，并发数大</span></span><br><span class="line">    <span class="comment">//小为16时，则每个线程分配到4个Node。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">//size = 1.0 + (long)initialCapacity / loadFactor 这里计算方法和上面的构造函数不一样。</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">//如果size大于允许的最大容量值则 sizeCtl = 允许的最大容量值 否则 sizeCtl =</span></span><br><span class="line">    <span class="comment">//size取2的幂次方。</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><ol><li>判断键值是否为<code>null</code>，为<code>null</code>抛出异常。</li><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址，这个HashMap相似。</li><li>如果当前table为空，则初始化table，需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去<strong>尝试</strong>初始化table，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程。</li><li>使用 <strong>容量大小-1 &amp; 哈希地址</strong> 计算出待插入键值的下标，如果该下标上的bucket为<code>null</code>，则直接调用实现<code>CAS</code>原子性操作的<code>casTabAt()</code>方法将节点插入到table中，如果插入成功则完成put操作，结束返回。插入失败(被别的线程抢先插入了)则继续往下执行。</li><li>如果该下标上的节点(头节点)的哈希地址为-1，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果该下标上的bucket不为空，且又不需要扩容，则进入到bucket中，同时<strong>锁住这个bucket</strong>，注意只是锁住该下标上的bucket而已，其他的bucket并未加锁，其他线程仍然可以操作其他未上锁的bucket，这个就是ConcurrentHashMap为什么高效的原因之一。</li><li>进入到bucket里面，首先判断这个bucket存储的是红黑树(哈希地址小于0，原因后面分析)还是链表。</li><li>如果是<strong>链表</strong>，则遍历链表看看是否有哈希地址和键key相同的节点，有的话则根据传入的参数进行覆盖或者不覆盖，没有找到相同的节点的话则将新增的节点<strong>插入到链表尾部</strong>。如果是<strong>红黑树</strong>，则将节点插入。到这里<strong>结束加锁</strong>。</li><li>最后判断该bucket上的链表长度是否大于<strong>链表转红黑树的阈值(8)</strong>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树，以免链表过长影响效率。</li><li>调用<code>addCount()</code>方法，作用是将ConcurrentHashMap的键值对数量+1，还有另一个作用是检查ConcurrentHashMap是否需要扩容。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不允许键值为null，这点与线程安全的Hashtable保持一致，和HashMap不同。</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//取键key的hashCode()和HashMap、Hashtable都一样，然后再执行spread()方法计算得到哈希地</span></span><br><span class="line">    <span class="comment">//址，这个spread()方法和HashMap的hash()方法一样，都是将hashCode()做无符号右移16位，只不</span></span><br><span class="line">    <span class="comment">//过spread()加多了 &amp;0x7fffffff，让结果为正数。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果table数组为空或者长度为0(未初始化)，则调用initTable()初始化table，初始化函数</span></span><br><span class="line">        <span class="comment">//下面介绍。</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//调用实现了CAS原子性操作的tabAt方法</span></span><br><span class="line">        <span class="comment">//tabAt方法的第一个参数是Node数组的引用，第二个参数在Node数组的下标，实现的是在Nod</span></span><br><span class="line">        <span class="comment">//e数组中查找指定下标的Node，如果找到则返回该Node节点(链表头节点)，否则返回null，</span></span><br><span class="line">        <span class="comment">//这里的i = (n - 1)&amp;hash即是计算待插入的节点在table的下标，即table容量-1的结果和哈</span></span><br><span class="line">        <span class="comment">//希地址做与运算，和HashMap的算法一样。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果该下标上并没有节点(即链表为空)，则直接调用实现了CAS原子性操作的</span></span><br><span class="line">            <span class="comment">//casTable()方法，</span></span><br><span class="line">            <span class="comment">//casTable()方法的第一个参数是Node数组的引用，第二个参数是待操作的下标，第三</span></span><br><span class="line">            <span class="comment">//个参数是期望值，第四个参数是待操作的Node节点，实现的是将Node数组下标为参数二</span></span><br><span class="line">            <span class="comment">//的节点替换成参数四的节点，如果期望值和实际值不符返回false，否则参数四的节点成</span></span><br><span class="line">            <span class="comment">//功替换上去，返回ture，即插入成功。注意这里：如果插入成功了则跳出for循环，插入</span></span><br><span class="line">            <span class="comment">//失败的话(其他线程抢先插入了)，那么会执行到下面的代码。</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该下标上的节点的哈希地址为-1(即链表的头节点为ForwardingNode节点)，则表示</span></span><br><span class="line">        <span class="comment">//table需要扩容，值得注意的是ConcurrentHashMap初始化和扩容不是用同一个方法，而</span></span><br><span class="line">        <span class="comment">//HashMap和Hashtable都是用同一个方法，当前线程会去协助扩容，扩容过程后面介绍。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//如果该下标上的节点既不是空也不是需要扩容，则表示这个链表可以插入值，将进入到链表</span></span><br><span class="line">        <span class="comment">//中，将新节点插入或者覆盖旧值。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//通过关键字synchroized对该下标上的节点加锁(相当于锁住锁住</span></span><br><span class="line">            <span class="comment">//该下标上的链表)，其他下标上的节点并没有加锁，所以其他线程</span></span><br><span class="line">            <span class="comment">//可以安全的获得其他下标上的链表进行操作，也正是因为这个所</span></span><br><span class="line">            <span class="comment">//以提高了ConcurrentHashMap的效率，提高了并发度。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//如果该下标上的节点的哈希地址大于等于0，则表示这是</span></span><br><span class="line">                    <span class="comment">//个链表。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果哈希地址、键key相同 或者 键key不为空</span></span><br><span class="line">                            <span class="comment">//且键key相同，则表示存在键key和待插入的键</span></span><br><span class="line">                            <span class="comment">//key相同，则执行更新值value的操作。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//如果找到了链表的最后一个节点都没有找到相</span></span><br><span class="line">                            <span class="comment">//同键Key的，则是插入操作，将插入的键值新建</span></span><br><span class="line">                            <span class="comment">//个节点并且添加到链表尾部，这个和HashMap一</span></span><br><span class="line">                            <span class="comment">//样都是插入到尾部。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果该下标上的节点的哈希地址小于0 且为树节点</span></span><br><span class="line">                    <span class="comment">//则将带插入键值新增到红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//如果插入的结果不为null，则表示为替换</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash,</span><br><span class="line">                        key,value)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断链表的长度是否大于等于链表的阈值(8)，大于则将链表转成</span></span><br><span class="line">            <span class="comment">//红黑树，提高效率。这点和HashMap一样。</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><ol><li>调用<code>spread()</code>方法计算key的hashCode()获得哈希地址。</li><li>计算出键key所在的下标，算法是(n - 1) &amp; h，如果table不为空，且下标上的bucket不为空，则到bucket中查找。</li><li>如果bucket的头节点的哈希地址小于0，则代表这个bucket存储的是红黑树，否则是链表。</li><li>到红黑树或者链表中查找，找到则返回该键key的值，找不到则返回null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//运用键key的hashCode()计算出哈希地址</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//如果table不为空 且 table长度大于0 且 计算出的下标上bucket不为空，</span></span><br><span class="line">    <span class="comment">//则代表这个bucket存在，进入到bucket中查找，</span></span><br><span class="line">    <span class="comment">//其中(n - 1) &amp; h为计算出键key相对应的数组下标的算法。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果哈希地址、键key相同则表示查找到，返回value，这里查找到的是头节点。</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果bucket头节点的哈希地址小于0，则代表bucket为红黑树，在红黑树中查找。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果bucket头节点的哈希地址不小于0，则代表bucket为链表，遍历链表，在链表中查找。</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ol><li>调用<code>spread()</code>方法计算出键key的哈希地址。</li><li>计算出键key所在的数组下标，如果table为空或者bucket为空，则返回<code>null</code>。</li><li>判断当前table是否正在扩容，如果在扩容则调用helpTransfer方法协助扩容。</li><li>如果table和bucket都不为空，table也不处于在扩容状态，则<strong>锁住当前bucket</strong>，对bucket进行操作。</li><li>根据bucket的头结点判断bucket是链表还是红黑树。</li><li>在链表或者红黑树中移除哈希地址、键key相同的节点。</li><li>调用<code>addCount</code>方法，将当前table存储的键值对数量-1。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算需要移除的键key的哈希地址。</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//遍历table。</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//table为空，或者键key所在的bucket为空，则跳出循环返回。</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//如果当前table正在扩容，则调用helpTransfer方法，去协助扩容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//将键key所在的bucket加锁。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//bucket头节点的哈希地址大于等于0，为链表。</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//遍历链表。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//找到哈希地址、键key相同的节点，进行移除。</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                    (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果bucket的头节点小于0，即为红黑树。</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                        <span class="comment">//找到节点，并且移除。</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用addCount方法，将当前ConcurrentHashMap存储的键值对数量-1。</span></span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="initTable初始化方法"><a href="#initTable初始化方法" class="headerlink" title="initTable初始化方法"></a>initTable初始化方法</h3><p>　　<code>table</code>的初始化主要由initTable()方法实现的，initTable()方法初始化一个合适大小的数组，然后设置sizeCtl。 我们知道<code>ConcurrentHashMap</code>是线程安全的，即支持多线程的，那么一开始很多个线程同时执行<code>put()</code>方法，而<code>table</code>又没初始化，那么就会很多个线程会去执行initTable()方法尝试初始化table，而<code>put</code>方法和<code>initTable</code>方法都是没有加锁的(synchronize)，那SUN的大师们是怎么保证线程安全的呢？<br>　　通过源码可以看得出，table的初始化只能由一个线程完成，但是每个线程都可以争抢去初始化table。</p><ol><li>判断table是否为<code>null</code>，即需不需要首次初始化，如果某个线程进到这个方法后，其他线程已经将table初始化好了，那么该线程结束该方法返回。</li><li>如果table为<code>null</code>，进入到while循环，如果<code>sizeCtl</code>小于0(其他线程正在对table初始化)，那么该线程调用<code>Thread.yield()</code>挂起该线程，让出CPU时间，该线程也从运行态转成就绪态，等该线程从就绪态转成运行态的时候，别的线程已经table初始化好了，那么该线程结束while循环，结束初始化方法返回。如果从就绪态转成运行态后，table仍然为<code>null</code>，则继续while循环。</li><li>如果table为<code>null</code>且<code>sizeCtl</code>不小于0，则调用实现<code>CAS</code>原子性操作的<code>compareAndSwap()</code>方法将sizeCtl设置成-1，告诉别的线程我正在初始化table，这样别的线程无法对table进行初始化。如果设置成功，则再次判断table是否为空，不为空则初始化table，容量大小为默认的容量大小(16)，或者为sizeCtl。其中sizeCtl的初始化是在构造函数中进行的，sizeCtl = ((传入的容量大小 + 传入的容量大小无符号右移1位 + 1)的结果向上取最近的2幂次方)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//如果table为null或者长度为0， //则一直循环试图初始化table(如果某一时刻别的线程将table初始化好了，那table不为null，该//线程就结束while循环)。</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl小于0，</span></span><br><span class="line">        <span class="comment">//即有其他线程正在初始化或者扩容，执行Thread.yield()将当前线程挂起，让出CPU时间，</span></span><br><span class="line">        <span class="comment">//该线程从运行态转成就绪态。</span></span><br><span class="line">        <span class="comment">//如果该线程从就绪态转成运行态了，此时table可能已被别的线程初始化完成，table不为</span></span><br><span class="line">        <span class="comment">//null，该线程结束while循环。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//如果此时sizeCtl不小于0，即没有别的线程在做table初始化和扩容操作，</span></span><br><span class="line">        <span class="comment">//那么该线程就会调用Unsafe的CAS操作compareAndSwapInt尝试将sizeCtl的值修改成</span></span><br><span class="line">        <span class="comment">//-1(sizeCtl=-1表示table正在初始化，别的线程如果也进入了initTable方法则会执行</span></span><br><span class="line">        <span class="comment">//Thread.yield()将它的线程挂起 让出CPU时间)，</span></span><br><span class="line">        <span class="comment">//如果compareAndSwapInt将sizeCtl=-1设置成功 则进入if里面，否则继续while循环。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//再次确认当前table为null即还未初始化，这个判断不能少。</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果sc(sizeCtl)大于0，则n=sc，否则n=默认的容量大</span></span><br><span class="line">                    小<span class="number">16</span>，</span><br><span class="line">                    <span class="comment">//这里的sc=sizeCtl=0，即如果在构造函数没有指定容量</span></span><br><span class="line">                    大小，</span><br><span class="line">                    <span class="comment">//否则使用了有参数的构造函数，sc=sizeCtl=指定的容量大小。</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">//创建指定容量的Node数组(table)。</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算阈值，n - (n &gt;&gt;&gt; 2) = 0.75n当ConcurrentHashMap储存的键值对数量</span></span><br><span class="line">                    <span class="comment">//大于这个阈值，就会发生扩容。</span></span><br><span class="line">                    <span class="comment">//这里的0.75相当于HashMap的默认负载因子，可以发现HashMap、Hashtable如果</span></span><br><span class="line">                    <span class="comment">//使用传入了负载因子的构造函数初始化的话，那么每次扩容，新阈值都是=新容</span></span><br><span class="line">                    <span class="comment">//量 * 负载因子，而ConcurrentHashMap不管使用的哪一种构造函数初始化，</span></span><br><span class="line">                    <span class="comment">//新阈值都是=新容量 * 0.75。</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="transfer扩容方法"><a href="#transfer扩容方法" class="headerlink" title="transfer扩容方法"></a>transfer扩容方法</h3><p>　　<code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持多线程扩容，而且也没有进行加锁，所以实现会变得有点儿复杂。整个扩容操作分为两步：</p><ol><li>构建一个nextTable，其大小为原来大小的<strong>两倍</strong>，这个步骤是在单线程环境下完成的</li><li>将原来table里面的内容复制到nextTable中，这个步骤是允许<strong>多线程</strong>操作的，所以性能得到提升，减少了扩容的时间消耗。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协助扩容方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//如果当前table不为null 且 f为ForwardingNode节点 且 //新的table即nextTable存在的情况下才能协助扩容，该方法的作用是让线程参与扩容的复制。</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//更新sizeCtl的值，+1，代表新增一个线程参与扩容</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//根据服务器CPU数量来决定每个线程负责的bucket数量，避免因为扩容的线程过多反而影响性能。</span></span><br><span class="line">    <span class="comment">//如果CPU数量为1，则stride=1，否则将需要迁移的bucket数量(table大小)除以CPU数量，平分给</span></span><br><span class="line">    <span class="comment">//各个线程，但是如果每个线程负责的bucket数量小于限制的最小是(16)的话，则强制给每个线程</span></span><br><span class="line">    <span class="comment">//分配16个bucket数。</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果nextTable还未初始化，则初始化nextTable，这个初始化和iniTable初始化一样，只能由</span></span><br><span class="line">    <span class="comment">//一个线程完成。</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="comment">//分配任务和控制当前线程的任务进度，这部分是transfer()的核心逻辑，描述了如何与其他线</span></span><br><span class="line">    <span class="comment">//程协同工作。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="comment">//迁移过程（对当前指向的bucket），这部分的逻辑与HashMap类似，拿旧数组的容量当做一</span></span><br><span class="line">        <span class="comment">//个掩码，然后与节点的hash进行与操作，可以得出该节点的新增有效位，如果新增有效位为</span></span><br><span class="line">        <span class="comment">//0就放入一个链表A，如果为1就放入另一个链表B，链表A在新数组中的位置不变（跟在旧数</span></span><br><span class="line">        <span class="comment">//组的索引一致），链表B在新数组中的位置为原索引加上旧数组容量。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="addCount、sumCount方法"><a href="#addCount、sumCount方法" class="headerlink" title="addCount、sumCount方法"></a>addCount、sumCount方法</h3><p>　　<code>addCount()</code>做的工作是更新table的size，也就是table存储的键值对数量，在使用<code>put()</code>和<code>remove()</code>方法的时候都会在执行成功之后调用<code>addCount()</code>来更新table的size。对于<code>ConcurrentHashMap</code>来说，它到底有储存有多少个键值对，谁也不知道，因为他是支持并发的，储存的数量无时无刻都在变化着，所以说<code>ConcurrentHashMap</code>也只是统计一个大概的值，为了统计出这个值也是大费周章才统计出来的。<br>　　<img src="/blogImg/2019/9/22/4-4.jpg" alt></p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//如果计算盒子不是空，或者修改baseCount的值+x失败,则放弃对baseCount的修改。</span></span><br><span class="line">    <span class="comment">//这里的大概意思就是首先尝试直接修改baseCount，达到计数的目的，如果修改baseCount失败(</span></span><br><span class="line">    <span class="comment">//多个线程同时修改，则失败)</span></span><br><span class="line">    <span class="comment">//则使用CounterCell数组来达到计数的目的。</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果计数盒子是空的 或者随机取余一个数组为空 或者修改这个槽位的变量失败，</span></span><br><span class="line">        <span class="comment">//即表示出现了并发，则执行fullAddCount()方法进行死循环插入，同时返回，</span></span><br><span class="line">        <span class="comment">//否则代表修改这个槽位的变量成功了，继续往下执行，不进入if。</span></span><br><span class="line">        <span class="comment">//每个线程都会通过ThreadLocalRandom.getProbe() &amp; m寻址找到属于它的CounterCell，</span></span><br><span class="line">        <span class="comment">//然后进行计数。ThreadLocalRandom是一个线程私有的伪随机数生成器，</span></span><br><span class="line">        <span class="comment">//每个线程的probe都是不同的。CounterCell数组的大小永远是一个2的n次方，初始容量</span></span><br><span class="line">        <span class="comment">//为2，每次扩容的新容量都是之前容量乘以二，处于性能考虑，它的最大容量上限是机器</span></span><br><span class="line">        <span class="comment">//的CPU数量，所以说CounterCell数组的碰撞冲突是很严重的。</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">             <span class="comment">//并发过大，使用CAS修改CounterCell失败时候执行fullAddCount，</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果上面对盒子的赋值成功，且check&lt;=1，则直接返回，否则调用sumConut()方法计算</span></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果check&gt;=0，则检查是否需要扩容。</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="size、mappingCount方法"><a href="#size、mappingCount方法" class="headerlink" title="size、mappingCount方法"></a>size、mappingCount方法</h3><p>　　<code>size</code>和<code>mappingCount</code>方法都是用来统计table的size的，这两者不同的地方在<code>size</code>返回的是一个<code>int</code>类型，即可以表示size的范围是[-2^31，2^31-1]，超过这个范围就返回int能表示的最大值，<code>mappingCount</code>返回的是一个<code>long</code>类型，即可以表示size的范围是[-2^63，2^63-1]。<br>　　这两个方法都是调用的sumCount()方法实现统计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h3 id="HashMap、Hashtable、ConcurrentHashMap三者对比"><a href="#HashMap、Hashtable、ConcurrentHashMap三者对比" class="headerlink" title="HashMap、Hashtable、ConcurrentHashMap三者对比"></a>HashMap、Hashtable、ConcurrentHashMap三者对比</h3><table><thead><tr><th><strong>\</strong></th><th><strong>HashMap</strong></th><th><strong>Hashtable</strong></th><th><strong>ConcurrentHashMap</strong></th></tr></thead><tbody><tr><td>是否线程安全</td><td>否</td><td>是</td><td>是</td></tr><tr><td>线程安全采用的方式</td><td></td><td>采用<code>synchronized</code>类锁，效率低</td><td>采用<code>CAS</code> + <code>synchronized</code>，锁住的只有当前操作的<strong>bucket</strong>，不影响其他线程对其他bucket的操作，效率高</td></tr><tr><td>数据结构</td><td>数组+链表+红黑树(链表长度超过8则转红黑树)</td><td>数组+链表</td><td>数组+链表+红黑树(链表长度超过8则转红黑树)</td></tr><tr><td>是否允许<code>null</code>键值</td><td>是</td><td>否</td><td>否</td></tr><tr><td>哈希地址算法</td><td>(key的hashCode)^(key的hashCode无符号右移16位)</td><td>key的hashCode</td><td>( (key的hashCode)^(key的hashCode无符号右移16位) )&amp;0x7fffffff</td></tr><tr><td>定位算法</td><td>哈希地址&amp;(容量大小-1)</td><td>(哈希地址&amp;0x7fffffff)%容量大小</td><td>哈希地址&amp;(容量大小-1)</td></tr><tr><td>扩容算法</td><td>当键值对数量大于阈值，则容量扩容到原来的2倍</td><td>当键值对数量大于等于阈值，则容量扩容到原来的2倍+1</td><td>当键值对数量大于等于sizeCtl，<strong>单线程创建新哈希表，多线程复制bucket到新哈希表</strong>，容量扩容到原来的2倍</td></tr><tr><td>链表插入</td><td>将新节点插入到链表<strong>尾部</strong></td><td>将新节点插入到链表<strong>头部</strong></td><td>将新节点插入到链表<strong>尾部</strong></td></tr><tr><td>继承的类</td><td>继承<code>abstractMap</code>抽象类</td><td>继承<code>Dictionary</code>抽象类</td><td>继承<code>abstractMap</code>抽象类</td></tr><tr><td>实现的接口</td><td>实现<code>Map</code>接口</td><td>实现<code>Map</code>接口</td><td>实现<code>ConcurrentMap</code>接口</td></tr><tr><td>默认容量大小</td><td>16</td><td>11</td><td>16</td></tr><tr><td>默认负载因子</td><td>0.75</td><td>0.75</td><td>0.75</td></tr><tr><td>统计size方式</td><td>直接返回成员变量<code>size</code></td><td>直接返回成员变量<code>count</code></td><td>遍历<code>CounterCell</code>数组的值进行累加，最后加上<code>baseCount</code>的值即为<code>size</code></td></tr></tbody></table><p>　　</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://cmsblogs.com/?p=2283" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentHashMap</a><br><a href="http://www.importnew.com/29832.html" target="_blank" rel="noopener">Map 大家族的那点事儿 ( 7 ) ：ConcurrentHashMap</a><br><a href="http://www.importnew.com/28263.html?tdsourcetag=s_pcqq_aiomsg&amp;replytocom=667559#respond" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a><br><a href="https://juejin.im/entry/59fc786d518825297f3fa968" target="_blank" rel="noopener">Java 8 ConcurrentHashMap源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ddnd.cn/2019/03/10/jdk1-8-concurrenthashmap/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>常见OOM原因及解决方案</title>
    <link href="https://mlone.top/2019/09/22/%E5%B8%B8%E8%A7%81OOM%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://mlone.top/2019/09/22/常见OOM原因及解决方案/</id>
    <published>2019-09-22T08:14:54.000Z</published>
    <updated>2019-09-22T08:43:20.249Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>来自微信公众号：java深度理解</p><br><a id="more"></a><p></p><p>　　<br>　　当 JVM 内存严重不足时，就会抛出 java.lang.OutOfMemoryError 错误。本文总结了常见的 OOM 原因及其解决方法，如下图所示：<br>　　<img src="/blogImg/2019/9/22/3-1.png" alt></p><p>　　</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>Java heap space</li><li>GC overhead limit exceeded</li><li>Permgen spaceMetaspace</li><li>Unable to create new native thread</li><li>Out of swap space？</li><li>Kill process or sacrifice child</li><li>Requested array size exceeds VM limit</li><li>Direct buffer memory</li><li>推荐工具&amp;产品</li></ul><p>　　</p><h3 id="1-Java-heap-space"><a href="#1-Java-heap-space" class="headerlink" title="1. Java heap space"></a>1. Java heap space</h3><p>　　当堆内存（Heap Space）没有足够空间存放新创建的对象时，就会抛出 <code>java.lang.OutOfMemoryError: Java heap space</code>错误（根据实际生产经验，可以对程序日志中的 <code>OutOfMemoryError</code> 配置关键字告警，一经发现，立即处理）。</p><p><strong>原因分析：</strong><br>　　Java heap space 错误产生的常见原因可以分为以下几类：</p><ul><li>请求创建一个超大对象，通常是一个大数组。</li><li>超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。</li><li>过度使用终结器（Finalizer），该对象没有立即被 GC。</li><li>内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。</li></ul><p><strong>解决方案：</strong><br>　　针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理：</p><pre><code>* 如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。* 如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。* 如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。</code></pre><p>　　</p><h3 id="2-GC-overhead-limit-exceeded"><a href="#2-GC-overhead-limit-exceeded" class="headerlink" title="2. GC overhead limit exceeded"></a>2. GC overhead limit exceeded</h3><p>　　当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，就会抛出 java.lang.OutOfMemoryError:GC overhead limit exceeded 错误。简单地说，就是应用程序已经基本耗尽了所有可用内存， GC 也无法回收。</p><p>　　此类问题的原因与解决方案跟 Java heap space 非常类似，可以参考上文。</p><p>　　</p><h3 id="3-Permgen-space"><a href="#3-Permgen-space" class="headerlink" title="3. Permgen space"></a>3. Permgen space</h3><p>　　该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。</p><p><strong> 原因分析：</strong><br>　　永久代存储对象主要包括以下几类：</p><ul><li>加载/缓存到内存中的 class 定义，包括类的名称，字段，方法和字节码；</li><li>常量池；</li><li>对象数组/类型数组所关联的 class；</li><li>JIT 编译器优化后的 class 信息。</li></ul><p>　　PermGen 的使用量与加载到内存的 class 的数量/大小正相关。</p><p><strong>解决方案：</strong><br>　　根据 Permgen space 报错的时机，可以采用不同的解决方案，如下所示：</p><pre><code>* 程序启动报错，修改 -XX:MaxPermSize 启动参数，调大永久代空间。* 应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份 class 信息，只需重启 JVM 即可解决。* 运行时报错，应用程序可能会动态创建大量 class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，可以设置 `-XX:+CMSClassUnloadingEnabled `和 `-XX:+UseConcMarkSweepGC` 这两个参数允许 JVM 卸载 class。</code></pre><p>　　如果上述方法无法解决，可以通过 jmap 命令 dump 内存对象 jmap -dump:format=b,file=dump.hprof <process-id> ，然后利用 Eclipse MAT 功能逐一分析开销最大的 classloader 和重复 class。</process-id></p><p>　　</p><h3 id="4-Metaspace"><a href="#4-Metaspace" class="headerlink" title="4. Metaspace"></a>4. Metaspace</h3><p>　　JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），该错误表示 Metaspace 已被用满，通常是因为加载的 class 数目太多或体积太大。<br>此类问题的原因与解决方法跟 Permgen space 非常类似，可以参考上文。需要特别注意的是调整 Metaspace 空间大小的启动参数为<code>-XX:MaxMetaspaceSize</code>。</p><p>　　</p><h3 id="5-Unable-to-create-new-native-thread"><a href="#5-Unable-to-create-new-native-thread" class="headerlink" title="5. Unable to create new native thread"></a>5. Unable to create new native thread</h3><p>　　每个 Java 线程都需要占用一定的内存空间，当 JVM 向底层操作系统请求创建一个新的 native 线程时，如果没有足够的资源分配就会报此类错误。</p><p><strong> 原因分析：</strong><br>　　JVM 向 OS 请求创建 native 线程失败，就会抛出 Unable to create new native thread，常见的原因包括以下几类：</p><ul><li>线程数超过操作系统最大线程数 ulimit 限制。</li><li>线程数超过 kernel.pid_max（只能重启）。</li><li>native 内存不足。</li></ul><p>该问题发生的常见过程主要包括以下几步：</p><pre><code>1. JVM 内部的应用程序请求创建一个新的 Java 线程；2. JVM native 方法代理了该次请求，并向操作系统请求创建一个 native 线程；3. 操作系统尝试创建一个新的 native 线程，并为其分配内存；4. 如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次 native 内存分配；5. JVM 将抛出 java.lang.OutOfMemoryError: Unable to create new native thread 错误。</code></pre><p><strong>解决方案：</strong></p><pre><code>* 升级配置，为机器提供更多的内存；* 降低 Java Heap Space 大小；* 修复应用程序的线程泄漏问题；* 限制线程池大小；* 使用 -Xss 参数减少线程栈的大小；* 调高 OS 层面的线程最大数：执行 ulimia -a 查看最大线程数限制，使用 ulimit -u xxx 调整最大线程数限制。</code></pre><hr><pre><code>ulimit -a.... 省略部分内容 .....max user processes              (-u) 16384</code></pre><p>　　</p><h3 id="6-Out-of-swap-space？"><a href="#6-Out-of-swap-space？" class="headerlink" title="6. Out of swap space？"></a>6. Out of swap space？</h3><p>　　该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。当运行时程序请求的虚拟内存溢出时就会报 Out of swap space? 错误。</p><p><strong>原因分析：</strong><br>　　该错误出现的常见原因包括以下几类：</p><pre><code>* 地址空间不足；* 物理内存已耗光；* 应用程序的本地内存泄漏（native leak），例如不断申请本地内存，却不释放。* 执行 jmap -histo:live 命令，强制执行 Full GC；如果几次执行后内存明显下降，则基本确认为 Direct ByteBuffer 问题。</code></pre><p><strong>解决方案：</strong></p><p>　　根据错误原因可以采取如下解决方案：</p><pre><code>* 升级地址空间为 64 bit；* 使用 Arthas 检查是否为 Inflater/Deflater 解压缩问题，如果是，则显式调用 end 方法。* Direct ByteBuffer 问题可以通过启动参数 -XX:MaxDirectMemorySize 调低阈值。* 升级服务器配置/隔离部署，避免争用。</code></pre><p>　　</p><h3 id="7-Kill-process-or-sacrifice-child"><a href="#7-Kill-process-or-sacrifice-child" class="headerlink" title="7. Kill process or sacrifice child"></a>7. Kill process or sacrifice child</h3><p>　　有一种内核作业（Kernel Job）名为 Out of Memory Killer，它会在可用内存极低的情况下“杀死”（kill）某些进程。OOM Killer 会对所有进程进行打分，然后将评分较低的进程“杀死”，具体的评分规则可以参考 Surviving the Linux OOM Killer。<br>不同于其他的 OOM 错误，Kill process or sacrifice child 错误不是由 JVM 层面触发的，而是由操作系统层面触发的。</p><p><strong>原因分析：</strong><br>　　默认情况下，Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。</p><p>　　然而，这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。</p><p><strong>解决方案：</strong></p><pre><code>* 升级服务器配置/隔离部署，避免争用。* OOM Killer 调优。</code></pre><p>　　</p><h3 id="8-Requested-array-size-exceeds-VM-limit"><a href="#8-Requested-array-size-exceeds-VM-limit" class="headerlink" title="8. Requested array size exceeds VM limit"></a>8. Requested array size exceeds VM limit</h3><p>　　JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。<br>　　JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为 <code>Integer.MAX_VALUE - 2</code>。<br>　　此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。</p><p>　　</p><h3 id="9-Direct-buffer-memory"><a href="#9-Direct-buffer-memory" class="headerlink" title="9. Direct buffer memory"></a>9. Direct buffer memory</h3><p>　　Java 允许应用程序通过 Direct ByteBuffer 直接访问堆外内存，许多高性能程序通过 Direct ByteBuffer 结合内存映射文件（Memory Mapped File）实现高速 IO。</p><p><strong>原因分析：</strong><br>　　Direct ByteBuffer 的默认大小为 64 MB，一旦使用超出限制，就会抛出 Direct buffer memory 错误。</p><p><strong>解决方案：</strong></p><pre><code>* Java 只能通过 ByteBuffer.allocateDirect 方法使用 Direct ByteBuffer，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查。* 检查是否直接或间接使用了 NIO，如 netty，jetty 等。* 通过启动参数 -XX:MaxDirectMemorySize 调整 Direct ByteBuffer 的上限值。* 检查 JVM 参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc() 失效。* 检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用 sun.misc.Cleaner 的 clean() 方法来主动释放被 Direct ByteBuffer 持有的内存空间。* 内存容量确实不足，升级配置。</code></pre><p>　　</p><h3 id="推荐工具-amp-产品"><a href="#推荐工具-amp-产品" class="headerlink" title="推荐工具&amp;产品"></a>推荐工具&amp;产品</h3><ul><li>Eclipse Memory Analyzer —— JVM 内存分析工具</li><li>ARMS —— 阿里云 APM 产品，支持 OOM 异常关键字告警</li><li>Arthas —— Java 在线诊断工具</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;来自微信公众号：java深度理解&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>ArrayList源码分析（扩容机制jdk8）</title>
    <link href="https://mlone.top/2019/09/22/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6jdk8%EF%BC%89/"/>
    <id>https://mlone.top/2019/09/22/ArrayList源码分析（扩容机制jdk8）/</id>
    <published>2019-09-22T07:41:52.000Z</published>
    <updated>2019-09-22T08:10:52.205Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://juejin.im/post/5d42ab5e5188255d691bc8d6" target="_blank" rel="noopener">https://juejin.im/post/5d42ab5e5188255d691bc8d6</a><br><a id="more"></a></p><p>　　</p><h3 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h3><hr><p>（1）<code>ArrayList</code> 是一种变长的集合类，基于定长数组实现。</p><p>（2）<code>ArrayList</code> 允许空值和重复元素，当往 ArrayList 中添加的元素数量大于其底层数组容量时，其会通过<strong>扩容</strong>机制重新生成一个更大的数组。</p><p>（3）由于 <code>ArrayList</code> 底层基于数组实现，所以其可以保证在 <code>O(1)</code> 复杂度下完成随机查找操作。</p><p>（4）<code>ArrayList</code> 是非线程安全类，并发环境下，多个线程同时操作 ArrayList，会引发不可预知的异常或错误。</p><p>　　</p><h3 id="ArrayList的成员属性"><a href="#ArrayList的成员属性" class="headerlink" title="ArrayList的成员属性"></a>ArrayList的成员属性</h3><hr><p>　　在介绍关于ArrayList的各种方法之前先看一下基础属性成员。其中<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA与EMPTY_ELEMENTDATA的区别是：当我们向数组中添加第一个元素时，DEFAULTCAPACITY_EMPTY_ELEMENTDATA将会知道数组该扩充多少</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的空的数组，这个主要是在构造方法初始化一个空数组的时候使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认size大小的空数组实例，和EMPTY_ELEMENTDATA区分开来，</span></span><br><span class="line"><span class="comment">//这样可以知道当第一个元素添加的时候进行扩容至多少</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList底层存储数据就是通过数组的形式，ArrayList长度就是数组的长度。</span></span><br><span class="line"><span class="comment">//一个空的实例elementData为上面的DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当添加第一个元素的时候</span></span><br><span class="line"><span class="comment">//会进行扩容，扩容大小就是上面的默认容量DEFAULT_CAPACITY</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//arrayList的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></p><p>　　static修饰的<code>EMPTY_ELEMENTDATA</code>和<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code><br>　　<img src="/blogImg/2019/9/22/2-1.png" alt></p><p>　　</p><h3 id="ArrayList构造方法"><a href="#ArrayList构造方法" class="headerlink" title="ArrayList构造方法"></a>ArrayList构造方法</h3><hr><p>（1）带有初始化容量的构造方法</p><ul><li>参数大于0，elementData初始化为initialCapacity大小的数组</li><li>参数小于0，elementData初始化为空数组</li><li>参数小于0，抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数为初始化容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断容量的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//elementData才是实际存放元素的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果传递的长度为0，就是直接使用自己已经定义的成员变量(一个空数组)</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<br>（2）无参构造</p><ul><li>构造方法中将elementData初始化为空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA</li><li>当调用add方法添加第一个元素的时候，会进行扩容</li><li>扩容至大小为DEFAULT_CAPACITY=10</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造，使用默认的size为10的空数组，在构造方法中没有对数组长度进行设置，会在后续调用add方法的时候进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<br>（3）参数为Collection类型的构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个参数为Collection的集合转变为ArrayList（实际上就是将集合中的元素换为了数组的形式）。如果</span></span><br><span class="line"><span class="comment">//传入的集合为null会抛出空指针异常（调用c.toArray()方法的时候）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//c.toArray()可能不会正确地返回一个 Object[]数组，那么使用Arrays.copyOf()方法</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果集合转换为数组之后数组长度为0，就直接使用自己的空成员变量初始化elementData</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面的这些构造方法理解起来比较简单，关注前两个构造方法做的事情，目的都是<strong>初始化底层数组 elementData(this.elementData=XXX)</strong>。区别在于<code>无参构造方法会将 elementData 初始化一个空数组，插入元素时，扩容将会按默认值重新初始化数组</code>。而<code>有参的构造方法则会将 elementData 初始化为参数值大小（&gt;= 0）的数组</code>。一般情况下，我们用默认的构造方法即可。倘若在可知道将会向 ArrayList 插入多少元素的情况下，可以使用有参构造方法。</p><p>　　<br>　　上面说到了使用无参构造的时候，在调用add方法的时候会进行扩容，所以下面我们就看看add方法以及扩容的细节</p><h3 id="ArrayList的add方法"><a href="#ArrayList的add方法" class="headerlink" title="ArrayList的add方法"></a>ArrayList的add方法</h3><hr><h4 id="add方法大致流程"><a href="#add方法大致流程" class="headerlink" title="add方法大致流程"></a>add方法大致流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将指定元素添加到list的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为要添加元素，所以添加之后可能导致容量不够，所以需要在添加之前进行判断（扩容）</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!（待会会介绍到fast-fail）</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　我们看到add方法中在添加元素之前，会先判断size的大小，所以我们来看看ensureCapacityInternal方法的细节</p><p>　　</p><h4 id="ensureCapacityInternal方法分析"><a href="#ensureCapacityInternal方法分析" class="headerlink" title="ensureCapacityInternal方法分析"></a>ensureCapacityInternal方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里就是判断elementData数组是不是为空数组</span></span><br><span class="line">    <span class="comment">//（使用的无参构造的时候，elementData=DEFAULTCAPACITY_EMPTY_ELEMENTDATA）</span></span><br><span class="line">    <span class="comment">//如果是，那么比较size+1(第一次调用add的时候size+1=1)和DEFAULT_CAPACITY，</span></span><br><span class="line">    <span class="comment">//那么显然容量为10</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<strong>当 要 add 进第1个元素时，minCapacity为(size+1=0+1=)1，在Math.max()方法比较后，minCapacity 为10。</strong>然后紧接着调用ensureExplicitCapacity更新modCount的值，并判断是否需要扩容</p><p>　　</p><h4 id="ensureExplicitCapacity方法分析"><a href="#ensureExplicitCapacity方法分析" class="headerlink" title="ensureExplicitCapacity方法分析"></a>ensureExplicitCapacity方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++; <span class="comment">//这里就是add方法中注释的Increments modCount</span></span><br><span class="line">    <span class="comment">//溢出</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);<span class="comment">//这里就是执行扩容的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<br>　　下面来看一下扩容的主要方法grow。</p><h4 id="grow方法分析"><a href="#grow方法分析" class="headerlink" title="grow方法分析"></a>grow方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧数组的容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// newCapacity为新数组的容量（oldCap+oldCap/2:即更新为旧容量的1.5倍）</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 检查新容量的大小是否小于最小需要容量，如果小于那旧将最小容量最为数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果新容量大于MAX_ARRAY_SIZE，使用hugeCapacity比较二者</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">// 将原数组中的元素拷贝</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　</p><h4 id="hugeCapacity方法"><a href="#hugeCapacity方法" class="headerlink" title="hugeCapacity方法"></a>hugeCapacity方法</h4><p>这里简单看一下hugeCapacity方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h4 id="add方法执行流程总结"><a href="#add方法执行流程总结" class="headerlink" title="add方法执行流程总结"></a>add方法执行流程总结</h4><p>　　我们用一幅图来简单梳理一下，当使用无参构造的时候，在第一次调用add方法之后的执行流程<br>　　<img src="/blogImg/2019/9/22/2-2.png" alt></p><p>这是第一次调用add方法的过程，当扩容值capacity为10之后，</p><ul><li>继续添加第2个元素（先注意调用<code>ensureCapacityInternal</code>方法传递的参数为<code>size+1=1+1=2</code>）</li><li>在<code>ensureCapacityInternal</code>方法中，<code>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>不成立，所以直接执行<code>ensureExplicitCapacity</code>方法</li><li><code>ensureExplicitCapacity</code>方法中<code>minCapacity</code>为刚刚传递的2，所以第二个if判断<code>（2-10=-8）</code>不会成立，即<code>newCapacity</code> 不比 <code>MAX_ARRAY_SIZE</code>大，则不会进入 <code>grow</code> 方法。数组容量为10，<code>add</code>方法中<code>return true</code>, size增为1。</li><li>假设又添加3、4……10个元素（其中过程类似，但是不会执行grow扩容方法）</li><li>当add第11个元素时候，会进入<code>grow</code>方法时，计算<code>newCapacity</code>为15，比<code>minCapacity</code>（为10+1=11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入<code>hugeCapacity</code>方法。数组容量扩为15，<code>add</code>方法中<code>return true</code>,size增为11。</li></ul><p>　　</p><h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index,E element)方法"></a>add(int index,E element)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在元素序列 index 位置处插入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index); <span class="comment">//校验传递的index参数是不是合法</span></span><br><span class="line">    <span class="comment">// 1. 检测是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2. 将 index 及其之后的所有元素都向后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 3. 将新元素插入至 index 处</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>) <span class="comment">//这里判断的index&gt;size（保证数组的连续性），index小于0</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>add(int index, E element)</code>方法（在元素序列指定位置（<code>假设该位置合理</code>）插入）的过程大概是下面这些</p><ol><li>检测数组是否有足够的空间(这里的实现和上面的)</li><li>将 index 及其之后的所有元素向后移一位</li><li>将新元素插入至 index 处.</li></ol><p>　　将新元素插入至序列指定位置，需要先将该位置及其之后的元素都向后移动一位，为新元素腾出位置。这个操作的时间复杂度为<code>O(N)</code>，频繁移动元素可能会导致效率问题，特别是集合中元素数量较多时。在日常开发中，若非所需，我们应当尽量避免在大集合中调用第二个插入方法。</p><p>　　</p><h3 id="ArrayList的remove方法"><a href="#ArrayList的remove方法" class="headerlink" title="ArrayList的remove方法"></a>ArrayList的remove方法</h3><hr><p>ArrayList支持两种删除元素的方式：<br>1、remove(int index) 按照下标删除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index); <span class="comment">//校验下标是否合法（如果index&gt;size，旧抛出IndexOutOfBoundsException异常）</span></span><br><span class="line">    modCount++;<span class="comment">//修改list结构，就需要更新这个值</span></span><br><span class="line">    E oldValue = elementData(index); <span class="comment">//直接在数组中查找这个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;<span class="comment">//这里计算所需要移动的数目</span></span><br><span class="line">    <span class="comment">//如果这个值大于0 说明后续有元素需要左移(size=index+1)</span></span><br><span class="line">    <span class="comment">//如果是0说明被移除的对象就是最后一位元素(不需要移动别的元素)</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//索引index只有的所有元素左移一位  覆盖掉index位置上的元素</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//移动之后，原数组中size位置null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="comment">//返回旧值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//src:源数组   </span></span><br><span class="line"><span class="comment">//srcPos:从源数组的srcPos位置处开始移动</span></span><br><span class="line"><span class="comment">//dest:目标数组</span></span><br><span class="line"><span class="comment">//desPos:源数组的srcPos位置处开始移动的元素，这些元素从目标数组的desPos处开始填充</span></span><br><span class="line"><span class="comment">//length:移动源数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p><p> 删除过程如下图所示<br>　　<img src="/blogImg/2019/9/22/2-3.png" alt></p><p>　　<br>2、remove(Object o) 按照元素删除，会删除和参数匹配的第一个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果元素是null 遍历数组移除第一个null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历找到第一个null元素的下标 调用下标移除元素的方法</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到元素对应的下标 调用下标移除元素的方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照下标移除元素（通过数组元素的位置移动来达到删除的效果）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="ArrayList的其他方法"><a href="#ArrayList的其他方法" class="headerlink" title="ArrayList的其他方法"></a>ArrayList的其他方法</h3><hr><h4 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a>ensureCapacity方法</h4><p><strong>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量从新分配的次数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h3 id="ArrayList总结"><a href="#ArrayList总结" class="headerlink" title="ArrayList总结"></a>ArrayList总结</h3><hr><p>（1）<code>ArrayList</code> 是一种变长的集合类，基于定长数组实现，使用默认构造方法初始化出来的容量是10（1.7之后都是延迟初始化，即第一次调用add方法添加元素的时候才将elementData容量初始化为10）。</p><p>（2）<code>ArrayList</code> 允许空值和重复元素，当往 ArrayList 中添加的元素数量大于其底层数组容量时，其会通过<strong>扩容</strong>机制重新生成一个更大的数组。<code>ArrayList</code>扩容的长度是原长度的1.5倍</p><p>（3）由于 <code>ArrayList</code> 底层基于数组实现，所以其可以保证在 <code>O(1)</code> 复杂度下完成随机查找操作。</p><p>（4）<code>ArrayList</code> 是非线程安全类，并发环境下，多个线程同时操作 ArrayList，会引发不可预知的异常或错误。</p><p>（5）顺序添加很方便</p><p>（6）删除和插入需要复制数组，性能差（可以使用LinkindList）</p><p>（7）Integer.MAX_VALUE - 8 ：主要是考虑到不同的JVM,有的JVM会在加入一些数据头,当扩容后的容量大于MAX_ARRAY_SIZE,我们会去比较最小需要容量和MAX_ARRAY_SIZE做比较,如果比它大, 只能取Integer.MAX_VALUE,否则是Integer.MAX_VALUE -8。 这个是从jdk1.7开始才有的</p><p>　　</p><h3 id="fast-fail机制"><a href="#fast-fail机制" class="headerlink" title="fast-fail机制"></a>fast-fail机制</h3><hr><p>fail-fast的解释：</p><blockquote><p>在系统设计中，快速失效系统一种可以立即报告任何可能表明故障的情况的系统。快速失效系统通常设计用于停止正常操作，而不是试图继续可能存在缺陷的过程。这种设计通常会在操作中的多个点检查系统的状态，因此可以及早检测到任何故障。快速失败模块的职责是检测错误，然后让系统的下一个最高级别处理错误。</p></blockquote><p>　　就是在做系统设计的时候先考虑异常情况，一旦发生异常，直接停止并上报，比如下面的这个简单的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的代码是一个对两个整数做除法的方法，在fast_fail_method方法中，我们对被除数做了个简单的检查，如果其值为0，那么就直接抛出一个异常，并明确提示异常原因。这其实就是fail-fast理念的实际应用。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fast_fail_method</span><span class="params">(<span class="keyword">int</span> arg1,<span class="keyword">int</span> arg2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg2 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can't be zero"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arg1/arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在Java集合类中很多地方都用到了该机制进行设计，一旦使用不当，触发fail-fast机制设计的代码，就会发生非预期情况。我们通常说的Java中的fail-fast机制，<strong>默认指的是Java集合的一种错误检测机制</strong>。当多个线程对部分集合进行结构上的改变的操作时，有可能会触发该机制时，之后就会抛出并发修改异常<strong><code>ConcurrentModificationException</code></strong>.当然如果不在多线程环境下，如果在foreach遍历的时候使用add/remove方法，也可能会抛出该异常。参考<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F3542" target="_blank" rel="noopener">fast-fail机制</a>，这里简单做个总结</p><p>　　<code>之所以会抛出ConcurrentModificationException异常，是因为我们的代码中使用了增强for循环，而在增强for循环中，集合遍历是通过iterator进行的，但是元素的add/remove却是直接使用的集合类自己的方法。这就导致iterator在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被删除/添加了，就会抛出一个异常，用来提示可能发生了并发修改！所以，在使用Java的集合类的时候，如果发生ConcurrentModificationException，优先考虑fail-fast有关的情况，实际上这可能并没有真的发生并发，只是Iterator使用了fail-fast的保护机制，只要他发现有某一次修改是未经过自己进行的，那么就会抛出异常。</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://juejin.im/post/5d42ab5e5188255d691bc8d6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5d42ab5e5188255d691bc8d6&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring WebClient与RestTemplate比较</title>
    <link href="https://mlone.top/2019/09/22/Spring-WebClient%E4%B8%8ERestTemplate%E6%AF%94%E8%BE%83/"/>
    <id>https://mlone.top/2019/09/22/Spring-WebClient与RestTemplate比较/</id>
    <published>2019-09-22T07:27:10.000Z</published>
    <updated>2019-09-22T07:35:45.234Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://www.baeldung.com/spring-webclient-resttemplate" target="_blank" rel="noopener">https://www.baeldung.com/spring-webclient-resttemplate</a><br><a id="more"></a></p><p>　　</p><h3 id="1-导读"><a href="#1-导读" class="headerlink" title="1. 导读"></a><strong>1. 导读</strong></h3><p>　　在这篇教程中，我们将对比两种 Spring Web 客户端实现，RestTemplate 和新的 Spring 5 Reactive WebClient。</p><p>　　</p><h3 id="2-阻塞式客户端-vs-非阻塞客户端"><a href="#2-阻塞式客户端-vs-非阻塞客户端" class="headerlink" title="2. 阻塞式客户端 vs 非阻塞客户端"></a><strong>2. 阻塞式客户端 vs 非阻塞客户端</strong></h3><p>　　在 Web 应用程序中，向其他服务发起 HTTP 调用是常见需求。因此，需要一个 Web 客户端工具。</p><p>　　</p><h4 id="2-1-RestTemplate-阻塞式客户端"><a href="#2-1-RestTemplate-阻塞式客户端" class="headerlink" title="2.1. RestTemplate 阻塞式客户端"></a><strong>2.1. RestTemplate 阻塞式客户端</strong></h4><p>　　长期以来，Spring 一直把 RestTemplate 作为默认 Web 客户端。<strong>RestTemplate 使用 Java Servlet API，这种模型在底层会为每个请求分配处理线程</strong>。</p><p>　　这意味着线程会一直保持阻塞，直到 Web 客户端收到响应。阻塞式模型的问题在于每个线程都会消耗大量内存和 CPU 资源。</p><p>　　让我们考虑这样的情况：系统收到大批请求时，等待某些服务返回结果，而这些服务本身执行缓慢。</p><p>　　结果，等待的请求会发生堆积。<strong>应用程序将创建许多线程，耗尽线程池并占掉所有可用内存</strong>。还可能因为 CPU 上下文（线程）频繁切换导致性能下降。</p><p>　　</p><h4 id="2-2-WebClient-非阻塞客户端"><a href="#2-2-WebClient-非阻塞客户端" class="headerlink" title="2.2. WebClient 非阻塞客户端"></a><strong>2.2. WebClient 非阻塞客户端</strong></h4><p>　　另一种 WebClient 方案，利用 Spring Reactive 框架提供异步、非阻塞式解决方案。</p><p>　　RestTemplate 为每个事件（HTTP 调用）创建一个新线程，而 WebClient 为每个事件创建类似 task 的结构。Reactive 框架会在后台对这些 task 进行排队，且只在响应结果就绪后才开始执行。</p><p>　　Reactive 框架采用事件驱动，通过Reactive Streams API 实现异步逻辑。相比同步阻塞式调用，Reactive 方法用更少的线程和系统资源处理了更多业务逻辑。</p><p>　　Webclient 是 Spring WebFlux 开发库的一部分。因此，<strong>写客户端代码时，还可以应用函数式编程与流式 API，支持 Reactive 类型（Mono 和 Flux）</strong>。</p><p>　　</p><h3 id="3-实例比较"><a href="#3-实例比较" class="headerlink" title="3. 实例比较"></a>3. 实例比较</h3><p>　　为了展示两种方法差异，需要多客户端并行请求进行性能测试。可以看到，收到多个客户端请求后，阻塞方法的性能显著下降。</p><p>　　而 Reactive 非阻塞方法的表现应该与请求数量无关，性能稳定。</p><p>　　这里会实现两个 REST Endpoint：一个用 RestTemplate，另一个用 WebClient。它们的任务是调用另一个耗时的 REST Web 服务，返回推文列表。</p><p>首先，需要添加 Spring Boot WebFlux Starter 依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>下面 REST Endpoint，比较耗时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/slow-service-tweets"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Tweet&gt; <span class="title">getAllTweets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>); *<span class="comment">// 延迟*</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">      <span class="keyword">new</span> Tweet(<span class="string">"RestTemplate rules"</span>, <span class="string">"@user1"</span>),</span><br><span class="line">      <span class="keyword">new</span> Tweet(<span class="string">"WebClient is better"</span>, <span class="string">"@user2"</span>),</span><br><span class="line">      <span class="keyword">new</span> Tweet(<span class="string">"OK, both are useful"</span>, <span class="string">"@user1"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h4 id="3-1-RestTemplate-调用耗时服务"><a href="#3-1-RestTemplate-调用耗时服务" class="headerlink" title="3.1. RestTemplate 调用耗时服务"></a><strong>3.1. RestTemplate 调用耗时服务</strong></h4><p>　　接着实现 REST Endpoint，通过 WebClient 调用耗时服务。</p><p>　　先使用 RestTemplate：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/tweets-blocking"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Tweet&gt; <span class="title">getTweetsBlocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Starting BLOCKING Controller!"</span>);</span><br><span class="line">    <span class="keyword">final</span> String uri = getSlowServiceUri();</span><br><span class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    ResponseEntity&lt;List&lt;Tweet&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">      uri, HttpMethod.GET, <span class="keyword">null</span>,</span><br><span class="line">      <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;Tweet&gt;&gt;()&#123;&#125;);</span><br><span class="line">    List&lt;Tweet&gt; result = response.getBody();</span><br><span class="line">    result.forEach(tweet -&gt; log.info(tweet.toString()));</span><br><span class="line">    log.info(<span class="string">"Exiting BLOCKING Controller!"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　由于 RestTemplate 是同步调用，调用 Endpoint 时代码将进入阻塞等待被调用的耗时服务响应。只有在收到响应后，才会执行方法中的后续代码。通过日志可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Starting BLOCKING Controller!</span><br><span class="line">Tweet(text=RestTemplate rules, username=@user1)</span><br><span class="line">Tweet(text=WebClient is better, username=@user2)</span><br><span class="line">Tweet(text=OK, both are useful, username=@user1)</span><br><span class="line">Exiting BLOCKING Controller!</span><br></pre></td></tr></table></figure></p><p>　　</p><h4 id="3-2-WebClient-调用耗时服务"><a href="#3-2-WebClient-调用耗时服务" class="headerlink" title="3.2. WebClient 调用耗时服务"></a><strong>3.2. WebClient 调用耗时服务</strong></h4><p>　　接下来用 WebClient 调用耗时服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/tweets-non-blocking"</span>,</span><br><span class="line">            produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;Tweet&gt; <span class="title">getTweetsNonBlocking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Starting NON-BLOCKING Controller!"</span>);</span><br><span class="line">    Flux&lt;Tweet&gt; tweetFlux = WebClient.create()</span><br><span class="line">      .get()</span><br><span class="line">      .uri(getSlowServiceUri())</span><br><span class="line">      .retrieve()</span><br><span class="line">      .bodyToFlux(Tweet.class);</span><br><span class="line">    tweetFlux.subscribe(tweet -&gt; log.info(tweet.toString()));</span><br><span class="line">    log.info(<span class="string">"Exiting NON-BLOCKING Controller!"</span>);</span><br><span class="line">    <span class="keyword">return</span> tweetFlux;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　上面的情况，WebClient 返回 Flux publisher 后就执行完成了。结果就绪时，publisher 会向订阅者发送推文列表。注意：客户端（这里指 Web 浏览器）调用 /tweets-non-blocking Endpoint 也可以订阅 Flux 对象。</p><p>这次的日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Starting NON-BLOCKING Controller!</span><br><span class="line">Exiting NON-BLOCKING Controller!</span><br><span class="line">Tweet(text=RestTemplate rules, username=@user1)</span><br><span class="line">Tweet(text=WebClient is better, username=@user2)</span><br><span class="line">Tweet(text=OK, both are useful, username=@user1)</span><br></pre></td></tr></table></figure></p><p>　　请注意：这个 Endpoint 方法在收到响应前就已执行完成。</p><p>　　</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>　　这篇文章讨论了 Spring 中使用 Web Client 的两种不同方式。</p><p>　　RestTemplate 采用 Java Servlet API，因而是阻塞式同步调用。相反，WebClient 是异步的，等待响应的同时不会阻塞正在执行的线程。只有在响应结果准备就绪时，才会发起通知。</p><p>　　RestTemplate 仍然有用武之地。非阻塞模式在某些场景下比阻塞方法占用系统资源要少得多，这时 WebClient 是一种更好的选择。</p><p>　　本文所有源代码可以在 GitHub 上找到：<br>github.com/eugenp/tutorials/tree/master/spring-5-reactive-2</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://www.baeldung.com/spring-webclient-resttemplate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.baeldung.com/spring-webclient-resttemplate&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
      <category term="Spring" scheme="https://mlone.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring如何解决循环依赖的问题</title>
    <link href="https://mlone.top/2019/09/22/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://mlone.top/2019/09/22/Spring如何解决循环依赖的问题/</id>
    <published>2019-09-22T06:59:26.000Z</published>
    <updated>2019-09-22T07:21:12.649Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://my.oschina.net/zhangxufeng/blog/3096394" target="_blank" rel="noopener">https://my.oschina.net/zhangxufeng/blog/3096394</a><br><a id="more"></a></p><p>　　<br>　　在关于Spring的面试中，我们经常会被问到一个问题，就是Spring是如何解决循环依赖的问题的。这个问题算是关于Spring的一个高频面试题，因为如果不刻意研读，相信即使读过源码，面试者也不一定能够一下子思考出个中奥秘。本文主要针对这个问题，从源码的角度对其实现原理进行讲解。</p><p>　　</p><h3 id="1-过程演示"><a href="#1-过程演示" class="headerlink" title="1. 过程演示"></a>1. 过程演示</h3><p>　　关于Spring bean的创建，其本质上还是一个对象的创建，既然是对象，读者朋友一定要明白一点就是，一个完整的对象包含两部分：当前对象实例化和对象属性的实例化。在Spring中，对象的实例化是通过反射实现的，而对象的属性则是在对象实例化之后通过一定的方式设置的。这个过程可以按照如下方式进行理解：<br>　　<img src="/blogImg/2019/9/22/1-1.jpg" alt></p><p>　　理解这一个点之后，对于循环依赖的理解就已经帮助一大步了，我们这里以两个类A和B为例进行讲解，如下是A和B的声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以看到，这里A和B中各自都以对方为自己的全局属性。这里首先需要说明的一点是，Spring实例化bean是通过<code>pplicationContext.getBean()</code>法来进行的。如果要获取的对象依赖了另一个对象，那么其首先会创建当前对象，然后通过递归的调用<code>pplicationContext.getBean()</code>法来获取所依赖的对象，最后将获取到的对象注入到当前对象中。<br>　　<br>　　这里我们以上面的首先初始化A对象实例为例进行讲解。首先Spring尝试通过<code>pplicationContext.getBean()</code>法获取A对象的实例，由于Spring容器中还没有A对象实例，因而其会创建一个A对象，然后发现其依赖了B对象，因而会尝试递归的通过<code>pplicationContext.getBean()</code>法获取B对象的实例，但是Spring容器中此时也没有B对象的实例，因而其还是会先创建一个B对象的实例。读者需要注意这个时间点，此时A对象和B对象都已经创建了，并且保存在Spring容器中了，只不过A对象的属性b和B对象的属性a都还没有设置进去。在前面Spring创建B对象之后，Spring发现B对象依赖了属性A，因而此时还是会尝试递归的调用<code>pplicationContext.getBean()</code>法获取A对象的实例，因为Spring中已经有一个A对象的实例，虽然只是半成品（其属性b还未初始化），但其也还是目标bean，因而会将该A对象的实例返回。此时，B对象的属性a就设置进去了，然后还是<code>pplicationContext.getBean()</code>法递归的返回，也就是将B对象的实例返回，此时就会将该实例设置到A对象的属性b中。这个时候，注意A对象的属性b和B对象的属性a都已经设置了目标对象的实例了。<br>　　<br>　　读者朋友可能会比较疑惑的是，前面在为对象B设置属性a的时候，这个A类型属性还是个半成品。但是需要注意的是，这个A是一个引用，其本质上还是最开始就实例化的A对象。而在上面这个递归过程的最后，Spring将获取到的B对象实例设置到了A对象的属性b中了，这里的A对象其实和前面设置到实例B中的半成品A对象是同一个对象，其引用地址是同一个，这里为A对象的b属性设置了值，其实也就是为那个半成品的a属性设置了值。下面我们通过一个流程图来对这个过程进行讲解：<br>　　<img src="/blogImg/2019/9/22/1-2.jpg" alt></p><p>　　图中<code>getBean()</code>表示调用Spring的<code>ApplicationContext.getBean()</code>方法，而该方法中的参数，则表示我们要尝试获取的目标对象。图中的黑色箭头表示一开始的方法调用走向，走到最后，返回了Spring中缓存的A对象之后，表示递归调用返回了，此时使用绿色的箭头表示。从图中我们可以很清楚的看到，B对象的a属性是在第三步中注入的半成品A对象，而A对象的b属性是在第二步中注入的成品B对象，此时半成品的A对象也就变成了成品的A对象，因为其属性已经设置完成了。</p><p>　　</p><h3 id="2-源码讲解"><a href="#2-源码讲解" class="headerlink" title="2. 源码讲解"></a>2. 源码讲解</h3><p>　　对于Spring处理循环依赖问题的方式，我们这里通过上面的流程图其实很容易就可以理解，需要注意的一个点就是，Spring是如何标记开始生成的A对象是一个半成品，并且是如何保存A对象的。这里的标记工作Spring是使用ApplicationContext的属性<code>Set&lt;String&gt; singletonsCurrentlyInCreation</code>来保存的，而半成品的A对象则是通过<code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code>来保存的，这里的<code>ObjectFactory</code>是一个工厂对象，可通过调用其<code>getObject()</code>方法来获取目标对象。在<code>AbstractBeanFactory.doGetBean()</code>方法中获取对象的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试通过bean名称获取目标bean对象，比如这里的A对象</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 我们这里的目标对象都是单例的</span></span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    <span class="comment">// 这里就尝试创建目标对象，第二个参数传的就是一个ObjectFactory类型的对象，这里是使用Java8的lamada</span></span><br><span class="line">    <span class="comment">// 表达式书写的，只要上面的getSingleton()方法返回值为空，则会调用这里的getSingleton()方法来创建</span></span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试创建目标对象</span></span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这里的<code>doGetBean()</code>方法是非常关键的一个方法（中间省略了其他代码），上面也主要有两个步骤，第一个步骤的<code>getSingleton()</code>方法的作用是尝试从缓存中获取目标对象，如果没有获取到，则尝试获取半成品的目标对象；如果第一个步骤没有获取到目标对象的实例，那么就进入第二个步骤，第二个步骤的<code>getSingleton()</code>方法的作用是尝试创建目标对象，并且为该对象注入其所依赖的属性。</p><p>　　<br>　　这里其实就是主干逻辑，我们前面图中已经标明，在整个过程中会调用三次<code>doGetBean()</code>方法，第一次调用的时候会尝试获取A对象实例，此时走的是第一个<code>getSingleton()</code>方法，由于没有已经创建的A对象的成品或半成品，因而这里得到的是null，然后就会调用第二个<code>getSingleton()</code>方法，创建A对象的实例，然后递归的调用<code>doGetBean()</code>方法，尝试获取B对象的实例以注入到A对象中，此时由于Spring容器中也没有B对象的成品或半成品，因而还是会走到第二个<code>getSingleton()</code>方法，在该方法中创建B对象的实例，创建完成之后，尝试获取其所依赖的A的实例作为其属性，因而还是会递归的调用<code>doGetBean()</code>方法，此时需要注意的是，在前面由于已经有了一个半成品的A对象的实例，因而这个时候，再尝试获取A对象的实例的时候，会走第一个<code>getSingleton()</code>方法，在该方法中会得到一个半成品的A对象的实例。然后将该实例返回，并且将其注入到B对象的属性a中，此时B对象实例化完成。然后将实例化完成的B对象递归的返回，此时就会将该实例注入到A对象中，这样就得到了一个成品的A对象。我们这里可以阅读上面的第一个<code>getSingleton()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试从缓存中获取成品的目标对象，如果存在，则直接返回</span></span><br><span class="line">  Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  <span class="comment">// 如果缓存中不存在目标对象，则判断当前对象是否已经处于创建过程中，在前面的讲解中，第一次尝试获取A对象</span></span><br><span class="line">  <span class="comment">// 的实例之后，就会将A对象标记为正在创建中，因而最后再尝试获取A对象的时候，这里的if判断就会为true</span></span><br><span class="line">  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        <span class="comment">// 这里的singletonFactories是一个Map，其key是bean的名称，而值是一个ObjectFactory类型的</span></span><br><span class="line">        <span class="comment">// 对象，这里对于A和B而言，调用图其getObject()方法返回的就是A和B对象的实例，无论是否是半成品</span></span><br><span class="line">        ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 获取目标对象的实例</span></span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">          <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这里我们会存在一个问题就是A的半成品实例是如何实例化的，然后是如何将其封装为一个ObjectFactory类型的对象，并且将其放到上面的singletonFactories属性中的。这主要是在前面的第二个getSingleton()方法中，其最终会通过其传入的第二个参数，从而调用createBean()方法，该方法的最终调用是委托给了另一个doCreateBean()方法进行的，这里面有如下一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化当前尝试获取的bean对象，比如A对象和B对象都是在这里实例化的</span></span><br><span class="line">  BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断Spring是否配置了支持提前暴露目标bean，也就是是否支持提前暴露半成品的bean</span></span><br><span class="line">  <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences </span><br><span class="line">    &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="comment">// 如果支持，这里就会将当前生成的半成品的bean放到singletonFactories中，这个singletonFactories</span></span><br><span class="line">    <span class="comment">// 就是前面第一个getSingleton()方法中所使用到的singletonFactories属性，也就是说，这里就是</span></span><br><span class="line">    <span class="comment">// 封装半成品的bean的地方。而这里的getEarlyBeanReference()本质上是直接将放入的第三个参数，也就是</span></span><br><span class="line">    <span class="comment">// 目标bean直接返回</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在初始化实例之后，这里就是判断当前bean是否依赖了其他的bean，如果依赖了，</span></span><br><span class="line">    <span class="comment">// 就会递归的调用getBean()方法尝试获取目标bean</span></span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　到这里，Spring整个解决循环依赖问题的实现思路已经比较清楚了。对于整体过程，读者朋友只要理解两点：</p><ul><li>Spring是通过递归的方式获取目标bean及其所依赖的bean的；</li><li>Spring实例化一个bean的时候，是分两步进行的，首先实例化目标bean，然后为其注入属性。</li></ul><p>　　结合这两点，也就是说，Spring在实例化一个bean的时候，是首先递归的实例化其所依赖的所有bean，直到某个bean没有依赖其他bean，此时就会将该实例返回，然后反递归的将获取到的bean设置为各个上层bean的属性的。</p><p>　　</p><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>　　本文首先通过图文的方式对Spring是如何解决循环依赖的问题进行了讲解，然后从源码的角度详细讲解了Spring是如何实现各个bean的装配工作的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://my.oschina.net/zhangxufeng/blog/3096394&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.oschina.net/zhangxufeng/blog/3096394&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
  </entry>
  
  <entry>
    <title>16个超级实用的java工具类</title>
    <link href="https://mlone.top/2019/09/22/16%E4%B8%AA%E8%B6%85%E7%BA%A7%E5%AE%9E%E7%94%A8%E7%9A%84java%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://mlone.top/2019/09/22/16个超级实用的java工具类/</id>
    <published>2019-09-22T06:11:48.000Z</published>
    <updated>2019-09-22T06:30:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://juejin.im/post/5d4a25b351882505c105cc6e" target="_blank" rel="noopener">排名前16的Java工具类</a><br><a id="more"></a></p><p>　　<br>　　在Java中，工具类定义了一组公共方法，这篇文章将介绍Java中使用最频繁及最通用的Java工具类。以下工具类、方法按使用流行度排名，参考数据来源于Github上随机选取的5万个开源项目源码。</p><p>　　</p><h3 id="一-org-apache-commons-io-IOUtils"><a href="#一-org-apache-commons-io-IOUtils" class="headerlink" title="一. org.apache.commons.io.IOUtils"></a>一. org.apache.commons.io.IOUtils</h3><ul><li>closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在finally块</li><li>toString：转换IO流、 Uri、 byte[]为String</li><li>copy：IO流数据复制，从输入流写到输出流中，最大支持2GB</li><li>toByteArray：从输入流、URI获取byte[]</li><li>write：把字节. 字符等写入输出流</li><li>toInputStream：把字符转换为输入流</li><li>readLines：从输入流中读取多行数据，返回List<string></string></li><li>copyLarge：同copy，支持2GB以上数据的复制</li><li>lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败</li></ul><p>　　</p><h3 id="二-org-apache-commons-io-FileUtils"><a href="#二-org-apache-commons-io-FileUtils" class="headerlink" title="二. org.apache.commons.io.FileUtils"></a>二. org.apache.commons.io.FileUtils</h3><ul><li>deleteDirectory：删除文件夹</li><li>readFileToString：以字符形式读取文件内容</li><li>deleteQueitly：删除文件或文件夹且不会抛出异常</li><li>copyFile：复制文件</li><li>writeStringToFile：把字符写到目标文件，如果文件不存在，则创建</li><li>forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级</li><li>write：把字符写到指定文件中</li><li>listFiles：列举某个目录下的文件(根据过滤器)</li><li>copyDirectory：复制文件夹</li><li>forceDelete：强制删除文件</li></ul><p>　　</p><h3 id="三-org-apache-commons-lang-StringUtils"><a href="#三-org-apache-commons-lang-StringUtils" class="headerlink" title="三. org.apache.commons.lang.StringUtils"></a>三. org.apache.commons.lang.StringUtils</h3><ul><li>isBlank：字符串是否为空 (trim后判断)</li><li>isEmpty：字符串是否为空 (不trim并判断)</li><li>equals：字符串是否相等</li><li>join：合并数组为单一字符串，可传分隔符</li><li>split：分割字符串</li><li>EMPTY：返回空字符串</li><li>trimToNull：trim后为空字符串则转换为null</li><li>replace：替换字符串</li></ul><p>　　</p><h3 id="四-org-apache-http-util-EntityUtils"><a href="#四-org-apache-http-util-EntityUtils" class="headerlink" title="四. org.apache.http.util.EntityUtils"></a>四. org.apache.http.util.EntityUtils</h3><ul><li>toString：把Entity转换为字符串</li><li>consume：确保Entity中的内容全部被消费。可以看到源码里又一次消费了Entity的内容，假如用户没有消费，那调用Entity时候将会把它消费掉</li><li>toByteArray：把Entity转换为字节流</li><li>consumeQuietly：和consume一样，但不抛异常</li><li>getContentCharset：获取内容的编码</li></ul><p>　　</p><h3 id="五-org-apache-commons-lang3-StringUtils"><a href="#五-org-apache-commons-lang3-StringUtils" class="headerlink" title="五. org.apache.commons.lang3.StringUtils"></a>五. org.apache.commons.lang3.StringUtils</h3><ul><li>isBlank：字符串是否为空 (trim后判断)</li><li>isEmpty：字符串是否为空 (不trim并判断)</li><li>equals：字符串是否相等</li><li>join：合并数组为单一字符串，可传分隔符</li><li>split：分割字符串</li><li>EMPTY：返回空字符串</li><li>replace：替换字符串</li><li>capitalize：首字符大写</li></ul><p>　　</p><h3 id="六-org-apache-commons-io-FilenameUtils"><a href="#六-org-apache-commons-io-FilenameUtils" class="headerlink" title="六. org.apache.commons.io.FilenameUtils"></a>六. org.apache.commons.io.FilenameUtils</h3><ul><li>getExtension：返回文件后缀名</li><li>getBaseName：返回文件名，不包含后缀名</li><li>getName：返回文件全名</li><li>concat：按命令行风格组合文件路径(详见方法注释)</li><li>removeExtension：删除后缀名</li><li>normalize：使路径正常化</li><li>wildcardMatch：匹配通配符</li><li>seperatorToUnix：路径分隔符改成unix系统格式的，即/</li><li>getFullPath：获取文件路径，不包括文件名</li><li>isExtension：检查文件后缀名是不是传入参数(List<string>)中的一个</string></li></ul><p>　　</p><h3 id="七-org-springframework-util-StringUtils"><a href="#七-org-springframework-util-StringUtils" class="headerlink" title="七. org.springframework.util.StringUtils"></a>七. org.springframework.util.StringUtils</h3><ul><li>hasText：检查字符串中是否包含文本</li><li>hasLength：检测字符串是否长度大于0</li><li>isEmpty：检测字符串是否为空（若传入为对象，则判断对象是否为null）</li><li>commaDelimitedStringToArray：逗号分隔的String转换为数组</li><li>collectionToDelimitedString：把集合转为CSV格式字符串</li><li>replace 替换字符串</li><li>delimitedListToStringArray：相当于split</li><li>uncapitalize：首字母小写</li><li>collectionToDelimitedCommaString：把集合转为CSV格式字符串</li><li>tokenizeToStringArray：和split基本一样，但能自动去掉空白的单词</li></ul><p>　　</p><h3 id="八-org-apache-commons-lang-ArrayUtils"><a href="#八-org-apache-commons-lang-ArrayUtils" class="headerlink" title="八. org.apache.commons.lang.ArrayUtils"></a>八. org.apache.commons.lang.ArrayUtils</h3><ul><li>contains：是否包含某字符串</li><li>addAll：添加整个数组</li><li>clone：克隆一个数组</li><li>isEmpty：是否空数组</li><li>add：向数组添加元素</li><li>subarray：截取数组</li><li>indexOf：查找某个元素的下标</li><li>isEquals：比较数组是否相等</li><li>toObject：基础类型数据数组转换为对应的Object数组</li></ul><p>　　</p><h3 id="九-org-apache-commons-lang-StringEscapeUtils"><a href="#九-org-apache-commons-lang-StringEscapeUtils" class="headerlink" title="九. org.apache.commons.lang.StringEscapeUtils"></a>九. org.apache.commons.lang.StringEscapeUtils</h3><ul><li><p>参考十五：</p><p>org.apache.commons.lang3.StringEscapeUtils</p></li></ul><p>　　</p><h3 id="十-org-apache-http-client-utils-URLEncodedUtils"><a href="#十-org-apache-http-client-utils-URLEncodedUtils" class="headerlink" title="十. org.apache.http.client.utils.URLEncodedUtils"></a>十. org.apache.http.client.utils.URLEncodedUtils</h3><ul><li>format：格式化参数，返回一个HTTP POST或者HTTP PUT可用application/x-www-form-urlencoded字符串</li><li>parse：把String或者URI等转换为List<namevaluepair><code></code></namevaluepair></li></ul><p>　　</p><h3 id="十一-org-apache-commons-codec-digest-DigestUtils"><a href="#十一-org-apache-commons-codec-digest-DigestUtils" class="headerlink" title="十一. org.apache.commons.codec.digest.DigestUtils"></a>十一. org.apache.commons.codec.digest.DigestUtils</h3><ul><li>md5Hex：MD5加密，返回32位字符串</li><li>sha1Hex：SHA-1加密</li><li>sha256Hex：SHA-256加密</li><li>sha512Hex：SHA-512加密</li><li>md5：MD5加密，返回16位字符串</li></ul><p>　　</p><h3 id="十二-org-apache-commons-collections-CollectionUtils"><a href="#十二-org-apache-commons-collections-CollectionUtils" class="headerlink" title="十二. org.apache.commons.collections.CollectionUtils"></a>十二. org.apache.commons.collections.CollectionUtils</h3><ul><li>isEmpty：是否为空</li><li>select：根据条件筛选集合元素</li><li>transform：根据指定方法处理集合元素，类似List的map()</li><li>filter：过滤元素，雷瑟List的filter()</li><li>find：基本和select一样</li><li>collect：和transform 差不多一样，但是返回新数组</li><li>forAllDo：调用每个元素的指定方法</li><li>isEqualCollection：判断两个集合是否一致</li></ul><p>　　</p><h3 id="十三-org-apache-commons-lang3-ArrayUtils"><a href="#十三-org-apache-commons-lang3-ArrayUtils" class="headerlink" title="十三. org.apache.commons.lang3.ArrayUtils"></a>十三. org.apache.commons.lang3.ArrayUtils</h3><ul><li>contains：是否包含某个字符串</li><li>addAll：添加整个数组</li><li>clone：克隆一个数组</li><li>isEmpty：是否空数组</li><li>add：向数组添加元素</li><li>subarray：截取数组</li><li>indexOf：查找某个元素的下标</li><li>isEquals：比较数组是否相等</li><li>toObject：基础类型数据数组转换为对应的Object数组</li></ul><p>　　</p><h3 id="十四-org-apache-commons-beanutils-PropertyUtils"><a href="#十四-org-apache-commons-beanutils-PropertyUtils" class="headerlink" title="十四. org.apache.commons.beanutils.PropertyUtils"></a>十四. org.apache.commons.beanutils.PropertyUtils</h3><ul><li>getProperty：获取对象属性值</li><li>setProperty：设置对象属性值</li><li>getPropertyDiscriptor：获取属性描述器</li><li>isReadable：检查属性是否可访问</li><li>copyProperties：复制属性值，从一个对象到另一个对象</li><li>getPropertyDiscriptors：获取所有属性描述器</li><li>isWriteable：检查属性是否可写</li><li>getPropertyType：获取对象属性类型</li></ul><p>　　</p><h3 id="十五-org-apache-commons-lang3-StringEscapeUtils"><a href="#十五-org-apache-commons-lang3-StringEscapeUtils" class="headerlink" title="十五. org.apache.commons.lang3.StringEscapeUtils"></a>十五. org.apache.commons.lang3.StringEscapeUtils</h3><ul><li>unescapeHtml4：转义html</li><li>escapeHtml4：反转义html</li><li>escapeXml：转义xml</li><li>unescapeXml：反转义xml</li><li>escapeJava：转义unicode编码</li><li>escapeEcmaScript：转义EcmaScript字符</li><li>unescapeJava：反转义unicode编码</li><li>escapeJson：转义json字符</li><li>escapeXml10：转义Xml10</li></ul><p>这个现在已经废弃了，建议使用commons-text包里面的方法。</p><p>　　</p><h3 id="十六-org-apache-commons-beanutils-BeanUtils"><a href="#十六-org-apache-commons-beanutils-BeanUtils" class="headerlink" title="十六. org.apache.commons.beanutils.BeanUtils"></a>十六. org.apache.commons.beanutils.BeanUtils</h3><ul><li>copyPeoperties：复制属性值，从一个对象到另一个对象</li><li>getProperty：获取对象属性值</li><li>setProperty：设置对象属性值</li><li>populate：根据Map给属性复制</li><li>copyPeoperty：复制单个值，从一个对象到另一个对象</li><li>cloneBean：克隆bean实例</li></ul><p>　　现在你只要了解了以上16种最流行的工具类方法，你就不必要再自己写工具类了，不必重复造轮子。大部分工具类方法通过其名字就能明白其用途，如果不清楚的，可以看下别人是怎么用的，或者去网上查询其用法。</p><p>　　另外，根据阿里开发手册，工具类所在的包名如果要使用”util”则不能带”s”，而且工具类要命名为 <code>XxxUtils</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://juejin.im/post/5d4a25b351882505c105cc6e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;排名前16的Java工具类&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Lambda表达式有何用处？如何使用？</title>
    <link href="https://mlone.top/2019/09/21/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9C%89%E4%BD%95%E7%94%A8%E5%A4%84%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F/"/>
    <id>https://mlone.top/2019/09/21/Lambda表达式有何用处？如何使用？/</id>
    <published>2019-09-21T12:38:40.000Z</published>
    <updated>2019-09-21T13:21:54.233Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="https://www.zhihu.com/question/20125256/answer/324121308" target="_blank" rel="noopener">https://www.zhihu.com/question/20125256/answer/324121308</a><br><a id="more"></a></p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt></p><h3 id="什么是Lambda"><a href="#什么是Lambda" class="headerlink" title="什么是Lambda?"></a>什么是Lambda?</h3><p>　　我们知道，对于一个Java变量，我们可以赋给其一个<strong>“值”</strong>。<br>　　<img src="/blogImg/2019/9/21/3-1.png" alt></p><p>　　如果你想把<strong>“一块代码”</strong>赋给一个Java变量，应该怎么做呢？</p><p>　　比如，我想把右边那块代码，赋给一个叫做aBlockOfCode的Java变量：<br>　　<img src="/blogImg/2019/9/21/3-2.png" alt></p><p>　　在Java 8之前，这个是做不到的。但是Java 8问世之后，利用Lambda特性，就可以做到了。<br>　　<img src="/blogImg/2019/9/21/3-3.png" alt></p><p>　　当然，这个并不是一个很简洁的写法。所以，为了使这个赋值操作更加elegant, 我们可以移除一些没用的声明。<br>　　<img src="/blogImg/2019/9/21/3-4.png" alt></p><p>　　这样，我们就成功的非常优雅的把“一块代码”赋给了一个变量。<strong>而“这块代码”，或者说“这个被赋给一个变量的函数”，就是一个Lambda表达式</strong>。</p><blockquote><p>但是这里仍然有一个问题，就是变量aBlockOfCode的类型应该是什么？</p></blockquote><p>　　在Java 8里面，<strong>所有的Lambda的类型都是一个接口，而Lambda表达式本身，也就是”那段代码“，需要是这个接口的实现。</strong>这是我认为理解Lambda的一个关键所在，简而言之就是，<strong>Lambda表达式本身就是一个接口的实现</strong>。直接这样说可能还是有点让人困扰，我们继续看看例子。我们给上面的aBlockOfCode加上一个类型：<br>　　<img src="/blogImg/2019/9/21/3-5.png" alt></p><p>　　这种只有<strong>一个接口函数需要被实现的接口类型，我们叫它”函数式接口“。</strong>为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成”非函数接口”，我们可以在这个上面加上一个声明@FunctionalInterface, 这样别人就无法在里面添加新的接口函数了：<br>　　<img src="/blogImg/2019/9/21/3-6.png" alt></p><p>　　这样，我们就得到了一个完整的Lambda表达式声明：<br>　　<img src="/blogImg/2019/9/21/3-7.png" alt></p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt></p><h3 id="Lambda表达式有什么作用"><a href="#Lambda表达式有什么作用" class="headerlink" title="Lambda表达式有什么作用?"></a>Lambda表达式有什么作用?</h3><p>　　<strong>最直观的作用就是使得代码变得异常简洁。</strong></p><p>　　我们可以对比一下Lambda表达式和传统的Java对同一个接口的实现：<br>　　<img src="/blogImg/2019/9/21/3-8.png" alt></p><p>　　这两种写法本质上是等价的。但是显然，Java 8中的写法更加优雅简洁。并且，由于Lambda可以直接赋值给一个变量，<strong>我们就可以直接把Lambda作为参数传给函数, 而传统的Java必须有明确的接口实现的定义，初始化才行：</strong><br>　　<img src="/blogImg/2019/9/21/3-9.png" alt></p><p>　　有些情况下，这个接口实现只需要用到一次。传统的Java 7必须要求你定义一个“污染环境”的接口实现MyInterfaceImpl，而相较之下Java 8的Lambda, 就显得干净很多。</p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt></p><h3 id="Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！"><a href="#Lambda结合FunctionalInterface-Lib-forEach-stream-，method-reference等新特性可以使代码变的更加简洁！" class="headerlink" title="Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！"></a>Lambda结合FunctionalInterface Lib, forEach, stream()，method reference等新特性可以使代码变的更加简洁！</h3><p>直接上例子，假设Person的定义和List<person>的值都给定：</person></p><p>　　<img src="/blogImg/2019/9/21/3-10.png" alt></p><p>　　现在需要你打印出guiltyPersons List里面所有LastName以”Z”开头的人的FirstName。</p><p>　　<strong>原生态Lambda写法</strong>：定义两个函数式接口，定义一个静态函数，调用静态函数并给参数赋值Lambda表达式。<br>　　<img src="/blogImg/2019/9/21/3-11.png" alt></p><blockquote><p><strong>这个代码实际上已经比较简洁了，但是我们还可以更简洁么？</strong></p></blockquote><p>　　当然可以。在Java 8中有一个函数式接口的包，里面定义了大量可能用到的函数式接口（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">java.util.function (Java Platform SE 8 )</a>）。所以，我们在这里压根都不需要定义NameChecker和Executor这两个函数式接口，直接用Java 8函数式接口包里的Predicate<t>和Consumer<t>就可以了——因为他们这一对的接口定义和NameChecker/Executor其实是一样的。<br>　　<img src="/blogImg/2019/9/21/3-12.png" alt></t></t></p><p><strong>第一步简化 - 利用函数式接口包：</strong><br>　　<img src="/blogImg/2019/9/21/3-13.png" alt></p><p>　　静态函数里面的for each循环其实是非常碍眼的。这里可以利用Iterable自带的forEach()来替代。forEach()本身可以接受一个Consumer<t> 参数。</t></p><p><strong>第二步简化 - 用Iterable.forEach()取代foreach loop：</strong><br>　　<img src="/blogImg/2019/9/21/3-14.png" alt></p><p>　　**由于静态函数其实只是对List进行了一通操作，这里我们可以甩掉静态函数，直接使用stream()特性来完成。stream()的几个方法都是接受Predicate<t>，Consumer<t>等参数的（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">java.util.stream (Java Platform SE 8 )</a>）。你理解了上面的内容，stream()这里就非常好理解了，并不需要多做解释。</t></t></p><p><strong>第三步简化 - 利用stream()替代静态函数：</strong><br>　　<img src="/blogImg/2019/9/21/3-15.png" alt></p><p>　　对比最开始的Lambda写法，这里已经非常非常简洁了。但是如果，我们的要求变一下，变成print这个人的全部信息，及p -&gt; System.out.println(p); 那么还可以利用Method reference来继续简化。所谓Method reference, 就是用已经写好的别的Object/Class的method来代替Lambda expression。格式如下：<br>　　<img src="/blogImg/2019/9/21/3-16.png" alt></p><p><strong>第四步简化 - 如果是println(p)，则可以利用Method reference代替forEach中的Lambda表达式：</strong><br>　　<img src="/blogImg/2019/9/21/3-17.png" alt></p><p>　　这基本上就是能写的最简洁的版本了。</p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt></p><h3 id="Lambda配合Optional可以使Java对于null的处理变的异常优雅"><a href="#Lambda配合Optional可以使Java对于null的处理变的异常优雅" class="headerlink" title="Lambda配合Optional可以使Java对于null的处理变的异常优雅"></a>Lambda配合Optional<t>可以使Java对于null的处理变的异常优雅</t></h3><p>　　这里假设我们有一个person object，以及一个person object的Optional wrapper:<br>　　<img src="/blogImg/2019/9/21/3-18.png" alt></p><p>　　Optional<t>如果不结合Lambda使用的话，并不能使原来繁琐的null check变的简单。<br>　　<img src="/blogImg/2019/9/21/3-19.png" alt></t></p><p>　　<strong>只有当Optional<t>结合Lambda一起使用的时候，才能发挥出其真正的威力！</t></strong></p><p>　　我们现在就来对比一下下面四种常见的null处理中，Java 8的Lambda+Optional<t>和传统Java两者之间对于null的处理差异。</t></p><p><strong>情况一 - 存在则开干</strong><br>　　<img src="/blogImg/2019/9/21/3-20.png" alt></p><p><strong>情况二 - 存在则返回，无则返回屁</strong><br>　　<img src="/blogImg/2019/9/21/3-21.png" alt></p><p><strong>情况三 - 存在则返回，无则由函数产生</strong><br>　　<img src="/blogImg/2019/9/21/3-22.png" alt></p><p><strong>情况四 - 夺命连环null检查</strong><br>　　<img src="/blogImg/2019/9/21/3-23.png" alt></p><p>　　由上述四种情况可以清楚地看到，Optional<t>+Lambda可以让我们少写很多ifElse块。尤其是对于情况四那种夺命连环null检查，传统java的写法显得冗长难懂，而新的Optional<t>+Lambda则清新脱俗，清楚简洁。</t></t></p><p>　　<img src="/blogImg/2019/9/21/3-24.png" alt><br>　　关于Java的Lambda, 还有东西需要讨论和学习。比如如何handle lambda exception，如何利用Lambda的特性来进行parallel processing等。总之，我只是一如既往地介绍个大概，让你大概知道，哦！原来是这样子就OK了。网上关于Lambda有很多相关的教程，多看多练。假以时日，必定有所精益。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://www.zhihu.com/question/20125256/answer/324121308&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/20125256/answer/324121308&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题|多线程篇(一)</title>
    <link href="https://mlone.top/2019/09/21/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87-%E4%B8%80/"/>
    <id>https://mlone.top/2019/09/21/面试题-多线程篇-一/</id>
    <published>2019-09-21T09:28:47.000Z</published>
    <updated>2019-09-21T10:08:51.944Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;mid=2247483976&amp;idx=1&amp;sn=cc3fef354be2f4db951ab48eb30c9fd6&amp;chksm=ec294261db5ecb77f2b52a5c007cfc46878fdf161eeae7817259ee83d41c50a0567c988bf45e&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568038989685&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">每日3分钟技术干货 | 面试题+答案 |多线程篇(一)</a><br><a id="more"></a></p><p>　　</p><h4 id="1-为什么要使用线程池"><a href="#1-为什么要使用线程池" class="headerlink" title="1. 为什么要使用线程池"></a><strong>1. 为什么要使用线程池</strong></h4><p>　　避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><p>　　</p><h4 id="2-java中如何获取到线程dump文件"><a href="#2-java中如何获取到线程dump文件" class="headerlink" title="2. java中如何获取到线程dump文件"></a><strong>2. java中如何获取到线程dump文件</strong></h4><p>　　死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>　　另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈。</p><p>　　</p><h4 id="3-怎么检测一个线程是否持有对象监视器"><a href="#3-怎么检测一个线程是否持有对象监视器" class="headerlink" title="3. 怎么检测一个线程是否持有对象监视器"></a><strong>3. 怎么检测一个线程是否持有对象监视器</strong></h4><p>　　我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p><p>　　</p><h4 id="4-synchronized和ReentrantLock的区别"><a href="#4-synchronized和ReentrantLock的区别" class="headerlink" title="4. synchronized和ReentrantLock的区别"></a><strong>4. synchronized和ReentrantLock的区别</strong></h4><p>　　synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>　　另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><p>　　</p><h4 id="5-ConcurrentHashMap的并发度是什么"><a href="#5-ConcurrentHashMap的并发度是什么" class="headerlink" title="5. ConcurrentHashMap的并发度是什么"></a><strong>5. ConcurrentHashMap的并发度是什么</strong></h4><p>　　ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p>　　</p><h4 id="6-ReentrantLock是什么"><a href="#6-ReentrantLock是什么" class="headerlink" title="6. ReentrantLock是什么"></a><strong>6. ReentrantLock是什么</strong></h4><p>　　首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>　　因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p>　　</p><h4 id="7-FutureTask是什么"><a href="#7-FutureTask是什么" class="headerlink" title="7. FutureTask是什么"></a><strong>7. FutureTask是什么</strong></h4><p>　　这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p>　　</p><h4 id="8-Linux环境下如何查找哪个线程使用CPU最长"><a href="#8-Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="8. Linux环境下如何查找哪个线程使用CPU最长"></a><strong>8. Linux环境下如何查找哪个线程使用CPU最长</strong></h4><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><ul><li><p>（1）获取项目的pid，<code>jps</code>或者<code>ps -ef | grep java</code>，这个前面有讲过</p></li><li><p>（2）<code>top -H -p pid</code>，顺序不能改变</p></li></ul><p>　　这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>　　使用<code>top -H -p pid</code>+<code>jps pid</code>可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>　　最后提一点，<code>top -H -p pid</code>打出来的LWP是十进制的，<code>jps pid</code>打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><p>　　</p><h4 id="9-一个线程如果出现了运行时异常会怎么样"><a href="#9-一个线程如果出现了运行时异常会怎么样" class="headerlink" title="9. 一个线程如果出现了运行时异常会怎么样"></a><strong>9. 一个线程如果出现了运行时异常会怎么样</strong></h4><p>　　如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><p>　　</p><h4 id="10-如何在两个线程之间共享数据"><a href="#10-如何在两个线程之间共享数据" class="headerlink" title="10. 如何在两个线程之间共享数据"></a><strong>10. 如何在两个线程之间共享数据</strong></h4><p>　　通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><p>　　</p><h4 id="11-线程和进程的区别？"><a href="#11-线程和进程的区别？" class="headerlink" title="11.  线程和进程的区别？"></a><strong>11.  线程和进程的区别？</strong></h4><p>　　一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p><p>　　</p><h4 id="12-守护线程是什么？"><a href="#12-守护线程是什么？" class="headerlink" title="12. 守护线程是什么？"></a><strong>12. 守护线程是什么？</strong></h4><p>　　守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><p>　　</p><h4 id="13-创建线程有哪几种方式？"><a href="#13-创建线程有哪几种方式？" class="headerlink" title="13. 创建线程有哪几种方式？"></a><strong>13. 创建线程有哪几种方式？</strong></h4><p>创建线程有三种方式：</p><ul><li>继承 Thread 重新 run 方法；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口。</li></ul><p>　　</p><h4 id="14-说一下-runnable-和-callable-有什么区别？"><a href="#14-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="14. 说一下 runnable 和 callable 有什么区别？"></a><strong>14. 说一下 runnable 和 callable 有什么区别？</strong></h4><p>　　runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p><p>　　</p><h4 id="15-线程有哪些状态？"><a href="#15-线程有哪些状态？" class="headerlink" title="15. 线程有哪些状态？"></a><strong>15. 线程有哪些状态？</strong></h4><blockquote><p>线程的状态：</p></blockquote><ul><li><code>NEW</code> 尚未启动</li><li><code>RUNNABLE</code> 正在执行中</li><li><code>BLOCKED</code> 阻塞的（被同步锁或者IO锁阻塞）</li><li><code>WAITING</code> 永久等待状态</li><li><code>TIMED_WAITING</code> 等待指定的时间重新被唤醒的状态</li><li><code>TERMINATED</code> 执行完成</li></ul><p>　　</p><h4 id="16-sleep-和-wait-有什么区别？"><a href="#16-sleep-和-wait-有什么区别？" class="headerlink" title="16. sleep() 和 wait() 有什么区别？"></a><strong>16. sleep() 和 wait() 有什么区别？</strong></h4><ul><li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li><li>释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</li></ul><p>　　</p><h4 id="17-notify-和-notifyAll-有什么区别？"><a href="#17-notify-和-notifyAll-有什么区别？" class="headerlink" title="17. notify()和 notifyAll()有什么区别？"></a><strong>17. notify()和 notifyAll()有什么区别？</strong></h4><ul><li>notifyAll()会唤醒所有的线程，而notify()只会唤醒一个线程。</li><li>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。<br>　　而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</li></ul><p>　　</p><h4 id="18-线程的-run-和-start-有什么区别？"><a href="#18-线程的-run-和-start-有什么区别？" class="headerlink" title="18. 线程的 run() 和 start() 有什么区别？"></a><strong>18. 线程的 run() 和 start() 有什么区别？</strong></h4><p>　　start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><p>　　</p><h4 id="19-创建线程池有哪几种方式？"><a href="#19-创建线程池有哪几种方式？" class="headerlink" title="19. 创建线程池有哪几种方式？"></a><strong>19. 创建线程池有哪几种方式？</strong></h4><p>线程池创建有七种方式，最核心的是最后一种：</p><ul><li><p><code>newSingleThreadExecutor()</code>：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</p></li><li><p><code>newCachedThreadPool()</code>：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</p></li><li><p><code>newFixedThreadPool(int nThreads)</code>：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</p></li><li><p><code>newSingleThreadScheduledExecutor()</code>：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</p></li><li><p><code>newScheduledThreadPool(int corePoolSize)</code>：和<code>newSingleThreadScheduledExecutor()</code>类似，创建的是个 <code>ScheduledExecutorService</code>，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</p></li><li><p><code>newWorkStealingPool(int parallelism)</code>：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</p></li><li><p><code>ThreadPoolExecutor()</code>：是最原始的线程池创建，上面1-3创建方式都是对<code>ThreadPoolExecutor</code>的封装。</p></li></ul><p>　　</p><h4 id="20-线程池都有哪些状态？"><a href="#20-线程池都有哪些状态？" class="headerlink" title="20. 线程池都有哪些状态？"></a><strong>20. 线程池都有哪些状态？</strong></h4><ul><li><code>RUNNING</code>：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li><code>SHUTDOWN</code>：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li><code>STOP</code>：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li><code>TIDYING</code>：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li><code>TERMINATED</code>：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><p>　　</p><h4 id="21-线程池中-submit-和-execute-方法有什么区别？"><a href="#21-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="21. 线程池中 submit() 和 execute() 方法有什么区别？"></a><strong>21. 线程池中 submit() 和 execute() 方法有什么区别？</strong></h4><ul><li><code>execute()</code>：只能执行 Runnable 类型的任务。</li><li><code>submit()</code>：可以执行 Runnable 和 Callable 类型的任务。<br>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</li></ul><p>　　</p><h4 id="22-在-Java-程序中怎么保证多线程的运行安全？"><a href="#22-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="22. 在 Java 程序中怎么保证多线程的运行安全？"></a><strong>22. 在 Java 程序中怎么保证多线程的运行安全？</strong></h4><ul><li>方法一：使用安全类，比如 Java. util. concurrent 下的类。</li><li>方法二：使用自动锁 synchronized。</li><li>方法三：使用手动锁 Lock。</li></ul><p>手动锁 Java 示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   System. out. println(<span class="string">"获得锁"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   System. out. println(<span class="string">"释放锁"</span>);</span><br><span class="line">   lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　</p><h4 id="23-多线程中-synchronized-锁升级的原理是什么？"><a href="#23-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="23. 多线程中 synchronized 锁升级的原理是什么？"></a><strong>23. 多线程中 synchronized 锁升级的原理是什么？</strong></h4><p>　　<strong>synchronized锁升级原理：</strong>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>　　<strong>锁的升级的目的：</strong>锁升级是为了减低了锁带来的性能消耗。在Java6之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><p>　　</p><h4 id="24-什么是死锁？"><a href="#24-什么是死锁？" class="headerlink" title="24. 什么是死锁？"></a><strong>24. 什么是死锁？</strong></h4><p>　　当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><p>　　</p><h4 id="25-怎么防止死锁？"><a href="#25-怎么防止死锁？" class="headerlink" title="25. 怎么防止死锁？"></a><strong>25. 怎么防止死锁？</strong></h4><ul><li>尽量使用 <code>tryLock(long timeout, TimeUnit unit)</code>的方法<code>(ReentrantLock、ReentrantReadWriteLock)</code>，设置超时时间，超时可以退出防止死锁。</li><li>尽量使用 <code>Java.util.concurrent</code> 并发类代替自己手写锁。</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>尽量减少同步的代码块。</li></ul><p>　　</p><h4 id="26-ThreadLocal是什么？有哪些使用场景？"><a href="#26-ThreadLocal是什么？有哪些使用场景？" class="headerlink" title="26. ThreadLocal是什么？有哪些使用场景？"></a><strong>26. ThreadLocal是什么？有哪些使用场景？</strong></h4><p>　　ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>　　ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p><p>　　</p><h4 id="27-说一下-synchronized-底层实现原理？"><a href="#27-说一下-synchronized-底层实现原理？" class="headerlink" title="27. 说一下 synchronized 底层实现原理？"></a><strong>27. 说一下 synchronized 底层实现原理？</strong></h4><p>　　synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p><p>　　</p><h4 id="28-synchronized-和-volatile-的区别是什么？"><a href="#28-synchronized-和-volatile-的区别是什么？" class="headerlink" title="28. synchronized 和 volatile 的区别是什么？"></a><strong>28. synchronized 和 volatile 的区别是什么？</strong></h4><ul><li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li></ul><p>　　</p><h4 id="29-synchronized-和-Lock-有什么区别？"><a href="#29-synchronized-和-Lock-有什么区别？" class="headerlink" title="29. synchronized 和 Lock 有什么区别？"></a><strong>29. synchronized 和 Lock 有什么区别？</strong></h4><ul><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><p>　　</p><h4 id="30-synchronized-和-ReentrantLock-区别是什么？"><a href="#30-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="30. synchronized 和 ReentrantLock 区别是什么？"></a><strong>30. synchronized 和 ReentrantLock 区别是什么？</strong></h4><p>　　synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>主要区别如下：</p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ul><p>　　</p><h4 id="31-说一下-atomic-的原理？"><a href="#31-说一下-atomic-的原理？" class="headerlink" title="31. 说一下 atomic 的原理？"></a><strong>31. 说一下 atomic 的原理？</strong></h4><p>　　atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>　　</p><h4 id="32-线程类的构造方法，静态块是哪个线程调用的"><a href="#32-线程类的构造方法，静态块是哪个线程调用的" class="headerlink" title="32.线程类的构造方法，静态块是哪个线程调用的"></a><strong>32.线程类的构造方法，静态块是哪个线程调用的</strong></h4><p>　　这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>　　如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><ul><li>1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</li><li>2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</li></ul><p>　　</p><h4 id="33-同步方法和同步块，哪个是更好的选择"><a href="#33-同步方法和同步块，哪个是更好的选择" class="headerlink" title="33. 同步方法和同步块，哪个是更好的选择"></a><strong>33. 同步方法和同步块，哪个是更好的选择</strong></h4><p>　　同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：<strong>同步的范围越小越好。</strong></p><p>　　借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p>　　</p><h4 id="34-高并发、任务执行时间短的业务怎样使用线程池？-并发不高、任务执行时间长的业务怎样使用线程池？-并发高、业务执行时间长的业务怎样使用线程池？"><a href="#34-高并发、任务执行时间短的业务怎样使用线程池？-并发不高、任务执行时间长的业务怎样使用线程池？-并发高、业务执行时间长的业务怎样使用线程池？" class="headerlink" title="34. 高并发、任务执行时间短的业务怎样使用线程池？**并发不高、任务执行时间长的业务怎样使用线程池？**并发高、业务执行时间长的业务怎样使用线程池？"></a><strong>34. 高并发、任务执行时间短的业务怎样使用线程池？**</strong>并发不高、任务执行时间长的业务怎样使用线程池？<strong>**并发高、业务执行时间长的业务怎样使用线程池？</strong></h4><p>　　这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><ul><li><p>1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p></li><li><p>2）并发不高、任务执行时间长的业务要区分开看：</p></li><li><ul><li>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</li></ul></li><li><ul><li>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li></ul></li><li><ul><li>c）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考其他有关线程池的文章。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;amp;mid=2247483976&amp;amp;idx=1&amp;amp;sn=cc3fef354be2f4db951ab48eb30c9fd6&amp;amp;chksm=ec294261db5ecb77f2b52a5c007cfc46878fdf161eeae7817259ee83d41c50a0567c988bf45e&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1568038989685&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每日3分钟技术干货 | 面试题+答案 |多线程篇(一)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题|MyBatis篇(一)</title>
    <link href="https://mlone.top/2019/09/21/%E9%9D%A2%E8%AF%95%E9%A2%98-MyBatis%E7%AF%87-%E4%B8%80/"/>
    <id>https://mlone.top/2019/09/21/面试题-MyBatis篇-一/</id>
    <published>2019-09-21T06:57:11.000Z</published>
    <updated>2019-09-21T07:13:34.348Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;mid=2247483985&amp;idx=2&amp;sn=f39c83232616fd3f1f41872cf5cd821b&amp;chksm=ec294278db5ecb6ea40b263c482699aa8fe8fd37e2bd052cc5b7833e718d2a6e1173110089fc&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568038876476&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">每日3分钟技术干货 | 面试题+答案 | MyBatis篇(一)</a><br><a id="more"></a></p><h4 id="1-MyBatis-中-和-的区别是什么？"><a href="#1-MyBatis-中-和-的区别是什么？" class="headerlink" title="1. MyBatis 中 #{}和 ${}的区别是什么？"></a><strong>1. MyBatis 中 #{}和 ${}的区别是什么？</strong></h4><p>　　#{}是预编译处理，${}是字符替换。在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p><p>　　</p><h4 id="2-MyBatis-有几种分页方式？"><a href="#2-MyBatis-有几种分页方式？" class="headerlink" title="2. MyBatis 有几种分页方式？"></a><strong>2. MyBatis 有几种分页方式？</strong></h4><ul><li><p><strong>分页方式：</strong>逻辑分页和物理分页。</p></li><li><p><strong>逻辑分页：</strong>使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p></li><li><p><strong>物理分页：</strong>自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p></li></ul><p>　　</p><h4 id="3-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#3-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="3. RowBounds 是一次性查询全部结果吗？为什么？"></a><strong>3. RowBounds 是一次性查询全部结果吗？为什么？</strong></h4><p>　　RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p><p>　　</p><h4 id="4-MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#4-MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="4. MyBatis 逻辑分页和物理分页的区别是什么？"></a><strong>4. MyBatis 逻辑分页和物理分页的区别是什么？</strong></h4><p>　　逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</p><p>　　物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p><p>　　</p><h4 id="5-MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#5-MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="5. MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a><strong>5. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</strong></h4><p>　　MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p><p>　　延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p><p>　　</p><h4 id="6-说一下-MyBatis-的一级缓存和二级缓存？"><a href="#6-说一下-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="6. 说一下 MyBatis 的一级缓存和二级缓存？"></a><strong>6. 说一下 MyBatis 的一级缓存和二级缓存？</strong></h4><p><strong>一级缓存：</strong>基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 　　SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</p><p><strong>二级缓存：</strong>也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</p><blockquote><p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p></blockquote><p><strong>缓存更新机制：</strong>当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><p>　　</p><h4 id="7-MyBatis-和-hibernate-的区别有哪些？"><a href="#7-MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="7. MyBatis 和 hibernate 的区别有哪些？"></a><strong>7. MyBatis 和 hibernate 的区别有哪些？</strong></h4><ul><li><p><strong>灵活性：</strong>MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</p></li><li><p><strong>可移植性：</strong>MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</p></li><li><p><strong>学习和使用门槛：</strong>MyBatis 入门比较简单，使用门槛也更低。</p></li><li><p><strong>二级缓存：</strong>hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p></li></ul><p>　　</p><h4 id="8-MyBatis-有哪些执行器（Executor）？"><a href="#8-MyBatis-有哪些执行器（Executor）？" class="headerlink" title="8. MyBatis 有哪些执行器（Executor）？"></a><strong>8. MyBatis 有哪些执行器（Executor）？</strong></h4><p>MyBatis 有三种基本的Executor执行器：</p><ul><li><p><strong>SimpleExecutor：</strong>每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</p></li><li><p><strong>ReuseExecutor：</strong>执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</p></li><li><p><strong>BatchExecutor：</strong>执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</p></li></ul><p>　　</p><h4 id="9-MyBatis-分页插件的实现原理是什么？"><a href="#9-MyBatis-分页插件的实现原理是什么？" class="headerlink" title="9. MyBatis 分页插件的实现原理是什么？"></a><strong>9. MyBatis 分页插件的实现原理是什么？</strong></h4><p>　　分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><p>　　</p><h4 id="10-MyBatis-如何编写一个自定义插件？"><a href="#10-MyBatis-如何编写一个自定义插件？" class="headerlink" title="10. MyBatis 如何编写一个自定义插件？"></a><strong>10. MyBatis 如何编写一个自定义插件？</strong></h4><p><strong>自定义插件实现原理</strong></p><p>　　MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p><ul><li>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</li><li>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；</li><li>ParameterHandler：拦截参数的处理；</li><li>ResultSetHandler：拦截结果集的处理。</li></ul><p>　　<br><strong>自定义插件实现关键</strong><br>　　MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</li><li>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；</li><li>intercept 方法就是要进行拦截的时候要执行的方法。</li></ul><p>　　<br><strong>自定义插件实现示例</strong><br>　　官方插件实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor. <span class="class"><span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>,</span><br><span class="line">args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">      Object target = invocation. getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line"></span><br><span class="line">      Method method = invocation. getMethod(); <span class="comment">//代理方法</span></span><br><span class="line"></span><br><span class="line">      Object[] args = invocation. getArgs(); <span class="comment">//方法参数</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// do something . . . . . .  方法拦截前执行代码块</span></span><br><span class="line"></span><br><span class="line">      Object result = invocation. proceed();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// do something . . . . . . . 方法拦截后执行代码块</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Plugin. wrap(target, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;amp;mid=2247483985&amp;amp;idx=2&amp;amp;sn=f39c83232616fd3f1f41872cf5cd821b&amp;amp;chksm=ec294278db5ecb6ea40b263c482699aa8fe8fd37e2bd052cc5b7833e718d2a6e1173110089fc&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1568038876476&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每日3分钟技术干货 | 面试题+答案 | MyBatis篇(一)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
      <category term="mybatis" scheme="https://mlone.top/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>synchronized与volatile</title>
    <link href="https://mlone.top/2019/09/21/synchronized%E4%B8%8Evolatile/"/>
    <id>https://mlone.top/2019/09/21/synchronized与volatile/</id>
    <published>2019-09-21T06:35:43.000Z</published>
    <updated>2019-09-21T06:54:45.479Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650124577&amp;idx=1&amp;sn=4f471855e58d2ded0c9044a3a7e9c698&amp;chksm=f36bac00c41c25166ec3ca43e5811984e4977e8cbbd5f14947fb4d0bc9c67b4a80c726699ff2&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1566351934675&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">既生synchronized，何生volatile</a><br><a id="more"></a></p><blockquote><p>之前的文章中我们介绍过了两个在Java并发编程中比较重要的两个关键字：synchronized和volatile</p></blockquote><p>简单回顾一下相关内容：</p><p>1、Java语言为了解决并发编程中存在的原子性、可见性和有序性问题，提供了一系列和并发处理相关的关键字，比如synchronized、volatile、final、concurren包等。(<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121599&amp;idx=1&amp;sn=42b2cfabfb3057ac6c09026a8b9656cd&amp;chksm=f36bb85ec41c31489e461a53e78f2959f0224c87c312724f420265b70e67e4efdae2331155aa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">再有人问你Java内存模型是什么，就把这篇文章发给他</a>)</p><p>2、synchronized通过加锁的方式，使得其在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121805&amp;idx=1&amp;sn=8aea8c329a018c82a7ebfe80ec604226&amp;chksm=f36bbb6cc41c327acc23d3d7cdf0b785e318d8e970d564ba9ce8b28a1ae6b41499d351497af3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">再有人问你synchronized是什么，就把这篇文章发给他</a>）</p><p>3、volatile通过在volatile变量的操作前后插入内存屏障的方式，保证了变量在并发场景下的可见性和有序性。（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121952&amp;idx=1&amp;sn=5fd25ca48e2005379bffae1608027b59&amp;chksm=f36bbbc1c41c32d781ca24cfa3373660516a50f8b89772260ea247bfb89a0e9a215317e509a4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">再有人问你volatile是什么，把这篇文章也发给他</a>）</p><p>4、volatile关键字是无法保证原子性的，而synchronized通过monitorenter和monitorexit两个指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，即可保证不会出现CPU时间片在多个线程间切换，即可保证原子性。（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121739&amp;idx=1&amp;sn=7b60f56d408457f34d5fc0b200ed32bb&amp;chksm=f36bbb2ac41c323c000e2a51e76c627d17f4759d3a54c520a073506ef3de0c46e196f11cd287&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Java的并发编程中的多线程问题到底是怎么回事儿</a>）<br>　　<br>　　那么，我们知道，synchronized和volatile两个关键字是Java并发编程中经常用到的两个关键字，而且，通过前面的回顾，我们知道synchronized可以保证并发编程中不会出现原子性、可见性和有序性问题，而volatile只能保证可见性和有序性，那么，<strong>既生synchronized、何生volatile？</strong></p><p>　　接下来，本文就来论述一下，为什么Java中已经有了synchronized关键字，还要提供volatile关键字。</p><h2 id="1-synchronized的问题"><a href="#1-synchronized的问题" class="headerlink" title="1. synchronized的问题"></a>1. synchronized的问题</h2><p>我们都知道synchronized其实是一种加锁机制，那么既然是锁，天然就具备以下几个缺点：</p><h3 id="1、有性能损耗"><a href="#1、有性能损耗" class="headerlink" title="1、有性能损耗"></a><strong>1、有性能损耗</strong></h3><p>　　虽然在JDK 1.6中对synchronized做了很多优化，如如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121186&amp;idx=1&amp;sn=248d37be27d3bbeb103464b2a96a0ae4&amp;chksm=f36bbec3c41c37d59277ac8539a616b65ec44637f341325056e98323e8780e09c6e4f7cc7a85&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解多线程（五）—— Java虚拟机的锁优化技术</a>），但是他毕竟还是一种锁。</p><p>　　以上这几种优化，都是尽量想办法避免对Monitor（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120784&amp;idx=1&amp;sn=3436c978f0d7ab3bb672d03689518902&amp;chksm=f36bbf71c41c36672a3a6a7edebe0b913f2f5cf33d75d594d228f086ec7bdb9e253ab0beeae4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解多线程（四）—— Moniter的实现原理</a>）进行加锁，但是，并不是所有情况都可以优化的，况且就算是经过优化，优化的过程也是有一定的耗时的。</p><p>　　所以，无论是使用同步方法还是同步代码块，在同步操作之前还是要进行加锁，同步操作之后需要进行解锁，这个加锁、解锁的过程是要有性能损耗的。</p><p>　　关于二者的性能对比，由于虚拟机对锁实行的许多消除和优化，使得我们很难量化这两者之间的性能差距，但是我们可以确定的一个基本原则是：volatile变量的读操作的性能小号普通变量几乎无差别，但是写操作由于需要插入内存屏障所以会慢一些，即便如此，volatile在大多数场景下也比锁的开销要低。</p><h3 id="2、产生阻塞"><a href="#2、产生阻塞" class="headerlink" title="2、产生阻塞"></a><strong>2、产生阻塞</strong></h3><p>　　我们在<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120537&amp;idx=1&amp;sn=f56201217c0ca6fde45ee12965b56296&amp;chksm=f36bbc78c41c356ee363367addcdc0b311afb2f9df86a7ee20d21348b3332fd64f273d6028ca&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>中介绍过关于synchronize的实现原理，无论是同步方法还是同步代码块，无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的。</p><p>　　基于Monitor对象，当多个线程同时访问一段同步代码时，首先会进入Entry Set，当有一个线程获取到对象的锁之后，才能进行The Owner区域，其他线程还会继续在Entry Set等待。并且当某个线程调用了wait方法后，会释放锁并进入Wait Set等待。<br>　　<img src="/blogImg/2019/9/21/2-1.png" alt></p><p>　　<span style="color: orange;">所以，synchronize实现的锁本质上是一种阻塞锁，也就是说多个线程要排队访问同一个共享对象。</span></p><p>　　而volatile是Java虚拟机提供的一种轻量级同步机制，他是基于内存屏障实现的。说到底，他并不是锁，所以他不会有synchronized带来的阻塞和性能损耗的问题。</p><h2 id="2-volatile的附加功能"><a href="#2-volatile的附加功能" class="headerlink" title="2. volatile的附加功能"></a>2. volatile的附加功能</h2><p>　　除了前面我们提到的volatile比synchronized性能好以外，<span style="color: orange;">volatile其实还有一个很好的附加功能，那就是禁止指令重排</span>。</p><p>　　我们先来举一个例子，看一下如果只使用synchronized而不使用volatile会发生什么问题，就拿我们比较熟悉的单例模式来看。</p><p>　　我们通过双重校验锁的方式实现一个单例，这里不使用volatile关键字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　以上代码，我们通过使用synchronized对Singleton.class进行加锁，可以保证同一时间只有一个线程可以执行到同步代码块中的内容，也就是说singleton = new Singleton()这个操作只会执行一次，这就是实现了一个单例。</p><p>　　<strong>但是，当我们在代码中使用上述单例对象的时候有可能发生空指针异常。这是一个比较诡异的情况。</strong></p><p>我们假设Thread1 和 Thread2两个线程同时请求Singleton.getSingleton方法的时候：<br>　　<img src="/blogImg/2019/9/21/2-2.png" alt></p><ul><li>Step1 ,Thread1执行到第8行，开始进行对象的初始化。</li><li>Step2 ,Thread2执行到第5行，判断singleton == null。 </li><li>Step3 ,Thread2经过判断发现singleton ！= null，所以执行第12行，返回singleton。 </li><li>Step4 ,Thread2拿到singleton对象之后，开始执行后续的操作，比如调用singleton.call()。</li></ul><p>　　以上过程，看上去并没有什么问题，但是，其实，在Step4，Thread2在调用singleton.call()的时候，是有可能抛出空指针异常的。</p><p>　　之所有会有NPE抛出，是因为在Step3，Thread2拿到的singleton对象并不是一个完整的对象。<br>　　<br><strong>什么叫做不完整对象，这个怎么理解呢？</strong></p><p>我们这里来先来看一下，<code>singleton = new Singleton();</code>这行代码到底做了什么事情，大致过程如下：</p><ul><li>1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。 </li><li>2、检查符号引用代表的类是否被加载、解析、初始化过。 </li><li>3、虚拟机为对象分配内存。 </li><li>4、虚拟机将分配到的内存空间都初始化为零值。 </li><li>5、虚拟机对对象进行必要的设置。 </li><li>6、执行方法，成员变量进行初始化。</li><li>7、将对象的引用指向这个内存区域。</li></ul><p>　　<br>我们把这个过程简化一下，简化成3个步骤：</p><ul><li>a、JVM为对象分配一块内存M </li><li>b、在内存M上为对象进行初始化 </li><li>c、将内存M的地址复制给singleton变量</li></ul><p>如下图：<br>　　<img src="/blogImg/2019/9/21/2-3.png" alt></p><p>　　因为将内存的地址赋值给singleton变量是最后一步，所以Thread1在这一步骤执行之前，Thread2在对singleton==null进行判断一直都是true的，那么他会一直阻塞，直到Thread1将这一步骤执行完。<br>　　<br>　　但是，问题就出在以上过程并不是一个原子操作，并且编译器可能会进行重排序，如果以上步骤被重排成：</p><ul><li>a、JVM为对象分配一块内存M </li><li>c、将内存的地址复制给singleton变量 </li><li>b、在内存M上为对象进行初始化</li></ul><p>如下图：<br>　　<img src="/blogImg/2019/9/21/2-4.png" alt></p><p>　　这样的话，Thread1会先执行内存分配，在执行变量赋值，最后执行对象的初始化，那么，也就是说，在Thread1还没有为对象进行初始化的时候，Thread2进来判断singleton==null就可能提前得到一个false，则会返回一个不完整的sigleton对象，因为他还未完成初始化操作。</p><p>　　这种情况一旦发生，我们拿到了一个不完整的singleton对象，当尝试使用这个对象的时候就极有可能发生NPE异常。<br>　　<br>　　那么，怎么解决这个问题呢？因为指令重排导致了这个问题，那就避免指令重排就行了。</p><p>　　所以，volatile就派上用场了，因为<span style="color: orange;">volatile可以避免指令重排</span>。只要将代码改成以下代码，就可以解决这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　对singleton使用volatile约束，保证他的初始化过程不会被指令重排。这样就可以保Thread2 要不然就是拿不到对象，要不然就是拿到一个完整的对象。</p><h2 id="3-synchronized的有序性保证呢？"><a href="#3-synchronized的有序性保证呢？" class="headerlink" title="3. synchronized的有序性保证呢？"></a>3. synchronized的有序性保证呢？</h2><p>　　看到这里可能有朋友会问了，说到底上面问题是发生了指令重排，其实还是个有序性的问题，<strong>不是说synchronized是可以保证有序性的么，这里为什么就不行了呢？</strong></p><p>　　首先，可以明确的一点是：<span style="color: orange;">synchronized是无法禁止指令重排和处理器优化的。</span>那么他是如何保证的有序性呢？</p><p>　　这就要再把有序性的概念扩展一下了。Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。</p><p>　　以上这句话也是《深入理解Java虚拟机》中的原句，但是怎么理解呢？周志明并没有详细的解释。这里我简单扩展一下，这其实和as-if-serial语义有关。</p><p>　　as-if-serial语义的意思指：不管怎么重排序，单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。</p><p>　　这里不对as-if-serial语义详细展开了，<span style="color: orange;">简单说就是，as-if-serial语义保证了单线程中，不管指令怎么重排，最终的执行结果是不能被改变的。</span></p><p>　　那么，我们回到刚刚那个双重校验锁的例子，站在单线程的角度，也就是只看Thread1的话，因为编译器会遵守as-if-serial语义，所以这种优化不会有任何问题，对于这个线程的执行结果也不会有任何影响。</p><p>　　但是，Thread1内部的指令重排却对Thread2产生了影响。</p><p>　　那么，我们可以说，<span style="color: orange;">synchronized保证的有序性是多个线程之间的有序性，即被加锁的内容要按照顺序被多个线程执行。但是其内部的同步代码还是会发生重排序，只不过由于编译器和处理器都遵循as-if-serial语义，所以我们可以认为这些重排序在单线程内部可忽略。</span></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文从两方面论述了volatile的重要性以及不可替代性：</p><p>　　<strong>一方面是因为synchronized是一种锁机制，存在阻塞问题和性能问题，而volatile并不是锁，所以不存在阻塞和性能问题。</strong></p><p>　　另外一方面，因为<strong>volatile借助了内存屏障来帮助其解决可见性和有序性问题，而内存屏障的使用还为其带来了一个禁止指令重排的附件功能，所以在有些场景中是可以避免发生指令重排的问题的。</strong></p><p>　　所以，在日后需要做并发控制的时候，如果不涉及到原子性的问题，可以优先考虑使用volatile关键字。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650124577&amp;amp;idx=1&amp;amp;sn=4f471855e58d2ded0c9044a3a7e9c698&amp;amp;chksm=f36bac00c41c25166ec3ca43e5811984e4977e8cbbd5f14947fb4d0bc9c67b4a80c726699ff2&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1566351934675&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;既生synchronized，何生volatile&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个TCP连接上面能发多少个HTTP请求</title>
    <link href="https://mlone.top/2019/09/21/%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E4%B8%8A%E9%9D%A2%E8%83%BD%E5%8F%91%E5%A4%9A%E5%B0%91%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82/"/>
    <id>https://mlone.top/2019/09/21/一个TCP连接上面能发多少个HTTP请求/</id>
    <published>2019-09-21T06:09:28.000Z</published>
    <updated>2019-09-21T06:31:03.589Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://zhuanlan.zhihu.com/p/61423830" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61423830</a><br><a id="more"></a></p><p>　　一道经典的面试题是从 URL 在浏览器被被输入到页面展现的过程中发生了什么，大多数回答都是说请求响应之后 DOM 怎么被构建，被绘制出来。但是你有没有想过，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</p><p>要搞懂这个问题，我们需要先解决下面五个问题：</p><ol><li>现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</li><li>一个 TCP 连接可以对应几个 HTTP 请求？</li><li>一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</li><li>为什么有的时候刷新页面不需要重新建立 SSL 连接？</li><li>浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</li></ol><p>　　<strong>先来谈谈第一个问题：现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</strong></p><p>　　在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 <code>Connection: keep-alive</code> 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是我短时间内两次访问 <a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a> 的时间统计：<br>　　<img src="/blogImg/2019/9/21/1-1.png" alt><br>　　头一次访问，有初始化连接和 SSL 开销<br>　　<img src="/blogImg/2019/9/21/1-2.png" alt><br>　　初始化连接和 SSL 开销消失了，说明使用的是同一个 TCP 连接<br>　　<br>　　持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。</p><p>　　所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。（详细文档见下面的链接）</p><p>　　<a href="https://tools.ietf.org/html/rfc2616#section-8.1" target="_blank" rel="noopener">Hypertext Transfer Protocol – HTTP/1.1</a><br>　　<br><strong>第二个问题：一个 TCP 连接可以对应几个 HTTP 请求？</strong></p><p>　　了解了第一个问题之后，其实这个问题已经有了答案，如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。<br>　　<br><strong>第三个问题：一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</strong></p><p>　　HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。</p><p>　　虽然 HTTP/1.1 规范中规定了 <a href="https://tools.ietf.org/html/rfc2616#section-8.1.2.2" target="_blank" rel="noopener">Pipelining</a> 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。</p><p>先来看一下 Pipelining 是什么，RFC 2616 中规定了：</p><blockquote><p>A client that supports persistent connections MAY “pipeline” its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received.<br>一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。</p></blockquote><p>　　至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 <code>GET /query?q=A</code> 和 <code>GET /query?q=B</code>，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。<br>　　<br>Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：</p><ul><li>一些代理服务器不能正确的处理 HTTP Pipelining。</li><li>正确的流水线实现是复杂的。详见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x#HTTP_%E6%B5%81%E6%B0%B4%E7%BA%BF" target="_blank" rel="noopener">HTTP/1.x的连接管理</a></li><li>Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。</li></ul><p>　　所以现代浏览器默认是不开启 HTTP Pipelining 的。<br>　　<br>　　但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果：<br>　　<img src="/blogImg/2019/9/21/1-3.png" alt><br>　　绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个 Connection，并行完成的<br>　　<br>　　所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。</p><p>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：</p><ol><li>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。</li><li>和服务器建立多个 TCP 连接。</li></ol><p>　　<br><strong>第四个问题：为什么有的时候刷新页面不需要重新建立 SSL 连接？</strong></p><p>　　在第一个问题的讨论中已经有答案了，TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。</p><p>　　<br><strong>第五个问题：浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</strong></p><p>　　假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。</p><p>　　所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。<a href="https://developers.google.com/web/tools/chrome-devtools/network/issues#queued-or-stalled-requests" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome…</a><br>　　<br>　　<strong>那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？</strong></p><p>　　如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。</p><p>　　如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/61423830&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/61423830&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://mlone.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="http" scheme="https://mlone.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>java单例类实现及其原理</title>
    <link href="https://mlone.top/2019/09/21/java%E5%8D%95%E4%BE%8B%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://mlone.top/2019/09/21/java单例类实现及其原理/</id>
    <published>2019-09-21T05:46:11.000Z</published>
    <updated>2019-09-21T06:06:09.727Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.inusha.cn/2019/08/26/singleton/" target="_blank" rel="noopener">https://blog.inusha.cn/2019/08/26/singleton/</a><br><a id="more"></a></p><blockquote><p><strong>第一种，上面使用 static 修饰符：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接在类加载的时候就实例化了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>第二种，在需要这个类的时候才实例化一个类。</strong></p></blockquote><p>　　为了说清楚原理，所以就一步步慢慢来。首先看看下面这个有什么问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>这个代码单线程是没问题的，那如果是多个线程呢？</strong></p></blockquote><p>　　比如两个线程同时判断到 singleton 是 null，两个都去初始化这个实例，或者一个线程还在初始化中，另一个线程判断不为 null 直接拿去用了，那就出问题了呀。</p><p>　　上面的代码问题知道了，那怎么解决呢？最简单粗暴的方法就是把<code>public static SingletonLazy getInstance() {}</code> 这个方法用<code>synchronized</code>修饰一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy singleton;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">          singleton = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　好的，现在知道了加 synchronized可以解决单例的线程安全问题。</p><blockquote><p><strong>那新问题又来了：</strong>每次其他的类要拿这个单例类的实例时，不管需不需要初始化这个单例对象都要经synchronized，要是获取单例对象次数一多，对性能的影响肯定是极大的。那又该怎么解决呢？</p></blockquote><p>　　去掉 synchronized肯定是不行的。既然不能去掉，那就想办法减少加锁的次数嘛。<br>那现在的问题就转化成了怎么把 synchronized的加锁次数降到最低。从上面的多线程问题可知，问题是出在初始化单例对象的时候，那我们能不能只对这一部分加锁呢？</p><p>　　答案肯定是可以的。不多 bb，直接上代码，这里用到了两次 if 判断，没看到过这种用法的可能一时半会儿还真想不出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy singleton;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (SingletonLazy.class) &#123;</span><br><span class="line">              <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  singleton = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>现在你是不是以为问题就解决了？No !</strong></p></blockquote><p>　　现在来分析下为什么上面两个 if 会出问题：</p><pre><code>先来看看new SingletonLazy();时做了些什么呢？memory = allocate();  // 1:分配对象的内存空间ctorInstance(memory); // 2：初始化对象instance = memory;    // 3：设置 instance 指向刚分配的内存地址</code></pre><p>　　2 和 3 这两步是可能发生重排序的(重排序指的是编译器和处理器为了优化程序性能而对指令进行重新排序的一种手段)，也就是 2 可能在 3 执行后再执行,由于 <strong>as-if-serial(as-if-serial 的语义是：不管怎么重排序，单线程程序的执行结果不能被改变)</strong> 的存在，这对单线程没什么影响，但是他并不限制多线程。</p><p>　　回到上面的问题，由于这个<strong>as-if-serial</strong>并不限制多线程，所以上面的代码在多线程下，就有可能由于 上述实例化对象步骤的 2 和 3 的重排序而导致 3 执行了，<strong>对象已经不为 null 了，而这个时候对象还是不可用的，但是恰巧这时候这个对象被其他对象拿去用了</strong>，这会发生什么呢？不知道。有兴趣可以多开点线程试试。<br>　　<br>现在知道问题的根源了。解决方法就出来了嘛：</p><ul><li>1.禁止 2 和 3 两个步骤发生重排序。</li><li>2.可以让他们重排序，但是不能让其他的线程感知到这个重排序。这种方法就是直接在类加载的时候 new 一个，也就是文章开始时的那种方法。</li><li><strong>懒加载最终方法</strong>，加个 <code>volatile</code>嘛。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonLazy singleton;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (SingletonLazy.class) &#123;</span><br><span class="line">              <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  singleton = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后，关于上面用的 <code>volatile</code>什么意思，为什么能禁止重排序。我这儿直接贴一下我以前看的书上的内容了。<br>　　<br><strong>定义：</strong></p><p>　　1. 当写一个 volatile 变量时，Java 内存模型(后面简称 JMM)会把该线程对应的本地内存中的共享变量值刷新到主内存。与锁的释放具有相同的内存语义。<br>　　2. 当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将会从主内存中读取共享变量。与锁的获取具有相同的内存语义。</p><p>　　<br><strong>总结：</strong></p><ul><li>1.线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了(我要修改这个共享变量了)的消息。</li><li>2.线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的(在写这个 volatile 变量之前对共享变量所做修改的)消息。</li><li>3.线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li><li>也就是说，对一个 volatile 变量的写操作对于 读这个 volatile 变量的操作是可见的，而这就保证了获取(即 <strong>读</strong>) singleton 变量时 singleton 已经实例化完成了。</li></ul><p>　　<strong>而这里 volatile 作用实质上是禁止了实例化时步骤 2 和 3 的重排序</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.inusha.cn/2019/08/26/singleton/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.inusha.cn/2019/08/26/singleton/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://mlone.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式锁面试题一</title>
    <link href="https://mlone.top/2019/09/19/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
    <id>https://mlone.top/2019/09/19/分布式锁面试题一/</id>
    <published>2019-09-19T13:56:28.000Z</published>
    <updated>2019-09-19T14:11:14.759Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;mid=2247484012&amp;idx=2&amp;sn=38875256a8e8a618f37ff59fa93a4901&amp;chksm=ec294245db5ecb530b51f8532a7e2945cd663c01464b5d9a3a799c580200f1dcb3df1919894b&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568036276371&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">每日3分钟技术干货 | 面试题+答案 | 分布式锁篇(一)</a><br><a id="more"></a></p><blockquote><p>为什么要使用分布式锁？</p></blockquote><p>　　为了保证一个方法在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。</p><p><strong> 下面介绍JAVA分布式锁的三种常用实现方式：</strong></p><h3 id="1-基于数据库实现分布式锁"><a href="#1-基于数据库实现分布式锁" class="headerlink" title="1. 基于数据库实现分布式锁"></a>1. 基于数据库实现分布式锁</h3><p>　　要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录.</p><p>　　具体操作就是在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><p>　　上面这种简单的实现有以下几个问题：</p><ol><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ol><p>　　当然，我们也可以有其他方式解决上面的问题。</p><p>　　数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</p><p>　　没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</p><p>　　非阻塞的？搞一个while循环，直到insert成功再返回成功。</p><p>　　非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</p><p>　　<strong>优点：</strong>借助数据库，方案简单。</p><p>　　<strong>缺点：</strong>在实际实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑</p><h3 id="2-基于Redis实现分布式锁"><a href="#2-基于Redis实现分布式锁" class="headerlink" title="2. 基于Redis实现分布式锁"></a>2. 基于Redis实现分布式锁</h3><p>　　在Redis2.6.12版本之前，使用setnx命令设置key-value、使用expire命令设置key的过期时间获取分布式锁，使用del命令释放分布式锁，但是这种实现有如下一些问题：</p><p>　　setnx命令设置完key-value后，还没来得及使用expire命令设置过期时间，当前线程挂掉了，会导致当前线程设置的key一直有效，后续线程无法正常通过setnx获取锁，造成死锁。</p><p>　　出现这个问题是因为两个命令是分开执行并且不具备原子特性，如果能将这两个命令合二为一就可以解决问题了。在Redis2.6.12版本中实现了这个功能，Redis为set命令增加了一系列选项。也就是说现在set命令就可以实现分布式锁，下面我们来了解一下set命令（set(keyName, lockValue, “NX”, “EX”, expireSeconds)）：  </p><ol><li>SET命令是原子性操作，NX指令保证只要当key不存在时才会设置value</li><li>设置的value要有唯一性，来确保锁不会被误删(value=系统时间戳+UUID)</li><li>当上述命令执行返回OK时，客户端获取锁成功，否则失败</li><li>客户端可以通过redis释放脚本来释放锁（del 命令）</li><li>如果锁到达了最大生存时间将会自动释放</li></ol><p>　　只有当前key的value和传入的value相同才会执行DEL命令。</p><p>　　<strong>优点：</strong>高性能，借助Redis实现比较方便。</p><p>　　<strong>缺点：</strong>线程获取锁后，如果处理时间过长会导致锁超时失效(失效时间我设置多长时间为好？如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。这个问题使用数据库实现分布式锁同样存在)，所以，通过超时时间来控制锁的失效时间并不是十分的靠谱。</p><h3 id="3-基于Zookeeper实现分布式锁"><a href="#3-基于Zookeeper实现分布式锁" class="headerlink" title="3. 基于Zookeeper实现分布式锁"></a>3. 基于Zookeeper实现分布式锁</h3><p>　　ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>　　基于ZooKeeper实现分布式锁的步骤如下：</p><p>　　创建一个目录mylock； </p><p>　　线程A想获取锁就在mylock目录下创建临时顺序节点； </p><p>　　获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； </p><p>　　线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； </p><p>　　线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。 </p><p>　　<strong>优点：</strong>具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。具体说明如下：</p><p>　　锁无法释放，造成死锁！使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p><p>　　阻塞锁特性！使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p><p>　　可重入！使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p><p>　　单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p><p>　　<strong>缺点：</strong>因为需要频繁的创建和删除节点，性能上不如Redis方式。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>　　上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;amp;mid=2247484012&amp;amp;idx=2&amp;amp;sn=38875256a8e8a618f37ff59fa93a4901&amp;amp;chksm=ec294245db5ecb530b51f8532a7e2945cd663c01464b5d9a3a799c580200f1dcb3df1919894b&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1568036276371&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每日3分钟技术干货 | 面试题+答案 | 分布式锁篇(一)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://mlone.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的Unsafe与CAS</title>
    <link href="https://mlone.top/2019/09/19/Java%E4%B8%AD%E7%9A%84Unsafe%E4%B8%8ECAS/"/>
    <id>https://mlone.top/2019/09/19/Java中的Unsafe与CAS/</id>
    <published>2019-09-19T13:36:24.000Z</published>
    <updated>2019-09-19T13:48:34.581Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.cnblogs.com/xrq730/p/4976007.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4976007.html</a><br><a id="more"></a></p><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>　　简单讲一下这个类。Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的<strong>原子操作</strong>。</p><p>　　这个类尽管里面的方法都是public的，但是并没有办法使用它们，JDK API文档也没有提供任何关于这个类的方法的解释。总而言之，对于Unsafe类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然JDK库里面的类是可以随意使用的。</p><p>　　从第一行的描述可以了解到Unsafe提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过Java本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。</p><p>举两个例子，比方说：</p><pre><code>public native long staticFieldOffset(Field paramField);</code></pre><p>　　这个方法可以用来获取给定的paramField的内存地址偏移量，这个值对于给定的field是唯一的且是固定不变的。再比如说：</p><pre><code>public native int arrayBaseOffset(Class paramClass);public native int arrayIndexScale(Class paramClass);</code></pre><p>　　前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。最后看三个方法：</p><pre><code>public native long allocateMemory(long paramLong);public native long reallocateMemory(long paramLong1, long paramLong2);public native void freeMemory(long paramLong);</code></pre><p>　　分别用来分配内存，扩充内存和释放内存的。</p><p>　　当然这需要有一定的C/C++基础，对内存分配有一定的了解，这也是为什么我一直认为C/C++开发者转行做Java会有优势的原因。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>　　CAS，Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，java.util.concurrent包全完建立在CAS之上，没有CAS也就没有此包，可见CAS的重要性。</p><p>　　当前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。<span style="color: red;">CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。</span></p><p>　　CAS也是通过Unsafe实现的，看下Unsafe下的三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2, <span class="keyword">long</span> paramLong3)</span></span>;</span><br></pre></td></tr></table></figure></p><p>　　就拿中间这个比较并交换Int值为例好了，如果我们不用CAS，那么代码大致是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = j;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　当然这段代码在并发下是肯定有问题的，有可能线程1运行到了第5行正准备运行第7行，线程2运行了，把i修改为10，线程切换回去，线程1由于先前已经满足第5行的if了，所以导致两个线程同时修改了变量i。</p><p>　　解决办法也很简单，给compareAndSwapInt方法加锁同步就行了，这样，compareAndSwapInt方法就变成了一个原子操作。CAS也是一样的道理，比较、交换也是一组原子操作，不会被外部打断，先根据paramLong/paramLong1获取到内存当中当前的内存值V，在将内存值V和原值A作比较，要是相等就修改为要修改的值B，由于CAS都是硬件级别的操作，因此效率会高一些。</p><h2 id="由CAS分析AtomicInteger原理"><a href="#由CAS分析AtomicInteger原理" class="headerlink" title="由CAS分析AtomicInteger原理"></a>由CAS分析AtomicInteger原理</h2><p>　　java.util.concurrent.atomic包下的原子操作类都是基于CAS实现的，下面拿AtomicInteger分析一下，首先是AtomicInteger类变量的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    valueOffset = unsafe.objectFieldOffset</span><br><span class="line">        (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure></p><p>　　关于这段代码中出现的几个成员属性：</p><ol><li><p>Unsafe是CAS的核心类，前面已经讲过了</p></li><li><p>valueOffset表示的是变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的原值的</p></li><li><p>value是用volatile修饰的，这是非常关键的</p></li></ol><p>　　下面找一个方法getAndIncrement来研究一下AtomicInteger是如何实现的，比如我们常用的addAndGet方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + delta;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这段代码如何在不加锁的情况下通过CAS实现线程安全，我们不妨考虑一下方法的执行：</p><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据Java内存模型，线程1和线程2各自持有一份value的副本，值为3</li><li>线程1运行到第三行获取到当前的value为3，线程切换</li><li>线程2开始运行，获取到value为3，利用CAS对比内存中的值也为3，比较成功，修改内存，此时内存中的value改变比方说是4，线程切换</li><li>线程1恢复运行，利用CAS比较发现自己的value为3，内存中的value为4，得到一个重要的结论–&gt;<span style="color: red;">此时value正在被另外一个线程修改，所以我不能去修改它</span></li><li>线程1的compareAndSet失败，循环判断，因为value是volatile修饰的，所以它具备可见性的特性，线程2对于value的改变能被线程1看到，只要线程1发现当前获取的value是4，内存中的value也是4，说明<span style="color: red;">线程2对于value的修改已经完毕并且线程1可以尝试去修改它</span></li><li>最后说一点，比如说此时线程3也准备修改value了，没关系，因为比较-交换是一个原子操作不可被打断，线程3修改了value，线程1进行compareAndSet的时候必然返回的false，这样线程1会继续循环去获取最新的value并进行compareAndSet，直至获取的value和内存中的value一致为止</li></ol><p>　　整个过程中，利用CAS机制保证了对于value的修改的线程安全性。</p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p>　　CAS看起来很美，但这种操作显然无法涵盖并发下的所有场景，并且CAS从语义上来说也不是完美的，存在这样一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个漏洞称为CAS操作的”ABA”问题。java.util.concurrent包为了解决这个问题，提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较”鸡肋”，大部分情况下ABA问题并不会影响程序并发的正确性，如果需要解决ABA问题，使用传统的互斥同步可能回避原子类更加高效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://www.cnblogs.com/xrq730/p/4976007.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/xrq730/p/4976007.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock之公平锁源码分析</title>
    <link href="https://mlone.top/2019/09/19/ReentrantLock%E4%B9%8B%E5%85%AC%E5%B9%B3%E9%94%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://mlone.top/2019/09/19/ReentrantLock之公平锁源码分析/</id>
    <published>2019-09-19T13:09:59.000Z</published>
    <updated>2019-09-19T13:34:07.599Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s/S_mzc5dy89GwFnNUqaTu2Q" target="_blank" rel="noopener">ReentrantLock 之公平锁源码分析</a><br><a id="more"></a></p><p>　　本文分析的ReentrantLock所对应的Java版本为JDK8。<br>　　在阅读本文前，读者应该知道什么是CAS、自旋。</p><p><strong>本文大纲</strong></p><ol><li>ReentrantLock公平锁简介</li><li>AQS</li><li>lock方法</li><li>unlock方法</li></ol><h2 id="1-ReentrantLock公平锁简介"><a href="#1-ReentrantLock公平锁简介" class="headerlink" title="1. ReentrantLock公平锁简介"></a>1. ReentrantLock公平锁简介</h2><p>　　ReentrantLock是JUC（java.util.concurrent）包中Lock接口的一个实现类，它是基于AbstractQueuedSynchronizer（下文简称AQS）来实现锁的功能。ReentrantLock的内部类Sync继承了AbstractQueuedSynchronizer，Sync又有FairSync和NonFairSync两个子类。FairSync实现了公平锁相关的操作，NonFairSync实现了非公平锁相关的操作。它们之间的关系如下：<br>　　<img src="/blogImg/2019/9/19/1-1.png" alt></p><p>　　公平锁的公平之处主要体现在，对于一个新来的线程，如果锁没有被占用，它会判断等待队列中是否还有其它的等待线程，如果有的话，就加入等待队列队尾，否则就去抢占锁。</p><p>下面这段代码展示了公平锁的使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">// 参数true代表创建公平锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// ... method body</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2. AQS"></a>2. AQS</h2><p>　　下面简单介绍一下AQS中的Node内部类和几个重要的成员变量。</p><h3 id="2-1-Node"><a href="#2-1-Node" class="headerlink" title="2.1 Node"></a>2.1 Node</h3><p>　　AQS中，维护了一个Node内部类，用于包装我们的线程。我们需要关注Node中的如下属性：</p><ul><li>pre：当前节点的前驱节点。</li><li>next：当前节点的后继节点。</li><li>thread：thread表示被包装的线程。</li><li><p>waitStatus：waitStatus是一个int整型，可以被赋予如下几种值：</p><pre><code>static final int CANCELLED =  1; // 线程被取消static final int SIGNAL  = -1; // 后继节点中的线程需要被唤醒static final int CONDITION = -2; // 暂不关注static final int PROPAGATE = -3; // 暂不关注</code></pre></li></ul><p>另外，当一个新的Node被创建时，waitStatus是0。</p><h3 id="2-2-head"><a href="#2-2-head" class="headerlink" title="2.2 head"></a>2.2 head</h3><p>　　head指向队列中的队首元素，可以理解为当前持有锁的线程。</p><h3 id="2-3-tail"><a href="#2-3-tail" class="headerlink" title="2.3 tail"></a>2.3 tail</h3><p>　　tail指向队列中的队尾元素。</p><h3 id="2-4-state"><a href="#2-4-state" class="headerlink" title="2.4 state"></a>2.4 state</h3><p>　　state表示在ReentrantLock中可以理解为锁的状态，0表示当前锁没有被占用，大于0的数表示锁被当前线程重入的次数。例如，当state等于2时，表示当前线程在这把锁上进入了两次。</p><h3 id="2-5-exclusiveOwnerThread"><a href="#2-5-exclusiveOwnerThread" class="headerlink" title="2.5 exclusiveOwnerThread"></a>2.5 exclusiveOwnerThread</h3><p>　　表示当前占用锁的线程。</p><h3 id="2-6-等待队列"><a href="#2-6-等待队列" class="headerlink" title="2.6 等待队列"></a>2.6 等待队列</h3><p>　　下图简单展示了AQS中的等待队列：<br>　　<img src="/blogImg/2019/9/19/1-2.png" alt></p><h2 id="3-lock方法"><a href="#3-lock方法" class="headerlink" title="3. lock方法"></a>3. lock方法</h2><p>　　有了上面的AQS的基础知识后，我们就可以展开对ReentrantLock公平锁的分析了，先从lock方法入手。</p><p>　　ReentrantLock中的lock方法很简单，只是调用了Sync类（本文研究公平锁，所以应该是FairSync类）中的lock方法：</p><pre><code>public void lock() {    sync.lock();}</code></pre><p>　　我们跟到FairSync的lock方法，代码也很简单，调用了AQS中的acquire方法：</p><pre><code>final void lock() {    acquire(1);}</code></pre><p>　　acquire方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 调用tryAcquire尝试去获取锁，如果获取成功，则方法结束</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 如果获取锁失败，执行acquireQueued方法，将把当前线程排入队尾</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　tryAcquire方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 获取锁的状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果状态是0，表示锁没有被占用</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 判断是队列中是否有排队中的线程</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 队列中没有排队的线程，则尝试用CAS去获取一下锁</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 获取锁成功，则将当前占有锁的线程设置为当前线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁被占用、队列中有排队的线程或者当前线程在获取锁的时候失败将执行下面的代码</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 当前线程是否是占有锁的线程</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">// 是的话，表示当前线程是重入这把锁，将锁的状态进行加1</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>); <span class="comment">// 锁的重入次数超过int能够表示最大的值，抛出异常</span></span><br><span class="line">        setState(nextc); <span class="comment">// 设置锁的状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 没有获取到锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　hasQueuedPredecessors方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; <span class="comment">// 队列中的队首和队尾元素不相同</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread()); <span class="comment">// 队列中的第二个元素不为null，且第二个元素中的线程不是当前线程。这里如果返回true，说明队列中至少存在tail、head两个节点，就会执行acquireQueued将当前线程加入队尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如果tryAcquire没有获取到锁，将执行：</p><pre><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></pre><p>　　我们先分析addWaiter方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">// 将当前线程包装成Node，mode参数值为null，表示独占模式</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred; <span class="comment">// 如果队列中的尾节点不为空，将当前node的前驱节点设置为之前队列中的tail</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 用CAS把当前node设置为队尾元素</span></span><br><span class="line">            pred.next = node; <span class="comment">// 成功的话，则将之前队尾元素的后继节点设置为当前节点。如果这里不清楚的话，请结合前面讲等待队列的那张图进行理解。</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 队尾节点为空，或者用CAS设置队尾元素失败，则用自旋的方式入队</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　enq方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 队尾元素为空，创建一个空的Node，并设置为队首</span></span><br><span class="line">                tail = head; <span class="comment">// 设置队首和队尾为同一个空Node，进入下一次循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t; <span class="comment">// 如果队列中的尾节点不为空，将当前node的前驱节点设置为之前队列中的tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 用CAS把当前node设置为队尾元素</span></span><br><span class="line">                t.next = node; <span class="comment">// 成功的话，则将之前队尾元素的后继节点设置为当前节点</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　下面这张图反应了上面enq方法的处理流程：<br>　　<img src="/blogImg/2019/9/19/1-3.png" alt></p><p>　　经过上面的方法，当前node已经加入等待队列的队尾，接下来将执行acquireQueued方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获取node的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果node的前驱是head，它将去尝试获取锁（tryAcquire方法在前面已经分析过）</span></span><br><span class="line">                setHead(node); <span class="comment">// 获取成功，则将node设置为head</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 将之前的head的后继节点置空</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 当前node的前驱不是head，将为当前node找到一个能够将其唤醒的前驱节点；或者当前node的前驱是head，但是获取锁失败</span></span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 将当前线程挂起</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　shouldParkAfterFailedAcquire方法的作用就是找到一个能够唤醒当前node的节点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 开始时是0</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 前驱节点的状态是-1，会唤醒后继节点，可以将线程挂起</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev; <span class="comment">// 前驱节点中的线程被取消，那就需要一直循环直到找到一个没有被设置为取消状态的前驱节点</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node; <span class="comment">// 从后向前找，将第一个非取消状态的节点，设置这个节点的后继节点设置为当前node</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// waitStatus是0或者-3的时候，这时waitStatus都将被设置为-1</span></span><br><span class="line">                                                        <span class="comment">// 即后继节点需要前驱节点唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 上层代码再进行一次循环，下次进入此方法时，将进入第一个if条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　找到了合适的前驱节点，parkAndCheckInterrupt方法当前线程挂起：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123; <span class="comment">// 将线程挂起，等待前驱节点的唤醒</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-unlock方法"><a href="#4-unlock方法" class="headerlink" title="4. unlock方法"></a>4. unlock方法</h2><p>　　ReentrantLock的unlock方法调用AQS中的release方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>); <span class="comment">// 调用AQS的release方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　release方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 尝试去释放锁</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 释放锁成功，head不为空，并且head的waitStatus不为0的情况下，将唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　tryRelease方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 将锁的状态减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); <span class="comment">// 准备释放锁的线程不是持有锁的线程，抛出异常</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>; <span class="comment">// 锁的状态是0，说明不存在重入的情况了，可以直接释放了</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　锁释放成功，将唤醒后继节点，unparkSuccessor方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus; <span class="comment">// 注意，这个node是head节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 当前node的状态是小于0，将其状态设置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next; <span class="comment">// head节点的后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>; <span class="comment">// 执行到这表示head的后继节点是1，处于取消的状态</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t; <span class="comment">// 从等待队列的队尾向前找，找到倒序的最后一个处于非取消状态的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">// 唤醒head后面的处于非取消状态的第一个（正序）节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s/S_mzc5dy89GwFnNUqaTu2Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReentrantLock 之公平锁源码分析&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux最常用命令</title>
    <link href="https://mlone.top/2019/09/18/Linux%E6%9C%80%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://mlone.top/2019/09/18/Linux最常用命令/</id>
    <published>2019-09-18T13:42:01.000Z</published>
    <updated>2019-09-18T14:02:06.248Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://blog.csdn.net/xulong_08/article/list/" target="_blank" rel="noopener">https://blog.csdn.net/xulong_08/article/list/</a><br><a id="more"></a></p><h2 id="一、linux的目录结构"><a href="#一、linux的目录结构" class="headerlink" title="一、linux的目录结构"></a>一、linux的目录结构</h2><p>　　<img src="/blogImg/2019/9/18/1-1.png" alt></p><ul><li>bin (binaries)存放二进制可执行文件</li><li>sbin (super user binaries)存放二进制可执行文件，只有root才能访问</li><li>etc (etcetera)存放系统配置文件</li><li>usr (unix shared resources)用于存放共享的系统资源</li><li>home 存放用户文件的根目录</li><li>root 超级用户目录</li><li>dev (devices)用于存放设备文件</li><li>lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块</li><li>mnt (mount)系统管理员安装临时文件系统的安装点</li><li>boot 存放用于系统引导时使用的各种文件</li><li>tmp (temporary)用于存放各种临时文件</li><li>var (variable)用于存放运行时需要改变数据的文件</li></ul><h2 id="二、linux常用命令"><a href="#二、linux常用命令" class="headerlink" title="二、linux常用命令"></a>二、linux常用命令</h2><p><strong>命令格式</strong>：命令 -选项 参数 （选项和参数可以为空）<br>如：<code>ls -la /usr</code></p><h3 id="2-1-操作文件及目录"><a href="#2-1-操作文件及目录" class="headerlink" title="2.1 操作文件及目录"></a>2.1 操作文件及目录</h3><p>　　<img src="/blogImg/2019/9/18/1-2.png" alt></p><h3 id="2-2-系统常用命令"><a href="#2-2-系统常用命令" class="headerlink" title="2.2 系统常用命令"></a>2.2 系统常用命令</h3><p>　　<img src="/blogImg/2019/9/18/1-3.png" alt></p><h3 id="2-3-压缩解压缩"><a href="#2-3-压缩解压缩" class="headerlink" title="2.3 压缩解压缩"></a>2.3 压缩解压缩</h3><p>　　<img src="/blogImg/2019/9/18/1-4.png" alt></p><h3 id="2-4-文件权限操作"><a href="#2-4-文件权限操作" class="headerlink" title="2.4 文件权限操作"></a>2.4 文件权限操作</h3><ul><li>linux文件权限的描述格式解读<br>　　<img src="/blogImg/2019/9/18/1-5.png" alt>　　</li><li>r 可读权限，w可写权限，x可执行权限（也可以用二进制表示 111 110 100 –&gt; 764）</li><li>第1位：文件类型（d 目录，- 普通文件，l 链接文件）</li><li>第2-4位：所属用户权限，用u（user）表示</li><li>第5-7位：所属组权限，用g（group）表示</li><li>第8-10位：其他用户权限，用o（other）表示</li><li>第2-10位：表示所有的权限，用a（all）表示<br>　　<img src="/blogImg/2019/9/18/1-6.png" alt></li></ul><h2 id="三、linux系统常用快捷键及符号命令"><a href="#三、linux系统常用快捷键及符号命令" class="headerlink" title="三、linux系统常用快捷键及符号命令"></a>三、linux系统常用快捷键及符号命令</h2><p>　　<img src="/blogImg/2019/9/18/1-7.png" alt></p><h2 id="四、vim编辑器"><a href="#四、vim编辑器" class="headerlink" title="四、vim编辑器"></a>四、vim编辑器</h2><p>　　vi / vim是Linux上最常用的文本编辑器而且功能非常强大。只有命令，没有菜单，下图表示vi命令的各种模式的切换图：<br>　　<img src="/blogImg/2019/9/18/1-8.png" alt></p><h3 id="4-1-修改文本"><a href="#4-1-修改文本" class="headerlink" title="4.1 修改文本"></a>4.1 修改文本</h3><p>　　<img src="/blogImg/2019/9/18/1-9.png" alt></p><h3 id="4-2-定位命令"><a href="#4-2-定位命令" class="headerlink" title="4.2 定位命令"></a>4.2 定位命令</h3><p>　　<img src="/blogImg/2019/9/18/1-10.png" alt></p><h3 id="4-3-替换和取消命令"><a href="#4-3-替换和取消命令" class="headerlink" title="4.3 替换和取消命令"></a>4.3 替换和取消命令</h3><p>　　<img src="/blogImg/2019/9/18/1-11.png" alt></p><h3 id="4-4-删除命令"><a href="#4-4-删除命令" class="headerlink" title="4.4 删除命令"></a>4.4 删除命令</h3><p>　　<img src="/blogImg/2019/9/18/1-12.png" alt></p><h3 id="4-5-常用快捷键"><a href="#4-5-常用快捷键" class="headerlink" title="4.5 常用快捷键"></a>4.5 常用快捷键</h3><p>　　<img src="/blogImg/2019/9/18/1-13.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：&lt;a href=&quot;https://blog.csdn.net/xulong_08/article/list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/xulong_08/article/list/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://mlone.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>面试必备：Java线程池解析</title>
    <link href="https://mlone.top/2019/09/17/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90/"/>
    <id>https://mlone.top/2019/09/17/面试必备：Java线程池解析/</id>
    <published>2019-09-17T14:02:24.000Z</published>
    <updated>2019-09-17T15:08:15.633Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14</a><br><a id="more"></a></p><h1 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h1><ul><li>面试问题1：Java的线程池说一下，各个参数的作用，如何进行的?</li><li>面试问题2：按线程池内部机制，当提交新任务时，有哪些异常要考虑。</li><li>面试问题3：线程池都有哪几种工作队列？</li><li>面试问题4：使用无界队列的线程池会导致内存飙升吗？</li><li>面试问题5：说说几种常见的线程池及使用场景?</li></ul><h1 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h1><p><strong> 线程池：</strong> 简单理解，它就是一个管理线程的池子。</p><ul><li><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li><li><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li><li><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li></ul><h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><p>　　线程池可以通过ThreadPoolExecutor来创建，我们来看一下它的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">   BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">   RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure></p><p>几个核心参数的作用：</p><ul><li><strong>corePoolSize：</strong> 线程池核心线程数最大值</li><li><strong>maximumPoolSize：</strong> 线程池最大线程数大小</li><li><strong>keepAliveTime：</strong> 线程池中非核心线程空闲的存活时间大小</li><li><strong>unit：</strong> 线程空闲存活时间单位</li><li><strong>workQueue：</strong> 存放任务的阻塞队列</li><li><strong>threadFactory：</strong> 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li><li><strong>handler：</strong>  线城池的饱和策略事件，主要有四种类型。</li></ul><h1 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h1><h2 id="线程池执行流程，即对应execute-方法："><a href="#线程池执行流程，即对应execute-方法：" class="headerlink" title="线程池执行流程，即对应execute()方法："></a>线程池执行流程，即对应execute()方法：</h2><p>　　<img src="/blogImg/2019/9/17/3-1.png" alt></p><ul><li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li><li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li><li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li><li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li></ul><h2 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h2><ul><li>AbortPolicy(抛出一个异常，默认的)</li><li>DiscardPolicy(直接丢弃任务)</li><li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li><li>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</li></ul><h2 id="为了形象描述线程池执行，我打个比喻："><a href="#为了形象描述线程池执行，我打个比喻：" class="headerlink" title="为了形象描述线程池执行，我打个比喻："></a>为了形象描述线程池执行，我打个比喻：</h2><ul><li><p>核心线程比作公司正式员工</p></li><li><p>非核心线程比作外包员工</p></li><li><p>阻塞队列比作需求池</p></li><li><p>提交任务比作提需求<br>　　<img src="/blogImg/2019/9/17/3-2.png" alt></p></li><li><p>当产品提个需求，正式员工（核心线程）先接需求（执行任务）</p></li><li>如果正式员工都有需求在做，即核心线程数已满），产品就把需求先放需求池（阻塞队列）。</li><li>如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。</li><li>如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。</li><li>如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</li></ul><p>　　好的，到这里。<strong>面试问题1-&gt;Java的线程池说一下，各个参数的作用，如何进行的?</strong> 是否已经迎刃而解啦， 我觉得这个问题，回答：<strong>线程池构造函数的corePoolSize,maximumPoolSize等参数，并且能描述清楚线程池的执行流程</strong> 就差不多啦。</p><h1 id="线程池异常处理"><a href="#线程池异常处理" class="headerlink" title="线程池异常处理"></a>线程池异常处理</h1><p>　　在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p><h2 id="当提交新任务时，异常如何处理"><a href="#当提交新任务时，异常如何处理" class="headerlink" title="当提交新任务时，异常如何处理?"></a>当提交新任务时，异常如何处理?</h2><p>我们先来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    threadPool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"current thread name"</span> + Thread.currentThread().getName());</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        System.out.print(<span class="string">"result## "</span>+object.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然，这段代码会有异常，我们再来看看执行结果：<br>　　<img src="/blogImg/2019/9/17/3-3.png" alt><br>　　虽然没有结果输出，但是没有抛出异常，所以我们无法感知任务出现了异常，所以需要添加try/catch。如下图：<br>　　<img src="/blogImg/2019/9/17/3-4.png" alt></p><p>　　OK，线程的异常处理，<strong>我们可以直接try…catch捕获。</strong>　</p><h2 id="线程池exec-submit-runnable-的执行流程"><a href="#线程池exec-submit-runnable-的执行流程" class="headerlink" title="线程池exec.submit(runnable)的执行流程"></a>线程池exec.submit(runnable)的执行流程</h2><p>　　通过debug上面有异常的submit方法（<strong>建议大家也去debug看一下,图上的每个方法内部是我打断点的地方</strong>），处理有异常submit方法的主要执行流程图：<br>　　<img src="/blogImg/2019/9/17/3-5.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造feature对象</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">       <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">       execute(ftask);</span><br><span class="line">       <span class="keyword">return</span> ftask;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">       <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//线程池执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">              <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//捕获异常</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)</span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>　　通过以上分析，submit执行的任务，可以通过Future对象的get方法接收抛出的异常，再进行处理。 我们再通过一个demo，看一下Future对象的get方法处理异常的姿势，如下图：<br>　　<img src="/blogImg/2019/9/17/3-6.png" alt></p><h2 id="其他两种处理线程池异常方案"><a href="#其他两种处理线程池异常方案" class="headerlink" title="其他两种处理线程池异常方案"></a>其他两种处理线程池异常方案</h2><p>除了以上<strong>1. 在任务代码try/catch捕获异常，2. 通过Future对象的get方法接收抛出的异常，再处理</strong>两种方案外，还有以下两种方案：</p><h3 id="3-为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常"><a href="#3-为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常" class="headerlink" title="3. 为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常"></a>3. 为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常</h3><p>我们直接看这样实现的正确姿势：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">1</span>, r -&gt; &#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">    t.setUncaughtExceptionHandler(</span><br><span class="line">            (t1, e) -&gt; &#123;</span><br><span class="line">                System.out.println(t1.getName() + <span class="string">"线程抛出的异常"</span>+e);</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">   &#125;);</span><br><span class="line">threadPool.execute(()-&gt;&#123;</span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    System.out.print(<span class="string">"result## "</span> + object.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-7.png" alt></p><h3 id="4-重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用"><a href="#4-重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用" class="headerlink" title="4. 重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用"></a>4. 重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用</h3><p>这是jdk文档的一个demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这可是jdk文档里面给的例子。。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> &amp;&amp; r <span class="keyword">instanceof</span> Future&lt;?&gt;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object result = ((Future&lt;?&gt;) r).get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException ce) &#123;</span><br><span class="line">                t = ce;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException ee) &#123;</span><br><span class="line">                t = ee.getCause();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); <span class="comment">// ignore/reset</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="因此，被问到线程池异常处理，如何回答？"><a href="#因此，被问到线程池异常处理，如何回答？" class="headerlink" title="因此，被问到线程池异常处理，如何回答？"></a>因此，被问到线程池异常处理，如何回答？</h2><p>　　<img src="/blogImg/2019/9/17/3-8.png" alt></p><h1 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h1><p><strong>线程池都有哪几种工作队列？</strong></p><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>　　ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>　　LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>　　DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>　　PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列。</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>　　SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。<br>　　<br>　　针对面试题：<strong>线程池都有哪几种工作队列？</strong> 我觉得，<strong>回答以上几种ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue等，说出它们的特点，并结合使用到对应队列的常用线程池(如newFixedThreadPool线程池使用LinkedBlockingQueue)，进行展开阐述，</strong> 就可以啦。　　</p><h1 id="几种常用的线程池"><a href="#几种常用的线程池" class="headerlink" title="几种常用的线程池"></a>几种常用的线程池</h1><ul><li>newFixedThreadPool (固定数目线程的线程池)</li><li>newCachedThreadPool(可缓存线程的线程池)</li><li>newSingleThreadExecutor(单线程的线程池)</li><li>newScheduledThreadPool(定时及周期执行的线程池)</li></ul><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池特点："><a href="#线程池特点：" class="headerlink" title="线程池特点："></a>线程池特点：</h3><ul><li>核心线程数和最大线程数大小一样</li><li>没有所谓的非空闲时间，即keepAliveTime为0</li><li>阻塞队列为无界队列LinkedBlockingQueue</li></ul><h3 id="工作机制："><a href="#工作机制：" class="headerlink" title="工作机制："></a>工作机制：</h3><p>　　<img src="/blogImg/2019/9/17/3-9.png" alt></p><ul><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li></ul><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            executor.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>IDE指定JVM参数：<code>-Xmx8m -Xms8m</code> :<br>　　<img src="/blogImg/2019/9/17/3-10.png" alt></p><p>run以上代码，会抛出OOM：<br>　　<img src="/blogImg/2019/9/17/3-11.png" alt></p><p>　　<br>因此，<strong>面试题：使用无界队列的线程池会导致内存飙升吗？</strong></p><p>答案 <strong>：会的，newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长(比如，上面demo设置了10秒)，会导致队列的任务越积越多，导致机器内存使用不停飙升，</strong> 最终导致OOM。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池特点：-1"><a href="#线程池特点：-1" class="headerlink" title="线程池特点："></a>线程池特点：</h3><ul><li>核心线程数为0</li><li>最大线程数为Integer.MAX_VALUE</li><li>阻塞队列是SynchronousQueue</li><li>非核心线程空闲存活时间为60秒</li></ul><p>　　当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>　　<img src="/blogImg/2019/9/17/3-12.png" alt></p><ul><li>提交任务</li><li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ul><h3 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-13.png" alt></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　用于并发执行大量短期的小任务。</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池特点"><a href="#线程池特点" class="headerlink" title="线程池特点"></a>线程池特点</h3><ul><li>核心线程数为1</li><li>最大线程数也为1</li><li>阻塞队列是LinkedBlockingQueue</li><li>keepAliveTime为0</li></ul><h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><p>　　<img src="/blogImg/2019/9/17/3-14.png" alt></p><ul><li>提交任务</li><li>线程池是否有一条线程在，如果没有，新建线程执行任务</li><li>如果有，讲任务加到阻塞队列</li><li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</li></ul><h3 id="实例代码-2"><a href="#实例代码-2" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">     executor.execute(() -&gt; &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-15.png" alt></p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　适用于串行执行任务的场景，一个任务一个任务地执行。</p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池特点-1"><a href="#线程池特点-1" class="headerlink" title="线程池特点"></a>线程池特点</h3><ul><li>最大线程数为Integer.MAX_VALUE</li><li>阻塞队列是DelayedWorkQueue</li><li>keepAliveTime为0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><h3 id="工作机制-2"><a href="#工作机制-2" class="headerlink" title="工作机制"></a>工作机制</h3><ul><li>添加一个任务</li><li>线程池中的线程从 DelayQueue 中取任务</li><li>线程从 DelayQueue 中获取 time 大于等于当前时间的task</li><li>执行完后修改这个 task 的 time 为下次被执行的时间</li><li>这个 task 放回DelayQueue队列中</li></ul><h3 id="实例代码-3"><a href="#实例代码-3" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  创建一个给定初始延迟的间隔性的任务，之后的下次执行时间是上一次任务从执行到结束所需要的时间+* 给定的间隔时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">scheduledExecutorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"current Time"</span> + System.currentTimeMillis());</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-16.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  创建一个给定初始延迟的间隔性的任务，之后的每次任务执行时间为 初始延迟 + N * delay(间隔) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"current Time"</span> + System.currentTimeMillis());</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></p><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　周期性执行任务的场景，需要限制线程数量的场景</p><p>　　回到面试题：<strong>说说几种常见的线程池及使用场景？</strong></p><p>　　回答这四种经典线程池 <strong>：newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool，newScheduledThreadPool，分线程池特点，工作机制，使用场景分开描述，再分析可能存在的问题，比如newFixedThreadPool内存飙升问题</strong> 即可。</p><h1 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h1><p>线程池有这几个状态：<br>　　- RUNNING<br>　　- SHUTDOWN<br>　　- STOP<br>　　- TIDYING<br>　　- TERMINATED</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><h2 id="线程池各个状态切换图："><a href="#线程池各个状态切换图：" class="headerlink" title="线程池各个状态切换图："></a>线程池各个状态切换图：</h2><p>　　<img src="/blogImg/2019/9/17/3-17.png" alt></p><h3 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h3><ul><li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li><li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li><li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li></ul><h3 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h3><ul><li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</li></ul><h3 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h3><ul><li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>线程池中执行的任务为空,进入TIDYING状态;</li></ul><h3 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h3><ul><li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li><li>terminated()执行完毕，进入TERMINATED状态</li></ul><h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><ul><li>该状态表示线程池彻底终止</li></ul><h1 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h1><ul><li>Java线程池异常处理方案：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F30e488f4e021" target="_blank" rel="noopener">www.jianshu.com/p/30e488f4e…</a></li><li>Java线程池  <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2888" target="_blank" rel="noopener">www.hollischuang.com/archives/28…</a></li><li>关于线程池的面试题 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F9710b899e749" target="_blank" rel="noopener">www.jianshu.com/p/9710b899e…</a></li><li>线程池的五种状态 <a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fl_kanglin%2Farticle%2Fdetails%2F57411851" target="_blank" rel="noopener">blog.csdn.net/l_kanglin/a…</a></li><li>深入分析java线程池的实现原理 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F87bff5cc8d8c%2F" target="_blank" rel="noopener">www.jianshu.com/p/87bff5cc8…</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>count(1)、count(*)与count(列名)的执行区别</title>
    <link href="https://mlone.top/2019/09/17/count-1-%E3%80%81count-%E4%B8%8Ecount-%E5%88%97%E5%90%8D-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8C%BA%E5%88%AB/"/>
    <id>https://mlone.top/2019/09/17/count-1-、count-与count-列名-的执行区别/</id>
    <published>2019-09-17T13:40:28.000Z</published>
    <updated>2019-09-17T13:57:40.670Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/iFuMI/article/details/77920767" target="_blank" rel="noopener">count(1)、count(*) 与 count(列名) 的执行区别</a><br><a id="more"></a></p><h3 id="count-1-and-count"><a href="#count-1-and-count" class="headerlink" title="count(1) and count(*)"></a>count(1) and count(*)</h3><p>　　当表的数据量大些时，对表作分析之后，使用count(1)还要比使用count(*)用时多了！ </p><p>　　从执行计划来看，count(1)和count(<em>)的效果是一样的。但是在表做过分析之后，count(1)会比count(</em>)的用时少些（1w以内数据量），不过差不了多少。 </p><p>　　如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。 </p><p>　　因为count(<em>),自动会优化指定到那一个字段。所以没必要去count(1)，用count(</em>)，sql会帮你完成优化的 因此：<strong>count(1)和count(*)基本没有差别！ </strong></p><h3 id="count-1-and-count-字段"><a href="#count-1-and-count-字段" class="headerlink" title="count(1) and count(字段)"></a>count(1) and count(字段)</h3><p>两者的主要区别是：<br>　　1. count(1) 会统计表中的所有的记录数，包含字段为null 的记录。<br>　　2. count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 </p><h3 id="count-和-count-1-和count-列名"><a href="#count-和-count-1-和count-列名" class="headerlink" title="count(*) 和 count(1)和count(列名)"></a>count(*) 和 count(1)和count(列名)</h3><p><strong>执行效果上： </strong></p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，<strong>不会忽略列值为NULL</strong> ；</li><li>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，<strong>不会忽略列值为NULL</strong> ；</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，<strong>即某个字段值为NULL时，不统计</strong>。</li></ul><p><strong>执行效率上： </strong></p><ul><li>列名为主键，count(列名)会比count(1)快 ；</li><li>列名不为主键，count(1)会比count(列名)快；</li><li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） ；</li><li>如果有主键，则 <code>select count（主键）</code>的执行效率是最优的 ；</li><li>如果表只有一个字段，则<code>select count（*）</code>最优。</li></ul><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table counttest(name char(1), age char(2));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into counttest values</span><br><span class="line">    -&gt; ('a', '14'),('a', '15'), ('a', '15'),</span><br><span class="line">    -&gt; ('b', NULL), ('b', '16'),</span><br><span class="line">    -&gt; ('c', '17'),</span><br><span class="line">    -&gt; ('d', null),</span><br><span class="line">    -&gt;('e', '');</span><br><span class="line">Query OK, 8 rows affected (0.01 sec)</span><br><span class="line">Records: 8  Duplicates: 0  Warnings: 0</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from counttest;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| name | age  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| a    | 14   |</span><br><span class="line">| a    | 15   |</span><br><span class="line">| a    | 15   |</span><br><span class="line">| b    | NULL |</span><br><span class="line">| b    | 16   |</span><br><span class="line">| c    | 17   |</span><br><span class="line">| d    | NULL |</span><br><span class="line">| e    |      |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">count</span>(<span class="keyword">name</span>), <span class="keyword">count</span>(<span class="number">1</span>), <span class="keyword">count</span>(*), <span class="keyword">count</span>(age), <span class="keyword">count</span>(<span class="keyword">distinct</span>(age))</span><br><span class="line">    -&gt; <span class="keyword">from</span> counttest</span><br><span class="line">    -&gt; <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br><span class="line">+<span class="comment">------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line">| name | count(name) | count(1) | count(*) | count(age) | count(distinct(age)) |</span><br><span class="line">+<span class="comment">------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line">| a    |           3 |        3 |        3 |          3 |                    2 |</span><br><span class="line">| b    |           2 |        2 |        2 |          1 |                    1 |</span><br><span class="line">| c    |           1 |        1 |        1 |          1 |                    1 |</span><br><span class="line">| d    |           1 |        1 |        1 |          0 |                    0 |</span><br><span class="line">| e    |           1 |        1 |        1 |          1 |                    1 |</span><br><span class="line">+<span class="comment">------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/iFuMI/article/details/77920767&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;count(1)、count(*) 与 count(列名) 的执行区别&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>从头到尾说一次Java垃圾回收</title>
    <link href="https://mlone.top/2019/09/17/%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E8%AF%B4%E4%B8%80%E6%AC%A1Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://mlone.top/2019/09/17/从头到尾说一次Java垃圾回收/</id>
    <published>2019-09-17T13:14:23.000Z</published>
    <updated>2019-09-17T13:46:34.829Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247490759&amp;idx=2&amp;sn=0cd99a4f54f66b605399974efde40f0b&amp;chksm=eb5399f1dc2410e799ac385a710a23ac18b9b6b05f7f5b0a5ebc544e747e8e8f5cfc08309c2e&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568290753693&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">从头到尾说一次 Java 垃圾回收，写得非常好！</a><br><a id="more"></a></p><p>　　之前上学的时候有这个一个梗，说在食堂里吃饭，吃完把餐盘端走清理的，是 C++ 程序员，吃完直接就走的，是 Java 程序员。🤔</p><p>　　确实，在 Java 的世界里，似乎我们不用对垃圾回收那么的专注，很多初学者不懂 GC，也依然能写出一个能用甚至还不错的程序或系统。但其实这并不代表 Java 的 GC 就不重要。相反，它是那么的重要和复杂，以至于出了问题，那些初学者除了打开 GC 日志，看着一堆0101的天文，啥也做不了。😯</p><p>　　今天我们就从头到尾完整地聊一聊 Java 的垃圾回收。</p><h2 id="1-什么是垃圾回收"><a href="#1-什么是垃圾回收" class="headerlink" title="1. 什么是垃圾回收"></a>1. 什么是垃圾回收</h2><p>　　垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p><p>　　Java 语言出来之前，大家都在拼命的写 C 或者 C++ 的程序，而此时存在一个很大的矛盾，C++ 等语言创建对象要不断的去开辟空间，不用的时候又需要不断的去释放控件，既要写构造函数，又要写析构函数，很多时候都在重复的 allocated，然后不停的析构。于是，有人就提出，能不能写一段程序实现这块功能，每次创建，释放控件的时候复用这段代码，而无需重复的书写呢？</p><p>　　1960年，基于 MIT 的 Lisp 首先提出了垃圾回收的概念，而这时 Java 还没有出世呢！<strong>所以实际上 GC 并不是Java的专利，GC 的历史远远大于 Java 的历史！</strong></p><h2 id="2-怎么定义垃圾"><a href="#2-怎么定义垃圾" class="headerlink" title="2.  怎么定义垃圾"></a>2.  怎么定义垃圾</h2><p>　　既然我们要做垃圾回收，首先我们得搞清楚垃圾的定义是什么，哪些内存是需要回收的。</p><h3 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h3><p>　　引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。<br>　　<code>String m = new String(&quot;jack&quot;);</code></p><p>　　先创建一个字符串，这时候”jack”有一个引用，就是 m：<br>　　<img src="/blogImg/2019/9/17/2-1.png" alt></p><p>　　然后将 m 设置为 null，这时候”jack”的引用次数就等于0了，在引用计数算法中，意味着这块内容就需要被回收了。<br>　　<code>m = null;</code><br>　　<img src="/blogImg/2019/9/17/2-2.png" alt></p><p>　　引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，采用引用计数的垃圾收集不属于严格意义上的”Stop-The-World”的垃圾收集机制。</p><p>　　看似很美好，但我们知道JVM的垃圾回收就是”Stop-The-World”的，那是什么原因导致我们最终放弃了引用计数算法呢？看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountingGC</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objA"</span>);</span><br><span class="line">    ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objB"</span>);</span><br><span class="line"></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>定义2个对象</li><li>相互引用</li><li>置空各自的声明引用</li></ol></blockquote><p>　　<img src="/blogImg/2019/9/17/2-3.png" alt><br>　　我们可以看到，最后这2个对象已经不可能再被访问了，但由于他们相互引用着对方，导致它们的引用计数永远都不会为0，通过引用计数算法，也就永远无法通知GC收集器回收它们。</p><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>　　可达性分析算法（Reachability Analysis）的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。<br>　　<img src="/blogImg/2019/9/17/2-4.png" alt><br>　　通过可达性算法，成功解决了引用计数所无法解决的问题-“循环依赖”，只要你无法与 GC Root 建立直接或间接的连接，系统就会判定你为可回收对象。那这样就引申出了另一个问题，哪些属于 GC Root。</p><h2 id="3-Java-内存区域"><a href="#3-Java-内存区域" class="headerlink" title="3. Java 内存区域"></a>3. Java 内存区域</h2><p>在 Java 语言中，可作为 GC Root 的对象包括以下4种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><p>　　<img src="/blogImg/2019/9/17/2-5.png" alt></p><h3 id="3-1-虚拟机栈（栈帧中的本地变量表）中引用的对象"><a href="#3-1-虚拟机栈（栈帧中的本地变量表）中引用的对象" class="headerlink" title="3.1 虚拟机栈（栈帧中的本地变量表）中引用的对象"></a>3.1 虚拟机栈（栈帧中的本地变量表）中引用的对象</h3><p>　　此时的 s，即为 GC Root，当s置空时，localParameter 对象也断掉了与 GC Root 的引用链，将被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackLocalParameter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackLocalParameter</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StackLocalParameter s = <span class="keyword">new</span> StackLocalParameter(<span class="string">"localParameter"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-方法区中类静态属性引用的对象"><a href="#3-2-方法区中类静态属性引用的对象" class="headerlink" title="3.2 方法区中类静态属性引用的对象"></a>3.2 方法区中类静态属性引用的对象</h3><p>　　s 为 GC Root，s 置为 null，经过 GC 后，s 所指向的 properties 对象由于无法与 GC Root 建立关系被回收。</p><p>　　而 m 作为类的静态属性，也属于 GC Root，parameter 对象依然与 GC root 建立着连接，所以此时 parameter 对象并不会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaStaicProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodAreaStaicProperties m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAreaStaicProperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"properties"</span>);</span><br><span class="line">    s.m = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"parameter"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-方法区中常量引用的对象"><a href="#3-3-方法区中常量引用的对象" class="headerlink" title="3.3 方法区中常量引用的对象"></a>3.3 方法区中常量引用的对象</h3><p>　　m 即为方法区中的常量引用，也为 GC Root，s 置为 null 后，final 对象也不会因没有与 GC Root 建立联系而被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaStaicProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodAreaStaicProperties m = MethodAreaStaicProperties(<span class="string">"final"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAreaStaicProperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"staticProperties"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-4-本地方法栈中引用的对象"><a href="#3-4-本地方法栈中引用的对象" class="headerlink" title="3.4 本地方法栈中引用的对象"></a>3.4 本地方法栈中引用的对象</h3><p>　　任何 Native 接口都会使用某种本地方法栈，实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。<br>　　<img src="/blogImg/2019/9/17/2-6.png" alt></p><h2 id="4-怎么回收垃圾"><a href="#4-怎么回收垃圾" class="headerlink" title="4. 怎么回收垃圾"></a>4. 怎么回收垃圾</h2><p>　　在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，这里我们讨论几种常见的垃圾收集算法的核心思想。</p><h3 id="4-1-标记-—-清除算法"><a href="#4-1-标记-—-清除算法" class="headerlink" title="4.1 标记 — 清除算法"></a>4.1 标记 — 清除算法</h3><p>　　<img src="/blogImg/2019/9/17/2-7.png" alt><br>　　标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。</p><p>　　这逻辑再清晰不过了，并且也很好操作，但它存在一个很大的问题，那就是内存碎片。</p><p>　　上图中等方块的假设是 2M，小一些的是 1M，大一些的是 4M。等我们回收完，内存就会切成了很多段。我们知道开辟内存空间时，需要的是连续的内存区域，这时候我们需要一个 2M的内存区域，其中有2个 1M 是没法用的。这样就导致，其实我们本身还有这么多的内存的，但却用不了。</p><h3 id="4-2-复制算法"><a href="#4-2-复制算法" class="headerlink" title="4.2 复制算法"></a>4.2 复制算法</h3><p>　　<img src="/blogImg/2019/9/17/2-8.png" alt><br>　　复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。</p><p>　　上面的图很清楚，也很明显的暴露了另一个问题，合着我这140平的大三房，只能当70平米的小两房来使？代价实在太高。</p><h3 id="4-3-标记整理算法"><a href="#4-3-标记整理算法" class="headerlink" title="4.3 标记整理算法"></a>4.3 标记整理算法</h3><p>　　<img src="/blogImg/2019/9/17/2-9.png" alt><br>　　标记整理算法（Mark-Compact）标记过程仍然与标记 — 清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p><p>　　标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。</p><p>　　分代收集算法分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记 — 整理算法来进行回收。so，另一个问题来了，那内存区域到底被分为哪几块，每一块又有什么特别适合什么算法呢？</p><h2 id="5-内存模型与回收策略"><a href="#5-内存模型与回收策略" class="headerlink" title="5. 内存模型与回收策略"></a>5. 内存模型与回收策略</h2><p>　　<img src="/blogImg/2019/9/17/2-10.png" alt><br>　　Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，这里我们主要分析一下 Java 堆的结构。</p><p>　　Java 堆主要分为2个区域-年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。可能这时候大家会有疑问，为什么需要 Survivor区，为什么Survivor还要分2个区。不着急，我们从头到尾，看看对象到底是怎么来的，而它又是怎么没的。　　</p><h3 id="5-1-Eden-区"><a href="#5-1-Eden-区" class="headerlink" title="5.1 Eden 区"></a>5.1 Eden 区</h3><p>　　IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。</p><p>　　通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。</p><h3 id="5-2-Survivor-区"><a href="#5-2-Survivor-区" class="headerlink" title="5.2 Survivor 区"></a>5.2 Survivor 区</h3><p>　　Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。</p><p><strong>为啥需要？</strong><br>　　不就是新生代到老年代么，直接 Eden 到 Old 不好了吗，为啥要这么复杂。想想如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。</p><p>　　所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p><p><strong> 为啥需要俩？</strong><br>　　设置两个 Survivor 区最大的好处就是解决内存碎片化。</p><p>　　我们先假设一下，Survivor 如果只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。</p><p>　　这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。</p><h3 id="5-3-Old-区"><a href="#5-3-Old-区" class="headerlink" title="5.3 Old 区"></a>5.3 Old 区</h3><p>　　老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记 — 整理算法。</p><p>　　除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。</p><p><strong>大对象</strong><br>　　大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。</p><p><strong> 长期存活对象 </strong><br>　　虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。</p><p><strong>动态对象年龄</strong><br>　虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。</p><p>　　这其实有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机的硬件不通，健康状况不同，我们还可以基于每台机接受的请求数，或每台机的响应时间等，来调整我们的负载均衡算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247490759&amp;amp;idx=2&amp;amp;sn=0cd99a4f54f66b605399974efde40f0b&amp;amp;chksm=eb5399f1dc2410e799ac385a710a23ac18b9b6b05f7f5b0a5ebc544e747e8e8f5cfc08309c2e&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1568290753693&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从头到尾说一次 Java 垃圾回收，写得非常好！&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
