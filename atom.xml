<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Easygo_Space</title>
  
  <subtitle>The quick brown fox jumps over the lazy dog.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mlone.top/"/>
  <updated>2019-09-19T14:02:13.390Z</updated>
  <id>https://mlone.top/</id>
  
  <author>
    <name>easy go</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式锁面试题一</title>
    <link href="https://mlone.top/2019/09/19/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
    <id>https://mlone.top/2019/09/19/分布式锁面试题一/</id>
    <published>2019-09-19T13:56:28.000Z</published>
    <updated>2019-09-19T14:02:13.390Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;mid=2247484012&amp;idx=2&amp;sn=38875256a8e8a618f37ff59fa93a4901&amp;chksm=ec294245db5ecb530b51f8532a7e2945cd663c01464b5d9a3a799c580200f1dcb3df1919894b&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568036276371&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">每日3分钟技术干货 | 面试题+答案 | 分布式锁篇(一)</a><br><a id="more"></a><br>　　<br>　　paragraph…<br>　　paragraph…</p><blockquote><p>为什么要使用分布式锁？</p></blockquote><p>　　为了保证一个方法在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。</p><p><strong> 下面介绍JAVA分布式锁的三种常用实现方式：</strong></p><h3 id="1-基于数据库实现分布式锁"><a href="#1-基于数据库实现分布式锁" class="headerlink" title="1. 基于数据库实现分布式锁"></a>1. 基于数据库实现分布式锁</h3><p>　　要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录.</p><p>　　具体操作就是在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><p>　　上面这种简单的实现有以下几个问题：</p><ol><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ol><p>　　当然，我们也可以有其他方式解决上面的问题。</p><p>　　数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</p><p>　　没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</p><p>　　非阻塞的？搞一个while循环，直到insert成功再返回成功。</p><p>　　非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</p><p>　　优点：借助数据库，方案简单。</p><p>　　缺点：在实际实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑</p><h3 id="2-基于Redis实现分布式锁"><a href="#2-基于Redis实现分布式锁" class="headerlink" title="2. 基于Redis实现分布式锁"></a>2. 基于Redis实现分布式锁</h3><p>　　在Redis2.6.12版本之前，使用setnx命令设置key-value、使用expire命令设置key的过期时间获取分布式锁，使用del命令释放分布式锁，但是这种实现有如下一些问题：</p><p>　　setnx命令设置完key-value后，还没来得及使用expire命令设置过期时间，当前线程挂掉了，会导致当前线程设置的key一直有效，后续线程无法正常通过setnx获取锁，造成死锁。</p><p>　　出现这个问题是因为两个命令是分开执行并且不具备原子特性，如果能将这两个命令合二为一就可以解决问题了。在Redis2.6.12版本中实现了这个功能，Redis为set命令增加了一系列选项。也就是说现在set命令就可以实现分布式锁，下面我们来了解一下set命令（set(keyName, lockValue, “NX”, “EX”, expireSeconds)）：  </p><ol><li>SET命令是原子性操作，NX指令保证只要当key不存在时才会设置value</li><li>设置的value要有唯一性，来确保锁不会被误删(value=系统时间戳+UUID)</li><li>当上述命令执行返回OK时，客户端获取锁成功，否则失败</li><li>客户端可以通过redis释放脚本来释放锁（del 命令）<br>5.如果锁到达了最大生存时间将会自动释放</li></ol><p>　　只有当前key的value和传入的value相同才会执行DEL命令。</p><p>　　优点：高性能，借助Redis实现比较方便。</p><p>　　缺点：线程获取锁后，如果处理时间过长会导致锁超时失效(失效时间我设置多长时间为好？如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。这个问题使用数据库实现分布式锁同样存在)，所以，通过超时时间来控制锁的失效时间并不是十分的靠谱。</p><h3 id="3-基于Zookeeper实现分布式锁"><a href="#3-基于Zookeeper实现分布式锁" class="headerlink" title="3. 基于Zookeeper实现分布式锁"></a>3. 基于Zookeeper实现分布式锁</h3><p>　　ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>　　基于ZooKeeper实现分布式锁的步骤如下：</p><p>　　创建一个目录mylock； </p><p>　　线程A想获取锁就在mylock目录下创建临时顺序节点； </p><p>　　获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁； </p><p>　　线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点； </p><p>　　线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。 </p><p>　　优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。具体说明如下：</p><p>　　锁无法释放，造成死锁！使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p><p>　　阻塞锁特性！使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p><p>　　可重入！使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p><p>　　单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p><p>　　缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>　　上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4OTkwNDk2Ng==&amp;amp;mid=2247484012&amp;amp;idx=2&amp;amp;sn=38875256a8e8a618f37ff59fa93a4901&amp;amp;chksm=ec294245db5ecb530b51f8532a7e2945cd663c01464b5d9a3a799c580200f1dcb3df1919894b&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1568036276371&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每日3分钟技术干货 | 面试题+答案 | 分布式锁篇(一)&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://mlone.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的Unsafe与CAS</title>
    <link href="https://mlone.top/2019/09/19/Java%E4%B8%AD%E7%9A%84Unsafe%E4%B8%8ECAS/"/>
    <id>https://mlone.top/2019/09/19/Java中的Unsafe与CAS/</id>
    <published>2019-09-19T13:36:24.000Z</published>
    <updated>2019-09-19T13:48:34.581Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.cnblogs.com/xrq730/p/4976007.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4976007.html</a><br><a id="more"></a></p><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>　　简单讲一下这个类。Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的<strong>原子操作</strong>。</p><p>　　这个类尽管里面的方法都是public的，但是并没有办法使用它们，JDK API文档也没有提供任何关于这个类的方法的解释。总而言之，对于Unsafe类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然JDK库里面的类是可以随意使用的。</p><p>　　从第一行的描述可以了解到Unsafe提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过Java本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。</p><p>举两个例子，比方说：</p><pre><code>public native long staticFieldOffset(Field paramField);</code></pre><p>　　这个方法可以用来获取给定的paramField的内存地址偏移量，这个值对于给定的field是唯一的且是固定不变的。再比如说：</p><pre><code>public native int arrayBaseOffset(Class paramClass);public native int arrayIndexScale(Class paramClass);</code></pre><p>　　前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。最后看三个方法：</p><pre><code>public native long allocateMemory(long paramLong);public native long reallocateMemory(long paramLong1, long paramLong2);public native void freeMemory(long paramLong);</code></pre><p>　　分别用来分配内存，扩充内存和释放内存的。</p><p>　　当然这需要有一定的C/C++基础，对内存分配有一定的了解，这也是为什么我一直认为C/C++开发者转行做Java会有优势的原因。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>　　CAS，Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，java.util.concurrent包全完建立在CAS之上，没有CAS也就没有此包，可见CAS的重要性。</p><p>　　当前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。<span style="color: red;">CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。</span></p><p>　　CAS也是通过Unsafe实现的，看下Unsafe下的三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2, <span class="keyword">long</span> paramLong3)</span></span>;</span><br></pre></td></tr></table></figure></p><p>　　就拿中间这个比较并交换Int值为例好了，如果我们不用CAS，那么代码大致是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = j;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　当然这段代码在并发下是肯定有问题的，有可能线程1运行到了第5行正准备运行第7行，线程2运行了，把i修改为10，线程切换回去，线程1由于先前已经满足第5行的if了，所以导致两个线程同时修改了变量i。</p><p>　　解决办法也很简单，给compareAndSwapInt方法加锁同步就行了，这样，compareAndSwapInt方法就变成了一个原子操作。CAS也是一样的道理，比较、交换也是一组原子操作，不会被外部打断，先根据paramLong/paramLong1获取到内存当中当前的内存值V，在将内存值V和原值A作比较，要是相等就修改为要修改的值B，由于CAS都是硬件级别的操作，因此效率会高一些。</p><h2 id="由CAS分析AtomicInteger原理"><a href="#由CAS分析AtomicInteger原理" class="headerlink" title="由CAS分析AtomicInteger原理"></a>由CAS分析AtomicInteger原理</h2><p>　　java.util.concurrent.atomic包下的原子操作类都是基于CAS实现的，下面拿AtomicInteger分析一下，首先是AtomicInteger类变量的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">    valueOffset = unsafe.objectFieldOffset</span><br><span class="line">        (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure></p><p>　　关于这段代码中出现的几个成员属性：</p><ol><li><p>Unsafe是CAS的核心类，前面已经讲过了</p></li><li><p>valueOffset表示的是变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的原值的</p></li><li><p>value是用volatile修饰的，这是非常关键的</p></li></ol><p>　　下面找一个方法getAndIncrement来研究一下AtomicInteger是如何实现的，比如我们常用的addAndGet方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + delta;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　这段代码如何在不加锁的情况下通过CAS实现线程安全，我们不妨考虑一下方法的执行：</p><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据Java内存模型，线程1和线程2各自持有一份value的副本，值为3</li><li>线程1运行到第三行获取到当前的value为3，线程切换</li><li>线程2开始运行，获取到value为3，利用CAS对比内存中的值也为3，比较成功，修改内存，此时内存中的value改变比方说是4，线程切换</li><li>线程1恢复运行，利用CAS比较发现自己的value为3，内存中的value为4，得到一个重要的结论–&gt;<span style="color: red;">此时value正在被另外一个线程修改，所以我不能去修改它</span></li><li>线程1的compareAndSet失败，循环判断，因为value是volatile修饰的，所以它具备可见性的特性，线程2对于value的改变能被线程1看到，只要线程1发现当前获取的value是4，内存中的value也是4，说明<span style="color: red;">线程2对于value的修改已经完毕并且线程1可以尝试去修改它</span></li><li>最后说一点，比如说此时线程3也准备修改value了，没关系，因为比较-交换是一个原子操作不可被打断，线程3修改了value，线程1进行compareAndSet的时候必然返回的false，这样线程1会继续循环去获取最新的value并进行compareAndSet，直至获取的value和内存中的value一致为止</li></ol><p>　　整个过程中，利用CAS机制保证了对于value的修改的线程安全性。</p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p>　　CAS看起来很美，但这种操作显然无法涵盖并发下的所有场景，并且CAS从语义上来说也不是完美的，存在这样一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个漏洞称为CAS操作的”ABA”问题。java.util.concurrent包为了解决这个问题，提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较”鸡肋”，大部分情况下ABA问题并不会影响程序并发的正确性，如果需要解决ABA问题，使用传统的互斥同步可能回避原子类更加高效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://www.cnblogs.com/xrq730/p/4976007.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/xrq730/p/4976007.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock之公平锁源码分析</title>
    <link href="https://mlone.top/2019/09/19/ReentrantLock%E4%B9%8B%E5%85%AC%E5%B9%B3%E9%94%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://mlone.top/2019/09/19/ReentrantLock之公平锁源码分析/</id>
    <published>2019-09-19T13:09:59.000Z</published>
    <updated>2019-09-19T13:34:07.599Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s/S_mzc5dy89GwFnNUqaTu2Q" target="_blank" rel="noopener">ReentrantLock 之公平锁源码分析</a><br><a id="more"></a></p><p>　　本文分析的ReentrantLock所对应的Java版本为JDK8。<br>　　在阅读本文前，读者应该知道什么是CAS、自旋。</p><p><strong>本文大纲</strong></p><ol><li>ReentrantLock公平锁简介</li><li>AQS</li><li>lock方法</li><li>unlock方法</li></ol><h2 id="1-ReentrantLock公平锁简介"><a href="#1-ReentrantLock公平锁简介" class="headerlink" title="1. ReentrantLock公平锁简介"></a>1. ReentrantLock公平锁简介</h2><p>　　ReentrantLock是JUC（java.util.concurrent）包中Lock接口的一个实现类，它是基于AbstractQueuedSynchronizer（下文简称AQS）来实现锁的功能。ReentrantLock的内部类Sync继承了AbstractQueuedSynchronizer，Sync又有FairSync和NonFairSync两个子类。FairSync实现了公平锁相关的操作，NonFairSync实现了非公平锁相关的操作。它们之间的关系如下：<br>　　<img src="/blogImg/2019/9/19/1-1.png" alt></p><p>　　公平锁的公平之处主要体现在，对于一个新来的线程，如果锁没有被占用，它会判断等待队列中是否还有其它的等待线程，如果有的话，就加入等待队列队尾，否则就去抢占锁。</p><p>下面这段代码展示了公平锁的使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">// 参数true代表创建公平锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// ... method body</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2. AQS"></a>2. AQS</h2><p>　　下面简单介绍一下AQS中的Node内部类和几个重要的成员变量。</p><h3 id="2-1-Node"><a href="#2-1-Node" class="headerlink" title="2.1 Node"></a>2.1 Node</h3><p>　　AQS中，维护了一个Node内部类，用于包装我们的线程。我们需要关注Node中的如下属性：</p><ul><li>pre：当前节点的前驱节点。</li><li>next：当前节点的后继节点。</li><li>thread：thread表示被包装的线程。</li><li><p>waitStatus：waitStatus是一个int整型，可以被赋予如下几种值：</p><pre><code>static final int CANCELLED =  1; // 线程被取消static final int SIGNAL  = -1; // 后继节点中的线程需要被唤醒static final int CONDITION = -2; // 暂不关注static final int PROPAGATE = -3; // 暂不关注</code></pre></li></ul><p>另外，当一个新的Node被创建时，waitStatus是0。</p><h3 id="2-2-head"><a href="#2-2-head" class="headerlink" title="2.2 head"></a>2.2 head</h3><p>　　head指向队列中的队首元素，可以理解为当前持有锁的线程。</p><h3 id="2-3-tail"><a href="#2-3-tail" class="headerlink" title="2.3 tail"></a>2.3 tail</h3><p>　　tail指向队列中的队尾元素。</p><h3 id="2-4-state"><a href="#2-4-state" class="headerlink" title="2.4 state"></a>2.4 state</h3><p>　　state表示在ReentrantLock中可以理解为锁的状态，0表示当前锁没有被占用，大于0的数表示锁被当前线程重入的次数。例如，当state等于2时，表示当前线程在这把锁上进入了两次。</p><h3 id="2-5-exclusiveOwnerThread"><a href="#2-5-exclusiveOwnerThread" class="headerlink" title="2.5 exclusiveOwnerThread"></a>2.5 exclusiveOwnerThread</h3><p>　　表示当前占用锁的线程。</p><h3 id="2-6-等待队列"><a href="#2-6-等待队列" class="headerlink" title="2.6 等待队列"></a>2.6 等待队列</h3><p>　　下图简单展示了AQS中的等待队列：<br>　　<img src="/blogImg/2019/9/19/1-2.png" alt></p><h2 id="3-lock方法"><a href="#3-lock方法" class="headerlink" title="3. lock方法"></a>3. lock方法</h2><p>　　有了上面的AQS的基础知识后，我们就可以展开对ReentrantLock公平锁的分析了，先从lock方法入手。</p><p>　　ReentrantLock中的lock方法很简单，只是调用了Sync类（本文研究公平锁，所以应该是FairSync类）中的lock方法：</p><pre><code>public void lock() {    sync.lock();}</code></pre><p>　　我们跟到FairSync的lock方法，代码也很简单，调用了AQS中的acquire方法：</p><pre><code>final void lock() {    acquire(1);}</code></pre><p>　　acquire方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 调用tryAcquire尝试去获取锁，如果获取成功，则方法结束</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 如果获取锁失败，执行acquireQueued方法，将把当前线程排入队尾</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　tryAcquire方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">// 获取锁的状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果状态是0，表示锁没有被占用</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">// 判断是队列中是否有排队中的线程</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 队列中没有排队的线程，则尝试用CAS去获取一下锁</span></span><br><span class="line">            setExclusiveOwnerThread(current); <span class="comment">// 获取锁成功，则将当前占有锁的线程设置为当前线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁被占用、队列中有排队的线程或者当前线程在获取锁的时候失败将执行下面的代码</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 当前线程是否是占有锁的线程</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">// 是的话，表示当前线程是重入这把锁，将锁的状态进行加1</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>); <span class="comment">// 锁的重入次数超过int能够表示最大的值，抛出异常</span></span><br><span class="line">        setState(nextc); <span class="comment">// 设置锁的状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 没有获取到锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　hasQueuedPredecessors方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; <span class="comment">// 队列中的队首和队尾元素不相同</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread()); <span class="comment">// 队列中的第二个元素不为null，且第二个元素中的线程不是当前线程。这里如果返回true，说明队列中至少存在tail、head两个节点，就会执行acquireQueued将当前线程加入队尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如果tryAcquire没有获取到锁，将执行：</p><pre><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code></pre><p>　　我们先分析addWaiter方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">// 将当前线程包装成Node，mode参数值为null，表示独占模式</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred; <span class="comment">// 如果队列中的尾节点不为空，将当前node的前驱节点设置为之前队列中的tail</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 用CAS把当前node设置为队尾元素</span></span><br><span class="line">            pred.next = node; <span class="comment">// 成功的话，则将之前队尾元素的后继节点设置为当前节点。如果这里不清楚的话，请结合前面讲等待队列的那张图进行理解。</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 队尾节点为空，或者用CAS设置队尾元素失败，则用自旋的方式入队</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　enq方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 队尾元素为空，创建一个空的Node，并设置为队首</span></span><br><span class="line">                tail = head; <span class="comment">// 设置队首和队尾为同一个空Node，进入下一次循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t; <span class="comment">// 如果队列中的尾节点不为空，将当前node的前驱节点设置为之前队列中的tail</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 用CAS把当前node设置为队尾元素</span></span><br><span class="line">                t.next = node; <span class="comment">// 成功的话，则将之前队尾元素的后继节点设置为当前节点</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　下面这张图反应了上面enq方法的处理流程：<br>　　<img src="/blogImg/2019/9/19/1-3.png" alt></p><p>　　经过上面的方法，当前node已经加入等待队列的队尾，接下来将执行acquireQueued方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获取node的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果node的前驱是head，它将去尝试获取锁（tryAcquire方法在前面已经分析过）</span></span><br><span class="line">                setHead(node); <span class="comment">// 获取成功，则将node设置为head</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// 将之前的head的后继节点置空</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 当前node的前驱不是head，将为当前node找到一个能够将其唤醒的前驱节点；或者当前node的前驱是head，但是获取锁失败</span></span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 将当前线程挂起</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　shouldParkAfterFailedAcquire方法的作用就是找到一个能够唤醒当前node的节点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 开始时是0</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 前驱节点的状态是-1，会唤醒后继节点，可以将线程挂起</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev; <span class="comment">// 前驱节点中的线程被取消，那就需要一直循环直到找到一个没有被设置为取消状态的前驱节点</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node; <span class="comment">// 从后向前找，将第一个非取消状态的节点，设置这个节点的后继节点设置为当前node</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// waitStatus是0或者-3的时候，这时waitStatus都将被设置为-1</span></span><br><span class="line">                                                        <span class="comment">// 即后继节点需要前驱节点唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 上层代码再进行一次循环，下次进入此方法时，将进入第一个if条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　找到了合适的前驱节点，parkAndCheckInterrupt方法当前线程挂起：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123; <span class="comment">// 将线程挂起，等待前驱节点的唤醒</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-unlock方法"><a href="#4-unlock方法" class="headerlink" title="4. unlock方法"></a>4. unlock方法</h2><p>　　ReentrantLock的unlock方法调用AQS中的release方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>); <span class="comment">// 调用AQS的release方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　release方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 尝试去释放锁</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 释放锁成功，head不为空，并且head的waitStatus不为0的情况下，将唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　tryRelease方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 将锁的状态减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(); <span class="comment">// 准备释放锁的线程不是持有锁的线程，抛出异常</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>; <span class="comment">// 锁的状态是0，说明不存在重入的情况了，可以直接释放了</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　锁释放成功，将唤醒后继节点，unparkSuccessor方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus; <span class="comment">// 注意，这个node是head节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 当前node的状态是小于0，将其状态设置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next; <span class="comment">// head节点的后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>; <span class="comment">// 执行到这表示head的后继节点是1，处于取消的状态</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t; <span class="comment">// 从等待队列的队尾向前找，找到倒序的最后一个处于非取消状态的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">// 唤醒head后面的处于非取消状态的第一个（正序）节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s/S_mzc5dy89GwFnNUqaTu2Q&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReentrantLock 之公平锁源码分析&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux最常用命令</title>
    <link href="https://mlone.top/2019/09/18/Linux%E6%9C%80%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://mlone.top/2019/09/18/Linux最常用命令/</id>
    <published>2019-09-18T13:42:01.000Z</published>
    <updated>2019-09-18T14:02:06.248Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://blog.csdn.net/xulong_08/article/list/" target="_blank" rel="noopener">https://blog.csdn.net/xulong_08/article/list/</a><br><a id="more"></a></p><h2 id="一、linux的目录结构"><a href="#一、linux的目录结构" class="headerlink" title="一、linux的目录结构"></a>一、linux的目录结构</h2><p>　　<img src="/blogImg/2019/9/18/1-1.png" alt></p><ul><li>bin (binaries)存放二进制可执行文件</li><li>sbin (super user binaries)存放二进制可执行文件，只有root才能访问</li><li>etc (etcetera)存放系统配置文件</li><li>usr (unix shared resources)用于存放共享的系统资源</li><li>home 存放用户文件的根目录</li><li>root 超级用户目录</li><li>dev (devices)用于存放设备文件</li><li>lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块</li><li>mnt (mount)系统管理员安装临时文件系统的安装点</li><li>boot 存放用于系统引导时使用的各种文件</li><li>tmp (temporary)用于存放各种临时文件</li><li>var (variable)用于存放运行时需要改变数据的文件</li></ul><h2 id="二、linux常用命令"><a href="#二、linux常用命令" class="headerlink" title="二、linux常用命令"></a>二、linux常用命令</h2><p><strong>命令格式</strong>：命令 -选项 参数 （选项和参数可以为空）<br>如：<code>ls -la /usr</code></p><h3 id="2-1-操作文件及目录"><a href="#2-1-操作文件及目录" class="headerlink" title="2.1 操作文件及目录"></a>2.1 操作文件及目录</h3><p>　　<img src="/blogImg/2019/9/18/1-2.png" alt></p><h3 id="2-2-系统常用命令"><a href="#2-2-系统常用命令" class="headerlink" title="2.2 系统常用命令"></a>2.2 系统常用命令</h3><p>　　<img src="/blogImg/2019/9/18/1-3.png" alt></p><h3 id="2-3-压缩解压缩"><a href="#2-3-压缩解压缩" class="headerlink" title="2.3 压缩解压缩"></a>2.3 压缩解压缩</h3><p>　　<img src="/blogImg/2019/9/18/1-4.png" alt></p><h3 id="2-4-文件权限操作"><a href="#2-4-文件权限操作" class="headerlink" title="2.4 文件权限操作"></a>2.4 文件权限操作</h3><ul><li>linux文件权限的描述格式解读<br>　　<img src="/blogImg/2019/9/18/1-5.png" alt>　　</li><li>r 可读权限，w可写权限，x可执行权限（也可以用二进制表示 111 110 100 –&gt; 764）</li><li>第1位：文件类型（d 目录，- 普通文件，l 链接文件）</li><li>第2-4位：所属用户权限，用u（user）表示</li><li>第5-7位：所属组权限，用g（group）表示</li><li>第8-10位：其他用户权限，用o（other）表示</li><li>第2-10位：表示所有的权限，用a（all）表示<br>　　<img src="/blogImg/2019/9/18/1-6.png" alt></li></ul><h2 id="三、linux系统常用快捷键及符号命令"><a href="#三、linux系统常用快捷键及符号命令" class="headerlink" title="三、linux系统常用快捷键及符号命令"></a>三、linux系统常用快捷键及符号命令</h2><p>　　<img src="/blogImg/2019/9/18/1-7.png" alt></p><h2 id="四、vim编辑器"><a href="#四、vim编辑器" class="headerlink" title="四、vim编辑器"></a>四、vim编辑器</h2><p>　　vi / vim是Linux上最常用的文本编辑器而且功能非常强大。只有命令，没有菜单，下图表示vi命令的各种模式的切换图：<br>　　<img src="/blogImg/2019/9/18/1-8.png" alt></p><h3 id="4-1-修改文本"><a href="#4-1-修改文本" class="headerlink" title="4.1 修改文本"></a>4.1 修改文本</h3><p>　　<img src="/blogImg/2019/9/18/1-9.png" alt></p><h3 id="4-2-定位命令"><a href="#4-2-定位命令" class="headerlink" title="4.2 定位命令"></a>4.2 定位命令</h3><p>　　<img src="/blogImg/2019/9/18/1-10.png" alt></p><h3 id="4-3-替换和取消命令"><a href="#4-3-替换和取消命令" class="headerlink" title="4.3 替换和取消命令"></a>4.3 替换和取消命令</h3><p>　　<img src="/blogImg/2019/9/18/1-11.png" alt></p><h3 id="4-4-删除命令"><a href="#4-4-删除命令" class="headerlink" title="4.4 删除命令"></a>4.4 删除命令</h3><p>　　<img src="/blogImg/2019/9/18/1-12.png" alt></p><h3 id="4-5-常用快捷键"><a href="#4-5-常用快捷键" class="headerlink" title="4.5 常用快捷键"></a>4.5 常用快捷键</h3><p>　　<img src="/blogImg/2019/9/18/1-13.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：&lt;a href=&quot;https://blog.csdn.net/xulong_08/article/list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/xulong_08/article/list/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://mlone.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>面试必备：Java线程池解析</title>
    <link href="https://mlone.top/2019/09/17/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%9AJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90/"/>
    <id>https://mlone.top/2019/09/17/面试必备：Java线程池解析/</id>
    <published>2019-09-17T14:02:24.000Z</published>
    <updated>2019-09-17T15:08:15.633Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14</a><br><a id="more"></a></p><h1 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h1><ul><li>面试问题1：Java的线程池说一下，各个参数的作用，如何进行的?</li><li>面试问题2：按线程池内部机制，当提交新任务时，有哪些异常要考虑。</li><li>面试问题3：线程池都有哪几种工作队列？</li><li>面试问题4：使用无界队列的线程池会导致内存飙升吗？</li><li>面试问题5：说说几种常见的线程池及使用场景?</li></ul><h1 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h1><p><strong> 线程池：</strong> 简单理解，它就是一个管理线程的池子。</p><ul><li><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li><li><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li><li><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li></ul><h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><p>　　线程池可以通过ThreadPoolExecutor来创建，我们来看一下它的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">   BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">   RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure></p><p>几个核心参数的作用：</p><ul><li><strong>corePoolSize：</strong> 线程池核心线程数最大值</li><li><strong>maximumPoolSize：</strong> 线程池最大线程数大小</li><li><strong>keepAliveTime：</strong> 线程池中非核心线程空闲的存活时间大小</li><li><strong>unit：</strong> 线程空闲存活时间单位</li><li><strong>workQueue：</strong> 存放任务的阻塞队列</li><li><strong>threadFactory：</strong> 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li><li><strong>handler：</strong>  线城池的饱和策略事件，主要有四种类型。</li></ul><h1 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h1><h2 id="线程池执行流程，即对应execute-方法："><a href="#线程池执行流程，即对应execute-方法：" class="headerlink" title="线程池执行流程，即对应execute()方法："></a>线程池执行流程，即对应execute()方法：</h2><p>　　<img src="/blogImg/2019/9/17/3-1.png" alt></p><ul><li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li><li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li><li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li><li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li></ul><h2 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h2><ul><li>AbortPolicy(抛出一个异常，默认的)</li><li>DiscardPolicy(直接丢弃任务)</li><li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li><li>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</li></ul><h2 id="为了形象描述线程池执行，我打个比喻："><a href="#为了形象描述线程池执行，我打个比喻：" class="headerlink" title="为了形象描述线程池执行，我打个比喻："></a>为了形象描述线程池执行，我打个比喻：</h2><ul><li><p>核心线程比作公司正式员工</p></li><li><p>非核心线程比作外包员工</p></li><li><p>阻塞队列比作需求池</p></li><li><p>提交任务比作提需求<br>　　<img src="/blogImg/2019/9/17/3-2.png" alt></p></li><li><p>当产品提个需求，正式员工（核心线程）先接需求（执行任务）</p></li><li>如果正式员工都有需求在做，即核心线程数已满），产品就把需求先放需求池（阻塞队列）。</li><li>如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。</li><li>如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。</li><li>如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</li></ul><p>　　好的，到这里。<strong>面试问题1-&gt;Java的线程池说一下，各个参数的作用，如何进行的?</strong> 是否已经迎刃而解啦， 我觉得这个问题，回答：<strong>线程池构造函数的corePoolSize,maximumPoolSize等参数，并且能描述清楚线程池的执行流程</strong> 就差不多啦。</p><h1 id="线程池异常处理"><a href="#线程池异常处理" class="headerlink" title="线程池异常处理"></a>线程池异常处理</h1><p>　　在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p><h2 id="当提交新任务时，异常如何处理"><a href="#当提交新任务时，异常如何处理" class="headerlink" title="当提交新任务时，异常如何处理?"></a>当提交新任务时，异常如何处理?</h2><p>我们先来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    threadPool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"current thread name"</span> + Thread.currentThread().getName());</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        System.out.print(<span class="string">"result## "</span>+object.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然，这段代码会有异常，我们再来看看执行结果：<br>　　<img src="/blogImg/2019/9/17/3-3.png" alt><br>　　虽然没有结果输出，但是没有抛出异常，所以我们无法感知任务出现了异常，所以需要添加try/catch。如下图：<br>　　<img src="/blogImg/2019/9/17/3-4.png" alt></p><p>　　OK，线程的异常处理，<strong>我们可以直接try…catch捕获。</strong>　</p><h2 id="线程池exec-submit-runnable-的执行流程"><a href="#线程池exec-submit-runnable-的执行流程" class="headerlink" title="线程池exec.submit(runnable)的执行流程"></a>线程池exec.submit(runnable)的执行流程</h2><p>　　通过debug上面有异常的submit方法（<strong>建议大家也去debug看一下,图上的每个方法内部是我打断点的地方</strong>），处理有异常submit方法的主要执行流程图：<br>　　<img src="/blogImg/2019/9/17/3-5.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造feature对象</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">       <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">       execute(ftask);</span><br><span class="line">       <span class="keyword">return</span> ftask;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">       <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//线程池执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">              <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//捕获异常</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)</span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>　　通过以上分析，submit执行的任务，可以通过Future对象的get方法接收抛出的异常，再进行处理。 我们再通过一个demo，看一下Future对象的get方法处理异常的姿势，如下图：<br>　　<img src="/blogImg/2019/9/17/3-6.png" alt></p><h2 id="其他两种处理线程池异常方案"><a href="#其他两种处理线程池异常方案" class="headerlink" title="其他两种处理线程池异常方案"></a>其他两种处理线程池异常方案</h2><p>除了以上<strong>1. 在任务代码try/catch捕获异常，2. 通过Future对象的get方法接收抛出的异常，再处理</strong>两种方案外，还有以下两种方案：</p><h3 id="3-为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常"><a href="#3-为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常" class="headerlink" title="3. 为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常"></a>3. 为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常</h3><p>我们直接看这样实现的正确姿势：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">1</span>, r -&gt; &#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">    t.setUncaughtExceptionHandler(</span><br><span class="line">            (t1, e) -&gt; &#123;</span><br><span class="line">                System.out.println(t1.getName() + <span class="string">"线程抛出的异常"</span>+e);</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">   &#125;);</span><br><span class="line">threadPool.execute(()-&gt;&#123;</span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    System.out.print(<span class="string">"result## "</span> + object.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-7.png" alt></p><h3 id="4-重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用"><a href="#4-重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用" class="headerlink" title="4. 重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用"></a>4. 重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用</h3><p>这是jdk文档的一个demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这可是jdk文档里面给的例子。。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> &amp;&amp; r <span class="keyword">instanceof</span> Future&lt;?&gt;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object result = ((Future&lt;?&gt;) r).get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException ce) &#123;</span><br><span class="line">                t = ce;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException ee) &#123;</span><br><span class="line">                t = ee.getCause();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); <span class="comment">// ignore/reset</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="因此，被问到线程池异常处理，如何回答？"><a href="#因此，被问到线程池异常处理，如何回答？" class="headerlink" title="因此，被问到线程池异常处理，如何回答？"></a>因此，被问到线程池异常处理，如何回答？</h2><p>　　<img src="/blogImg/2019/9/17/3-8.png" alt></p><h1 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h1><p><strong>线程池都有哪几种工作队列？</strong></p><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>　　ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>　　LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p><h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>　　DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p><h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>　　PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列。</p><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>　　SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。<br>　　<br>　　针对面试题：<strong>线程池都有哪几种工作队列？</strong> 我觉得，<strong>回答以上几种ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue等，说出它们的特点，并结合使用到对应队列的常用线程池(如newFixedThreadPool线程池使用LinkedBlockingQueue)，进行展开阐述，</strong> 就可以啦。　　</p><h1 id="几种常用的线程池"><a href="#几种常用的线程池" class="headerlink" title="几种常用的线程池"></a>几种常用的线程池</h1><ul><li>newFixedThreadPool (固定数目线程的线程池)</li><li>newCachedThreadPool(可缓存线程的线程池)</li><li>newSingleThreadExecutor(单线程的线程池)</li><li>newScheduledThreadPool(定时及周期执行的线程池)</li></ul><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池特点："><a href="#线程池特点：" class="headerlink" title="线程池特点："></a>线程池特点：</h3><ul><li>核心线程数和最大线程数大小一样</li><li>没有所谓的非空闲时间，即keepAliveTime为0</li><li>阻塞队列为无界队列LinkedBlockingQueue</li></ul><h3 id="工作机制："><a href="#工作机制：" class="headerlink" title="工作机制："></a>工作机制：</h3><p>　　<img src="/blogImg/2019/9/17/3-9.png" alt></p><ul><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li></ul><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            executor.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>IDE指定JVM参数：<code>-Xmx8m -Xms8m</code> :<br>　　<img src="/blogImg/2019/9/17/3-10.png" alt></p><p>run以上代码，会抛出OOM：<br>　　<img src="/blogImg/2019/9/17/3-11.png" alt></p><p>　　<br>因此，<strong>面试题：使用无界队列的线程池会导致内存飙升吗？</strong></p><p>答案 <strong>：会的，newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长(比如，上面demo设置了10秒)，会导致队列的任务越积越多，导致机器内存使用不停飙升，</strong> 最终导致OOM。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池特点：-1"><a href="#线程池特点：-1" class="headerlink" title="线程池特点："></a>线程池特点：</h3><ul><li>核心线程数为0</li><li>最大线程数为Integer.MAX_VALUE</li><li>阻塞队列是SynchronousQueue</li><li>非核心线程空闲存活时间为60秒</li></ul><p>　　当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>　　<img src="/blogImg/2019/9/17/3-12.png" alt></p><ul><li>提交任务</li><li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ul><h3 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-13.png" alt></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　用于并发执行大量短期的小任务。</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池特点"><a href="#线程池特点" class="headerlink" title="线程池特点"></a>线程池特点</h3><ul><li>核心线程数为1</li><li>最大线程数也为1</li><li>阻塞队列是LinkedBlockingQueue</li><li>keepAliveTime为0</li></ul><h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><p>　　<img src="/blogImg/2019/9/17/3-14.png" alt></p><ul><li>提交任务</li><li>线程池是否有一条线程在，如果没有，新建线程执行任务</li><li>如果有，讲任务加到阻塞队列</li><li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</li></ul><h3 id="实例代码-2"><a href="#实例代码-2" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">     executor.execute(() -&gt; &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-15.png" alt></p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　适用于串行执行任务的场景，一个任务一个任务地执行。</p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池特点-1"><a href="#线程池特点-1" class="headerlink" title="线程池特点"></a>线程池特点</h3><ul><li>最大线程数为Integer.MAX_VALUE</li><li>阻塞队列是DelayedWorkQueue</li><li>keepAliveTime为0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><h3 id="工作机制-2"><a href="#工作机制-2" class="headerlink" title="工作机制"></a>工作机制</h3><ul><li>添加一个任务</li><li>线程池中的线程从 DelayQueue 中取任务</li><li>线程从 DelayQueue 中获取 time 大于等于当前时间的task</li><li>执行完后修改这个 task 的 time 为下次被执行的时间</li><li>这个 task 放回DelayQueue队列中</li></ul><h3 id="实例代码-3"><a href="#实例代码-3" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  创建一个给定初始延迟的间隔性的任务，之后的下次执行时间是上一次任务从执行到结束所需要的时间+* 给定的间隔时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">scheduledExecutorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"current Time"</span> + System.currentTimeMillis());</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-16.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  创建一个给定初始延迟的间隔性的任务，之后的每次任务执行时间为 初始延迟 + N * delay(间隔) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"current Time"</span> + System.currentTimeMillis());</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></p><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　周期性执行任务的场景，需要限制线程数量的场景</p><p>　　回到面试题：<strong>说说几种常见的线程池及使用场景？</strong></p><p>　　回答这四种经典线程池 <strong>：newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool，newScheduledThreadPool，分线程池特点，工作机制，使用场景分开描述，再分析可能存在的问题，比如newFixedThreadPool内存飙升问题</strong> 即可。</p><h1 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h1><p>线程池有这几个状态：<br>　　- RUNNING<br>　　- SHUTDOWN<br>　　- STOP<br>　　- TIDYING<br>　　- TERMINATED</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><h2 id="线程池各个状态切换图："><a href="#线程池各个状态切换图：" class="headerlink" title="线程池各个状态切换图："></a>线程池各个状态切换图：</h2><p>　　<img src="/blogImg/2019/9/17/3-17.png" alt></p><h3 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h3><ul><li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li><li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li><li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li></ul><h3 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h3><ul><li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</li></ul><h3 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h3><ul><li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>线程池中执行的任务为空,进入TIDYING状态;</li></ul><h3 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h3><ul><li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li><li>terminated()执行完毕，进入TERMINATED状态</li></ul><h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><ul><li>该状态表示线程池彻底终止</li></ul><h1 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h1><ul><li>Java线程池异常处理方案：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F30e488f4e021" target="_blank" rel="noopener">www.jianshu.com/p/30e488f4e…</a></li><li>Java线程池  <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2888" target="_blank" rel="noopener">www.hollischuang.com/archives/28…</a></li><li>关于线程池的面试题 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F9710b899e749" target="_blank" rel="noopener">www.jianshu.com/p/9710b899e…</a></li><li>线程池的五种状态 <a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fl_kanglin%2Farticle%2Fdetails%2F57411851" target="_blank" rel="noopener">blog.csdn.net/l_kanglin/a…</a></li><li>深入分析java线程池的实现原理 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F87bff5cc8d8c%2F" target="_blank" rel="noopener">www.jianshu.com/p/87bff5cc8…</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>count(1)、count(*)与count(列名)的执行区别</title>
    <link href="https://mlone.top/2019/09/17/count-1-%E3%80%81count-%E4%B8%8Ecount-%E5%88%97%E5%90%8D-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8C%BA%E5%88%AB/"/>
    <id>https://mlone.top/2019/09/17/count-1-、count-与count-列名-的执行区别/</id>
    <published>2019-09-17T13:40:28.000Z</published>
    <updated>2019-09-17T13:57:40.670Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/iFuMI/article/details/77920767" target="_blank" rel="noopener">count(1)、count(*) 与 count(列名) 的执行区别</a><br><a id="more"></a></p><h3 id="count-1-and-count"><a href="#count-1-and-count" class="headerlink" title="count(1) and count(*)"></a>count(1) and count(*)</h3><p>　　当表的数据量大些时，对表作分析之后，使用count(1)还要比使用count(*)用时多了！ </p><p>　　从执行计划来看，count(1)和count(<em>)的效果是一样的。但是在表做过分析之后，count(1)会比count(</em>)的用时少些（1w以内数据量），不过差不了多少。 </p><p>　　如果count(1)是聚索引,id,那肯定是count(1)快。但是差的很小的。 </p><p>　　因为count(<em>),自动会优化指定到那一个字段。所以没必要去count(1)，用count(</em>)，sql会帮你完成优化的 因此：<strong>count(1)和count(*)基本没有差别！ </strong></p><h3 id="count-1-and-count-字段"><a href="#count-1-and-count-字段" class="headerlink" title="count(1) and count(字段)"></a>count(1) and count(字段)</h3><p>两者的主要区别是：<br>　　1. count(1) 会统计表中的所有的记录数，包含字段为null 的记录。<br>　　2. count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 </p><h3 id="count-和-count-1-和count-列名"><a href="#count-和-count-1-和count-列名" class="headerlink" title="count(*) 和 count(1)和count(列名)"></a>count(*) 和 count(1)和count(列名)</h3><p><strong>执行效果上： </strong></p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，<strong>不会忽略列值为NULL</strong> ；</li><li>count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，<strong>不会忽略列值为NULL</strong> ；</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，<strong>即某个字段值为NULL时，不统计</strong>。</li></ul><p><strong>执行效率上： </strong></p><ul><li>列名为主键，count(列名)会比count(1)快 ；</li><li>列名不为主键，count(1)会比count(列名)快；</li><li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*） ；</li><li>如果有主键，则 <code>select count（主键）</code>的执行效率是最优的 ；</li><li>如果表只有一个字段，则<code>select count（*）</code>最优。</li></ul><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table counttest(name char(1), age char(2));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; insert into counttest values</span><br><span class="line">    -&gt; ('a', '14'),('a', '15'), ('a', '15'),</span><br><span class="line">    -&gt; ('b', NULL), ('b', '16'),</span><br><span class="line">    -&gt; ('c', '17'),</span><br><span class="line">    -&gt; ('d', null),</span><br><span class="line">    -&gt;('e', '');</span><br><span class="line">Query OK, 8 rows affected (0.01 sec)</span><br><span class="line">Records: 8  Duplicates: 0  Warnings: 0</span><br><span class="line"> </span><br><span class="line">mysql&gt; select * from counttest;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| name | age  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| a    | 14   |</span><br><span class="line">| a    | 15   |</span><br><span class="line">| a    | 15   |</span><br><span class="line">| b    | NULL |</span><br><span class="line">| b    | 16   |</span><br><span class="line">| c    | 17   |</span><br><span class="line">| d    | NULL |</span><br><span class="line">| e    |      |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">count</span>(<span class="keyword">name</span>), <span class="keyword">count</span>(<span class="number">1</span>), <span class="keyword">count</span>(*), <span class="keyword">count</span>(age), <span class="keyword">count</span>(<span class="keyword">distinct</span>(age))</span><br><span class="line">    -&gt; <span class="keyword">from</span> counttest</span><br><span class="line">    -&gt; <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br><span class="line">+<span class="comment">------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line">| name | count(name) | count(1) | count(*) | count(age) | count(distinct(age)) |</span><br><span class="line">+<span class="comment">------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line">| a    |           3 |        3 |        3 |          3 |                    2 |</span><br><span class="line">| b    |           2 |        2 |        2 |          1 |                    1 |</span><br><span class="line">| c    |           1 |        1 |        1 |          1 |                    1 |</span><br><span class="line">| d    |           1 |        1 |        1 |          0 |                    0 |</span><br><span class="line">| e    |           1 |        1 |        1 |          1 |                    1 |</span><br><span class="line">+<span class="comment">------+-------------+----------+----------+------------+----------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/iFuMI/article/details/77920767&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;count(1)、count(*) 与 count(列名) 的执行区别&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>从头到尾说一次Java垃圾回收</title>
    <link href="https://mlone.top/2019/09/17/%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E8%AF%B4%E4%B8%80%E6%AC%A1Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://mlone.top/2019/09/17/从头到尾说一次Java垃圾回收/</id>
    <published>2019-09-17T13:14:23.000Z</published>
    <updated>2019-09-17T13:46:34.829Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247490759&amp;idx=2&amp;sn=0cd99a4f54f66b605399974efde40f0b&amp;chksm=eb5399f1dc2410e799ac385a710a23ac18b9b6b05f7f5b0a5ebc544e747e8e8f5cfc08309c2e&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568290753693&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">从头到尾说一次 Java 垃圾回收，写得非常好！</a><br><a id="more"></a></p><p>　　之前上学的时候有这个一个梗，说在食堂里吃饭，吃完把餐盘端走清理的，是 C++ 程序员，吃完直接就走的，是 Java 程序员。🤔</p><p>　　确实，在 Java 的世界里，似乎我们不用对垃圾回收那么的专注，很多初学者不懂 GC，也依然能写出一个能用甚至还不错的程序或系统。但其实这并不代表 Java 的 GC 就不重要。相反，它是那么的重要和复杂，以至于出了问题，那些初学者除了打开 GC 日志，看着一堆0101的天文，啥也做不了。😯</p><p>　　今天我们就从头到尾完整地聊一聊 Java 的垃圾回收。</p><h2 id="1-什么是垃圾回收"><a href="#1-什么是垃圾回收" class="headerlink" title="1. 什么是垃圾回收"></a>1. 什么是垃圾回收</h2><p>　　垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p><p>　　Java 语言出来之前，大家都在拼命的写 C 或者 C++ 的程序，而此时存在一个很大的矛盾，C++ 等语言创建对象要不断的去开辟空间，不用的时候又需要不断的去释放控件，既要写构造函数，又要写析构函数，很多时候都在重复的 allocated，然后不停的析构。于是，有人就提出，能不能写一段程序实现这块功能，每次创建，释放控件的时候复用这段代码，而无需重复的书写呢？</p><p>　　1960年，基于 MIT 的 Lisp 首先提出了垃圾回收的概念，而这时 Java 还没有出世呢！<strong>所以实际上 GC 并不是Java的专利，GC 的历史远远大于 Java 的历史！</strong></p><h2 id="2-怎么定义垃圾"><a href="#2-怎么定义垃圾" class="headerlink" title="2.  怎么定义垃圾"></a>2.  怎么定义垃圾</h2><p>　　既然我们要做垃圾回收，首先我们得搞清楚垃圾的定义是什么，哪些内存是需要回收的。</p><h3 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h3><p>　　引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。<br>　　<code>String m = new String(&quot;jack&quot;);</code></p><p>　　先创建一个字符串，这时候”jack”有一个引用，就是 m：<br>　　<img src="/blogImg/2019/9/17/2-1.png" alt></p><p>　　然后将 m 设置为 null，这时候”jack”的引用次数就等于0了，在引用计数算法中，意味着这块内容就需要被回收了。<br>　　<code>m = null;</code><br>　　<img src="/blogImg/2019/9/17/2-2.png" alt></p><p>　　引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，采用引用计数的垃圾收集不属于严格意义上的”Stop-The-World”的垃圾收集机制。</p><p>　　看似很美好，但我们知道JVM的垃圾回收就是”Stop-The-World”的，那是什么原因导致我们最终放弃了引用计数算法呢？看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountingGC</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objA"</span>);</span><br><span class="line">    ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objB"</span>);</span><br><span class="line"></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><ol><li>定义2个对象</li><li>相互引用</li><li>置空各自的声明引用</li></ol></blockquote><p>　　<img src="/blogImg/2019/9/17/2-3.png" alt><br>　　我们可以看到，最后这2个对象已经不可能再被访问了，但由于他们相互引用着对方，导致它们的引用计数永远都不会为0，通过引用计数算法，也就永远无法通知GC收集器回收它们。</p><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>　　可达性分析算法（Reachability Analysis）的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。<br>　　<img src="/blogImg/2019/9/17/2-4.png" alt><br>　　通过可达性算法，成功解决了引用计数所无法解决的问题-“循环依赖”，只要你无法与 GC Root 建立直接或间接的连接，系统就会判定你为可回收对象。那这样就引申出了另一个问题，哪些属于 GC Root。</p><h2 id="3-Java-内存区域"><a href="#3-Java-内存区域" class="headerlink" title="3. Java 内存区域"></a>3. Java 内存区域</h2><p>在 Java 语言中，可作为 GC Root 的对象包括以下4种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><p>　　<img src="/blogImg/2019/9/17/2-5.png" alt></p><h3 id="3-1-虚拟机栈（栈帧中的本地变量表）中引用的对象"><a href="#3-1-虚拟机栈（栈帧中的本地变量表）中引用的对象" class="headerlink" title="3.1 虚拟机栈（栈帧中的本地变量表）中引用的对象"></a>3.1 虚拟机栈（栈帧中的本地变量表）中引用的对象</h3><p>　　此时的 s，即为 GC Root，当s置空时，localParameter 对象也断掉了与 GC Root 的引用链，将被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackLocalParameter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackLocalParameter</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StackLocalParameter s = <span class="keyword">new</span> StackLocalParameter(<span class="string">"localParameter"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-方法区中类静态属性引用的对象"><a href="#3-2-方法区中类静态属性引用的对象" class="headerlink" title="3.2 方法区中类静态属性引用的对象"></a>3.2 方法区中类静态属性引用的对象</h3><p>　　s 为 GC Root，s 置为 null，经过 GC 后，s 所指向的 properties 对象由于无法与 GC Root 建立关系被回收。</p><p>　　而 m 作为类的静态属性，也属于 GC Root，parameter 对象依然与 GC root 建立着连接，所以此时 parameter 对象并不会被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaStaicProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodAreaStaicProperties m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAreaStaicProperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"properties"</span>);</span><br><span class="line">    s.m = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"parameter"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-方法区中常量引用的对象"><a href="#3-3-方法区中常量引用的对象" class="headerlink" title="3.3 方法区中常量引用的对象"></a>3.3 方法区中常量引用的对象</h3><p>　　m 即为方法区中的常量引用，也为 GC Root，s 置为 null 后，final 对象也不会因没有与 GC Root 建立联系而被回收。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaStaicProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodAreaStaicProperties m = MethodAreaStaicProperties(<span class="string">"final"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAreaStaicProperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"staticProperties"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-4-本地方法栈中引用的对象"><a href="#3-4-本地方法栈中引用的对象" class="headerlink" title="3.4 本地方法栈中引用的对象"></a>3.4 本地方法栈中引用的对象</h3><p>　　任何 Native 接口都会使用某种本地方法栈，实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。<br>　　<img src="/blogImg/2019/9/17/2-6.png" alt></p><h2 id="4-怎么回收垃圾"><a href="#4-怎么回收垃圾" class="headerlink" title="4. 怎么回收垃圾"></a>4. 怎么回收垃圾</h2><p>　　在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，这里我们讨论几种常见的垃圾收集算法的核心思想。</p><h3 id="4-1-标记-—-清除算法"><a href="#4-1-标记-—-清除算法" class="headerlink" title="4.1 标记 — 清除算法"></a>4.1 标记 — 清除算法</h3><p>　　<img src="/blogImg/2019/9/17/2-7.png" alt><br>　　标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。</p><p>　　这逻辑再清晰不过了，并且也很好操作，但它存在一个很大的问题，那就是内存碎片。</p><p>　　上图中等方块的假设是 2M，小一些的是 1M，大一些的是 4M。等我们回收完，内存就会切成了很多段。我们知道开辟内存空间时，需要的是连续的内存区域，这时候我们需要一个 2M的内存区域，其中有2个 1M 是没法用的。这样就导致，其实我们本身还有这么多的内存的，但却用不了。</p><h3 id="4-2-复制算法"><a href="#4-2-复制算法" class="headerlink" title="4.2 复制算法"></a>4.2 复制算法</h3><p>　　<img src="/blogImg/2019/9/17/2-8.png" alt><br>　　复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。</p><p>　　上面的图很清楚，也很明显的暴露了另一个问题，合着我这140平的大三房，只能当70平米的小两房来使？代价实在太高。</p><h3 id="4-3-标记整理算法"><a href="#4-3-标记整理算法" class="headerlink" title="4.3 标记整理算法"></a>4.3 标记整理算法</h3><p>　　<img src="/blogImg/2019/9/17/2-9.png" alt><br>　　标记整理算法（Mark-Compact）标记过程仍然与标记 — 清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p><p>　　标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。</p><p>　　分代收集算法分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记 — 整理算法来进行回收。so，另一个问题来了，那内存区域到底被分为哪几块，每一块又有什么特别适合什么算法呢？</p><h2 id="5-内存模型与回收策略"><a href="#5-内存模型与回收策略" class="headerlink" title="5. 内存模型与回收策略"></a>5. 内存模型与回收策略</h2><p>　　<img src="/blogImg/2019/9/17/2-10.png" alt><br>　　Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，这里我们主要分析一下 Java 堆的结构。</p><p>　　Java 堆主要分为2个区域-年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。可能这时候大家会有疑问，为什么需要 Survivor区，为什么Survivor还要分2个区。不着急，我们从头到尾，看看对象到底是怎么来的，而它又是怎么没的。　　</p><h3 id="5-1-Eden-区"><a href="#5-1-Eden-区" class="headerlink" title="5.1 Eden 区"></a>5.1 Eden 区</h3><p>　　IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。</p><p>　　通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。</p><h3 id="5-2-Survivor-区"><a href="#5-2-Survivor-区" class="headerlink" title="5.2 Survivor 区"></a>5.2 Survivor 区</h3><p>　　Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。</p><p><strong>为啥需要？</strong><br>　　不就是新生代到老年代么，直接 Eden 到 Old 不好了吗，为啥要这么复杂。想想如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。</p><p>　　所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p><p><strong> 为啥需要俩？</strong><br>　　设置两个 Survivor 区最大的好处就是解决内存碎片化。</p><p>　　我们先假设一下，Survivor 如果只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。</p><p>　　这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。</p><h3 id="5-3-Old-区"><a href="#5-3-Old-区" class="headerlink" title="5.3 Old 区"></a>5.3 Old 区</h3><p>　　老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记 — 整理算法。</p><p>　　除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。</p><p><strong>大对象</strong><br>　　大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。</p><p><strong> 长期存活对象 </strong><br>　　虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。</p><p><strong>动态对象年龄</strong><br>　虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。</p><p>　　这其实有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机的硬件不通，健康状况不同，我们还可以基于每台机接受的请求数，或每台机的响应时间等，来调整我们的负载均衡算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247490759&amp;amp;idx=2&amp;amp;sn=0cd99a4f54f66b605399974efde40f0b&amp;amp;chksm=eb5399f1dc2410e799ac385a710a23ac18b9b6b05f7f5b0a5ebc544e747e8e8f5cfc08309c2e&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1568290753693&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从头到尾说一次 Java 垃圾回收，写得非常好！&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java集合类的总结</title>
    <link href="https://mlone.top/2019/09/17/Java%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://mlone.top/2019/09/17/Java集合类的总结/</id>
    <published>2019-09-17T12:12:25.000Z</published>
    <updated>2019-09-17T13:14:55.803Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>java集合类常见面试题</p><br><a id="more"></a><p></p><h2 id="1-集合类型概述"><a href="#1-集合类型概述" class="headerlink" title="1. 集合类型概述"></a>1. 集合类型概述</h2><p><img src="/blogImg/2019/9/17/1-1.png" alt></p><ol><li>Iterator：Collection（值）、Map（键值对）；</li><li>Collection：Set（无序不重复）、List（有序可重复）、Queue；</li><li>Set：HashSet（基于HashMap实现）、LinkedHashSet（继承自HashSet）、TreeSet（底层基于HashMap实现，升序排列）；</li><li>List：ArrayList（基于数组实现，默认初始容量为10，增速1.5倍 + 1）、Vector（初始容量为10，增速2倍）、Stack（继承自Vector）、LinkedList（基于链表实现）；</li><li>Map：HashMap、HashTable、TreeMap（基于红黑树实现，按key值排序）；</li><li>不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = collection.iterator(); <span class="comment">// 获得一个迭代子</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    Object obj = it.next(); <span class="comment">// 得到下一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>　　List还提供一个listIterator()方法，返回一个 ListIterator接口（实现Iterator），和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。</p><ol start="7"><li>快速失败（Fail-Fast）机制：它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li></ol><h2 id="2-Set接口与List接口"><a href="#2-Set接口与List接口" class="headerlink" title="2. Set接口与List接口"></a>2. Set接口与List接口</h2><p>　　List是有序的集合，这里的有序指的是元素插入List的顺序可以控制，Set是无序的。因此List可以允许元素重复，而Set则不可以（只能有一个null）。元素是否重复是根据equals和hashCode判断的，也就是说如果一个对象要存储在Set中，必须重写equals和hashCode方法。</p><h2 id="3-ArrayList和LinkedList"><a href="#3-ArrayList和LinkedList" class="headerlink" title="3. ArrayList和LinkedList"></a>3. ArrayList和LinkedList</h2><ol><li>ArrayList和LinkedList都是非线程安全的，都允许null值。ArrayList基于数组数据结构实现，LinkedList基于链表结构实现。</li><li>ArrayList允许对元素进行快速随机访问，但是想中间插入与移除元素的速率很慢；LinkedList插入与删除的开销不大，随机访问较慢。</li><li>LinkedList具有下列方法：addFirst()，addLast()，getFirst()，getLast()，removeFirst()和removeLast()这些方法(没有在任何接口或基类中定义过)，这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</li></ol><h2 id="4-ArrayList和Vector"><a href="#4-ArrayList和Vector" class="headerlink" title="4. ArrayList和Vector"></a>4. ArrayList和Vector</h2><ol><li>ArrayList是线程不安全的，Vector是线程安全的。因此ArrayList的性能要高于Vector；</li><li>ArrayList和Vector都采用基于数组的方式组织元素，默认初始容量都是10，如果集合中的元素的数目大于目前集合数组的长度时，Vector扩容为原数组的2倍，而ArrayList扩容为原来1.5倍。Vector还可以设置容量的增量，而ArrayList不可以。</li></ol><h2 id="5-队列与阻塞队列"><a href="#5-队列与阻塞队列" class="headerlink" title="5. 队列与阻塞队列"></a>5. 队列与阻塞队列</h2><p>  队列包含固定长度的队列和不固定长度的队列，先进先出。</p><p>  固定长度的队列往里放数据，如果放满了还要放，阻塞式队列就会等待，直到有数据取出，空出位置后才继续放；非阻塞式队列不能等待就只能报错了。</p><h2 id="6-ArrayBlockingQueue"><a href="#6-ArrayBlockingQueue" class="headerlink" title="6.  ArrayBlockingQueue"></a>6.  ArrayBlockingQueue</h2><p>  一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部是在队列中存在时间最长的元素。队列的尾部是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。</p><p>  这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。</p><p>  此类支持对等待的生产者线程和使用者线程进行排序的可选公平策略。默认情况下，不保证是这种排序。然而，通过将公平性 (fairness) 设置为 true 而构造的队列允许按照FIFO 顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。</p><p>  LinkedBlockingQueue则是一个由链接节点支持的可选有界队列。基于链表实现的阻塞队列。</p><h2 id="7-PriorityQueue"><a href="#7-PriorityQueue" class="headerlink" title="7. PriorityQueue"></a>7. PriorityQueue</h2><p>  PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序（natural order）排序的。在创建的时候，我们可以给他提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。<br>  PriorityBlockingQueue是对PriorityQueue的再次包装的阻塞型无界优先级队列。所以在优先阻塞队列上put时是不会受阻的（但是资源耗尽的情况下回导致OutOfMemoryError）。当队列为空，那么取元素的操作take就会阻塞。</p><h2 id="8-为什么集合类没有实现Cloneable和Serializable接口"><a href="#8-为什么集合类没有实现Cloneable和Serializable接口" class="headerlink" title="8. 为什么集合类没有实现Cloneable和Serializable接口"></a>8. 为什么集合类没有实现Cloneable和Serializable接口</h2><p>  克隆（cloning）或者是序列化（serialization）的语义和含义是跟具体的实现类相关的。因此应该由集合类的具体实现来决定如何被克隆或者序列化。当然了，集合框架的接口没有实现克隆和序列化，但是具体的集合类实现了，例如ArrayList类。</p><h2 id="9-Array与ArrayList的区别"><a href="#9-Array与ArrayList的区别" class="headerlink" title="9. Array与ArrayList的区别"></a>9. Array与ArrayList的区别</h2><h3 id="9-1-存储内容方面："><a href="#9-1-存储内容方面：" class="headerlink" title="9.1 存储内容方面："></a>9.1 存储内容方面：</h3><p>  Array数组可以包含基本类型和对象类型；ArrayList却只能包含对象类型。<br>  但是需要注意的是：Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。</p><h3 id="9-2-空间大小方面："><a href="#9-2-空间大小方面：" class="headerlink" title="9.2 空间大小方面："></a>9.2 空间大小方面：</h3><p>  Array的空间大小是固定的，空间不够时也不能再次申请，所以需要事先确定合适的空间大小。<br>  ArrayList的空间是动态增长的，如果空间不够，它会创建一个空间比原来大1.5倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且每次添加新元素的时候都会检查内部数组的空间是否足够。</p><h3 id="9-3-方法操作方面："><a href="#9-3-方法操作方面：" class="headerlink" title="9.3 方法操作方面："></a>9.3 方法操作方面：</h3><p>  ArrayList作为Array的增强版，当然是在方法上比Array更多样化，比如添加全部addAll()，删除全部removeAll()，返回迭代器iterator()等。<br>  <br>适用场景：<br>  如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里。如果数据的个数在程序运行时会发生改变，则只能使用ArrayList。但是应该注意到ArrayList增加或者删除数据的时候，都会移动数组中的元素。如果我们需要对元素进行频繁的移动或者删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就会很麻烦，那么，我们可以考虑选择LinkedList。</p><h3 id="9-4-Arrays类"><a href="#9-4-Arrays类" class="headerlink" title="9.4 Arrays类"></a>9.4 Arrays类</h3><p>Arrays主要是用于方便操作数组的，他的主要方法有：<br>  1. 给数组赋值：通过fill方法；<br>  2. 对数组排序：通过sort方法，按升序；<br>  3. 比较数组：通过equals方法比较数组中元素值是否相等；<br>  4. 查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找法操作。</p><h2 id="10-HashMap和HashTable"><a href="#10-HashMap和HashTable" class="headerlink" title="10. HashMap和HashTable"></a>10. HashMap和HashTable</h2><p>  <strong>相同点：</strong>HashMap和HasheTalbe都可以使用来存储key–value的数据。都实现了Map接口；<br>  <strong>区别：</strong><br>  1. 历史原因：HashTable是基于陈旧的Dictionary类的，HashMap是Java1.2引进的Map接口的一个实现。但是两者都实现了Map接口；<br>  2. 同步性：HashTable是线程安全的，也就是说同步的，这个类中的一些方法包装了HashTable中的对象是线程安全的。而HashMap则是线程异步的，即不同步的，因此HashMap中的对象并不是线程安全的。因为同步的要求会影响执行效率，所以HashMap的性能要高于HashTable；<br>  3. HashMap可以将空值（null）做为key和value，而HashTable是不能放入空值的（value为空也不行）；<br>  4. HashMap是快速失败机制，HashTable不是；<br>  5. HashTable使用Enumeration，HashMap使用Iterator；<br>  6. HashTable直接使用对象的hashCode值，而HashMap重新计算hash值，并且用“与”运算代替求模;<br>  7. HashMap的初始容量为16，HashTable的初始容量为11。</p><h2 id="11-Hashtable-和ConcurrentHashMap"><a href="#11-Hashtable-和ConcurrentHashMap" class="headerlink" title="11. Hashtable 和ConcurrentHashMap"></a>11. Hashtable 和ConcurrentHashMap</h2><p>  效率低下的HashTable容器：HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。<br>  如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><blockquote><p><strong>锁分段技术</strong></p></blockquote><p>  HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是 ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>  java5中新增了ConcurrentMap接口和它的一个实现类 ConcurrentHashMap。ConcurrentHashMap提供了和Hashtable以及SynchronizedMap中所不同的锁机制。Hashtable中采用的锁机制是一次锁住整个hash表，从而同一时刻只能由一个线程对其进行操作；而ConcurrentHashMap中则是一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如put，remove等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。</p><p>  而读操作大部分时候都不需要用到锁（读到null值时会上锁）。只有在size等操作时才需要锁住整个hash表。</p><p>  在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据，iterator完成后再将头指针替换为新的数据，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p><h2 id="12-为什么我们需要ConcurrentHashMap和CopyOnWriteArrayList"><a href="#12-为什么我们需要ConcurrentHashMap和CopyOnWriteArrayList" class="headerlink" title="12. 为什么我们需要ConcurrentHashMap和CopyOnWriteArrayList"></a>12. 为什么我们需要ConcurrentHashMap和CopyOnWriteArrayList</h2><p>  同步的集合类（Hashtable和Vector），同步的封装类（使用<code>Collections.synchronizedMap()</code>方法和<code>Collections.synchronizedList()</code>方法返回的对象）可以创建出线程安全的Map和List。但是有些因素使得它们不适合高并发的系统。它们仅有单个锁，对整个集合加锁，以及为了防止<code>ConcurrentModificationException</code>异常经常要在迭代的时候要将集合锁定一段时间，这些特性对可扩展性来说都是障碍。</p><p>　　ConcurrentHashMap和CopyOnWriteArrayList保留了线程安全的同时，也提供了更高的并发性。ConcurrentHashMap和CopyOnWriteArrayList并不是处处都需要用，大部分时候你只需要用到HashMap和ArrayList，它们用于应对一些普通的情况。</p><h2 id="13-Comparable接口和Comparator接口的比较"><a href="#13-Comparable接口和Comparator接口的比较" class="headerlink" title="13. Comparable接口和Comparator接口的比较"></a>13. Comparable接口和Comparator接口的比较</h2><p>  在实际应用中，我们往往有需要比较两个自定义对象大小的地方。而这些自定义对象的比较，就不像简单的整型数据那么简单，它们往往包含有许多的属性，我们一般都是根据这些属性对自定义对象进行比较的。所以Java中要比较对象的大小或者要对对象的集合进行排序，需要通过比较这些对象的某些属性的大小来确定它们之间的大小关系。</p><p>  一般，Java中通过接口实现两个对象的比较，比较常用就是Comparable接口和Comparator接口。首先类要实现接口，并且使用泛型规定要进行比较的对象所属的类，然后类实现了接口后，还需要实现接口定义的比较方法（compareTo方法或者compare方法），在这些方法中传入需要比较大小的另一个对象，通过选定的成员变量与之比较，如果大于则返回1，小于返回-1，相等返回0。<br>  1. Comparable和Comparator都是用来实现集合中元素的比较、排序的。<br>  2. Comparable是在类内部定义的方法实现的排序，位于java.lang下。<br>  3. Comparator是在类外部实现的排序，位于java.util下。<br>  4. 实现Comparable接口需要覆盖compareTo方法，实现Comparator接口需要覆盖compare方法。</p><h2 id="14-Comparable接口"><a href="#14-Comparable接口" class="headerlink" title="14. Comparable接口"></a>14. Comparable接口</h2><p><strong> 1、什么是Comparable接口 </strong><br>  此接口强行对实现它的每个类的对象进行整体排序。此排序被称为该类的自然排序，类的 compareTo方法被称为它的自然比较方法 。实现此接口的对象列表（和数组）可以通过 Collections.sort（和 Arrays.sort ）进行自动排序。实现此接口的对象可以用作有序映射表中的键或有序集合中的元素，无需指定比较器。<br>  如String、Integer自己就实现了Comparable接口，可完成比较大小操作。自定义类要在加入list容器中后能够排序，也可以实现Comparable接口，在用Collections类的sort方法排序时若不指定Comparator，那就以自然顺序排序。所谓自然顺序就是实现Comparable接口设定的排序方式。<br>  <br><strong>2、实现什么方法</strong><br>  <code>int compareTo(T o)</code><br>  比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。<br>  参数：o - 要比较的对象。<br>  返回：负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。<br>  抛出：ClassCastException - 如果指定对象的类型不允许它与此对象进行比较。</p><h2 id="15-Comparator接口"><a href="#15-Comparator接口" class="headerlink" title="15. Comparator接口"></a>15. Comparator接口</h2><p>  Comparator是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足要求时，可写一个比较器来完成两个对象之间大小的比较。Comparator体现了一种策略模式(strategy design pattern)，就是不改变对象自身，而用一个策略对象(strategy object)来改变它的行为。</p><p>与上面的Comparable接口不同的是：<br>  1）Comparator位于包java.util下，而Comparable位于包java.lang下。<br>  2）Comparable接口将比较代码嵌入需要进行比较的类的自身代码中，而Comparator接口在一个独立的类中实现比较。<br>  3）如果前期类的设计没有考虑到类的Compare问题而没有实现Comparable接口，后期可以通过Comparator接口来实现比较算法进行排序，并且为了使用不同的排序标准做准备，比如：升序、降序。<br>  4）Comparable接口强制进行自然排序，而Comparator接口不强制进行自然排序，可以指定排序顺序。</p><h2 id="16-快速失败与安全失败的区别"><a href="#16-快速失败与安全失败的区别" class="headerlink" title="16. 快速失败与安全失败的区别"></a>16. 快速失败与安全失败的区别</h2><h3 id="16-1-快速失败（fail—fast）"><a href="#16-1-快速失败（fail—fast）" class="headerlink" title="16.1 快速失败（fail—fast）"></a>16.1 快速失败（fail—fast）</h3><p>  在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出<code>Concurrent Modification Exception</code>。<br>  原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用<code>hashNext()/next()</code>遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。<br>  注意：这里异常的抛出条件是检测到 <code>modCount！=expectedmodCount</code> 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><p><strong>JDK中详细的描述：</strong><br>  注意，此实现不是同步的。如果多个线程同时访问一个哈希映射（或者其他集合类），而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：<br>  <code>Map m = Collections.synchronizedMap(new HashMap(...));</code><br>  由所有此类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 <code>ConcurrentModificationException</code>。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。<br>  注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。<br>  场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><h3 id="16-2-安全失败（fail—safe）"><a href="#16-2-安全失败（fail—safe）" class="headerlink" title="16.2 安全失败（fail—safe）"></a>16.2 安全失败（fail—safe）</h3><p>  <strong>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</strong><br>  原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发<code>ConcurrentModificationException</code>。<br>  缺点：基于拷贝内容的优点是避免了<code>ConcurrentModificationException</code>，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。<br>  场景：<code>java.util.concurrent</code>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。<br>  ConcurrentHashMap中的迭代器主要包括entrySet、keySet、values方法。它们大同小异，这里选择entrySet解释。当我们调用entrySet返回值的iterator方法时，返回的是EntryIterator，在EntryIterator上调用next方法时，最终实际调用到了HashIterator.advance()方法。这个方法在遍历底层数组。在遍历过程中，如果已经遍历的数组上的内容变化了，迭代器不会抛出<code>ConcurrentModificationException</code>异常。如果未遍历的数组上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器弱一致的表现。ConcurrentHashMap的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。要成为强一致性，就得到处使用锁，甚至是全局锁，这就与Hashtable和同步的HashMap一样了。</p><h2 id="17-Enumeration接口和Iterator接口的区别"><a href="#17-Enumeration接口和Iterator接口的区别" class="headerlink" title="17. Enumeration接口和Iterator接口的区别"></a>17. Enumeration接口和Iterator接口的区别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Enumeration</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">nextElement</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(1) 函数接口不同</strong><br>  Enumeration 只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。<br>  Iterator 只有3个函数接口。Iterator除了能读取集合的数据之外，也能对数据进行删除操作。</p><p><strong>(2) Iterator 支持 fail-fast 机制，而 Enumeration 不支持</strong><br>  Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。<br>  而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。<br>  总结：Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;java集合类常见面试题&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql数据类型</title>
    <link href="https://mlone.top/2019/09/16/mysql%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://mlone.top/2019/09/16/mysql数据类型/</id>
    <published>2019-09-16T15:06:45.000Z</published>
    <updated>2019-09-17T12:06:30.988Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html" target="_blank" rel="noopener">https://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html</a><br><a id="more"></a></p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table><thead><tr><th>MySQL数据类型</th><th>含义（有符号）</th></tr></thead><tbody><tr><td>tinyint(m)</td><td>1个字节 范围(-128~127)</td></tr><tr><td>smallint(m)</td><td>2个字节 范围(-32768~32767)</td></tr><tr><td>mediumint(m)</td><td>3个字节 范围(-8388608~8388607)</td></tr><tr><td>int(m)</td><td>4个字节 范围(-2147483648~2147483647)</td></tr><tr><td>bigint(m)</td><td>8个字节 范围(+-9.22*10的18次方)</td></tr></tbody></table><p>　　取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th>MySQL数据类型</th><th>含义</th></tr></thead><tbody><tr><td>float(m,d)</td><td>单精度浮点型 8位精度(4字节) m总个数，d小数位)</td></tr><tr><td>double(m,d)</td><td>双精度浮点型 16位精度(8字节) m总个数，d小数位</td></tr></tbody></table><p>　　设一个字段定义为float(5,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。</p><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>　　浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位。&lt;=”” p=””&gt;</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><table><thead><tr><th>MySQL数据类型</th><th>含义</th></tr></thead><tbody><tr><td>char(n)</td><td>固定长度，最多255个字符</td></tr><tr><td>varchar(n)</td><td>固定长度，最多65535个字符</td></tr><tr><td>tinytext</td><td>可变长度，最多255个字符</td></tr><tr><td>text</td><td>可变长度，最多65535个字符</td></tr><tr><td>mediumtext</td><td>可变长度，最多2的24次方-1个字符</td></tr><tr><td>longtext</td><td>可变长度，最多2的32次方-1个字符</td></tr></tbody></table><p><strong>char和varchar：</strong></p><ul><li>char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此；</li><li>char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节；</li><li>char类型的字符串检索速度要比varchar类型的快。</li></ul><p><strong>varchar和text：</strong></p><ul><li>varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字节；</li><li>text类型不能有默认值；</li><li>varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。</li></ul><h3 id="二进制数据-Blob"><a href="#二进制数据-Blob" class="headerlink" title="二进制数据(Blob)"></a>二进制数据(Blob)</h3><ul><li>BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写；</li><li>BLOB存储的数据只能整体读出；</li><li>TEXT可以指定字符集，BLO不用指定字符集。</li></ul><h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><table><thead><tr><th>MySQL数据类型</th><th>含义</th></tr></thead><tbody><tr><td>date</td><td>日期 ‘2008-12-2’</td></tr><tr><td>time</td><td>时间 ‘12:25:36’</td></tr><tr><td>datetime</td><td>日期时间 ‘2008-12-2 22:06:44’</td></tr><tr><td>timestamp</td><td>自动存储记录修改时间</td></tr></tbody></table><p>　　若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。</p><h3 id="数据类型的属性"><a href="#数据类型的属性" class="headerlink" title="数据类型的属性"></a>数据类型的属性</h3><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>这句简单的sql如何加索引</title>
    <link href="https://mlone.top/2019/09/16/%E8%BF%99%E5%8F%A5%E7%AE%80%E5%8D%95%E7%9A%84sql%E5%A6%82%E4%BD%95%E5%8A%A0%E7%B4%A2%E5%BC%95/"/>
    <id>https://mlone.top/2019/09/16/这句简单的sql如何加索引/</id>
    <published>2019-09-16T13:38:40.000Z</published>
    <updated>2019-09-16T14:57:54.185Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;mid=2257484491&amp;idx=1&amp;sn=4bbc14d324c8f7ea0809baeea0b20516&amp;chksm=a447f96c9330707a1930cf9b46d3263d476135b90f23392b048f668c12c173a53f414c3778c2&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568291267662&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">这句简单的sql，如何加索引？颠覆了我多年的认知</a><br><a id="more"></a></p><blockquote><p>请问下面的sql语句，要想加快查询速度，该怎么创建索引？（以下以mysql数据库为准）<br><code>select * from test where a=? and b&gt;? order by c limit 0,100</code></p></blockquote><p>　　结果可能会出乎你的意料。我们首先准备一下运行环境，然后按照<strong>最左前缀原则</strong>和<strong>explain关键字</strong>来进行验证。结果真是颠覆了我多年的认知。</p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>　　为了进行验证，我们创建一个简单的数据表。里面有a、b、c三个简单的int字段。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure></p><p>　　接下来，写一个简单的存储过程，来插入10w条数据。等待大约1分钟，数据插入完毕。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> test_initData;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_initData()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">    WHILE i&lt;=100000 DO</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(<span class="keyword">id</span>,a,b,c) <span class="keyword">VALUES</span>(i,i*<span class="number">2</span>,i*<span class="number">3</span>,i*<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">SET</span> i = i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="keyword">CALL</span> test_initData();</span><br></pre></td></tr></table></figure></p><p>　　由于mysql有<strong>最左前缀原则</strong>，我们对abc三列进行了全排列，创建了6个索引。这6个索引涵盖了所有的根据abc查询的情况。</p><pre><code>create INDEX idx_a_b_c on test(a,b,c);create INDEX idx_a_c_b on test(a,c,b);create INDEX idx_b_a_c on test(b,a,c);create INDEX idx_b_c_a on test(b,c,a);create INDEX idx_c_a_b on test(c,a,b);create INDEX idx_c_b_a on test(c,b,a);</code></pre><h2 id="使用Explain进行验证"><a href="#使用Explain进行验证" class="headerlink" title="使用Explain进行验证"></a>使用Explain进行验证</h2><h3 id="1、自动选用索引"><a href="#1、自动选用索引" class="headerlink" title="1、自动选用索引"></a>1、自动选用索引</h3><hr><p><code>explain select * from test where a &gt; 10 and b &gt; 10 order by c</code></p><p>首先，我们拿上面的sql语句进行验证。结果发现，查询使用了索引idx_a_b_c，只用到了前缀a，b。而extra部分，则用到了filesort，也就是性能非常差的方式。</p><table><thead><tr><th>字段</th><th>数值</th></tr></thead><tbody><tr><td>id</td><td>1</td></tr><tr><td>select_type</td><td>SIMPLE</td></tr><tr><td>table</td><td>test</td></tr><tr><td>type</td><td>range</td></tr><tr><td>possible_key</td><td>idx_a, idx_b, idx_a_b_c, idx_a_c_b, idx_b_a_c, idx_b_c_a</td></tr><tr><td>key</td><td>idx_a_b_c</td></tr><tr><td>key_len</td><td>5</td></tr><tr><td>ref</td><td></td></tr><tr><td>rows</td><td>50291</td></tr><tr><td>Extra</td><td>Using where; Using index; Using filesort</td></tr></tbody></table><p>我们尝试换一下查询参数的位置：<br><code>explain select * from test where c&gt;10 and b &gt;10   order by a</code></p><table><thead><tr><th>字段</th><th>数值</th></tr></thead><tbody><tr><td>id</td><td>1</td></tr><tr><td>select_type</td><td>SIMPLE</td></tr><tr><td>table</td><td>test</td></tr><tr><td>type</td><td>range</td></tr><tr><td>possible_key</td><td>idx_b, idx_c, idx_b_a_c, idx_b_c_a, idx_c_a_b, idx_c_b_a</td></tr><tr><td>key</td><td>idx_b_a_c</td></tr><tr><td>key_len</td><td>5</td></tr><tr><td>ref</td><td></td></tr><tr><td>rows</td><td>50291</td></tr><tr><td>Extra</td><td>Using where; Using index; Using filesort</td></tr></tbody></table><p>　　这次索引自动选择了idx_b_a_c，但依然使用的filesort，查询效果是一样的。按照上面的逻辑，不是应该选择idx_b_c_a么？</p><h3 id="2、指定索引"><a href="#2、指定索引" class="headerlink" title="2、指定索引"></a>2、指定索引</h3><hr><p>接下来使用force index方式，强制指定索引。这里直接给出结果，就是下面的sql：<br><code>explain select * from test    FORCE INDEX(idx_c_b_a)    where a&gt;10 and b &gt;10  order by c</code><br>结果如下：</p><table><thead><tr><th>字段</th><th>数值</th></tr></thead><tbody><tr><td>id</td><td>1</td></tr><tr><td>select_type</td><td>SIMPLE</td></tr><tr><td>table</td><td>test</td></tr><tr><td>type</td><td>index</td></tr><tr><td>possible_key</td><td></td></tr><tr><td>key</td><td>idx_c_b_a</td></tr><tr><td>key_len</td><td>15</td></tr><tr><td>ref</td><td></td></tr><tr><td>rows</td><td>100583</td></tr><tr><td>Extra</td><td>Using where; Using index</td></tr></tbody></table><p>　　我们使用force index来指定使用的索引。这次效果非常好，显示使用了index，使用了where，只在索引上就完成了操作。但扫描的行数却增加了。</p><p>　　但是，这与我们的经验是相悖的。idx_c_b_a的索引，是在字段(c,b,a)上创建的。按照最左原则，支持的搜索条件有：c,cb,cba。在这个例子中，order by后面的参数，却被当作了前缀的头部信息。</p><p>　　我们删掉其他索引，只留下idx_c_b_a，然后去掉force index部分。结果发现，mysql现在能够自动的选择索引了。</p><p>再看另外一种情况，order by上有两个参数：<br><code>explain select * from test    FORCE INDEX(idx_b_c_a)    where a&gt;10   order by b,c</code></p><table><thead><tr><th>字段</th><th>数值</th></tr></thead><tbody><tr><td>id</td><td>1</td></tr><tr><td>select_type</td><td>SIMPLE</td></tr><tr><td>table</td><td>test</td></tr><tr><td>type</td><td>index</td></tr><tr><td>possible_key</td><td></td></tr><tr><td>key</td><td>idx_b_c_a</td></tr><tr><td>key_len</td><td>15</td></tr><tr><td>ref</td><td></td></tr><tr><td>rows</td><td>100583</td></tr><tr><td>Extra</td><td>Using where; Using index</td></tr></tbody></table><p>　　结果如上，使用idx_b_c_a，不走filesort。其他索引都不是最优。</p><h3 id="3、explain部分返回值意义"><a href="#3、explain部分返回值意义" class="headerlink" title="3、explain部分返回值意义"></a>3、explain部分返回值意义</h3><hr><p>　　我们得出上面的结论，是根据mysql自己提供的explain工具。这个工具能够输出一些有用的信息。下面是相关的部分返回值的意义。</p><p><span style="color: red;"><strong>select_type</strong></span><br>表示SELECT的类型，常见的取值有：</p><blockquote><p><strong>SIMPLE</strong>    简单表，不使用表连接或子查询。<br><strong>PRIMARY</strong>    主查询，即外层的查询。<br><strong>UNION</strong>    UNION中的第二个或者后面的查询语句。<br><strong>SUBQUERY</strong>    子查询中的第一个。</p></blockquote><p><span style="color: red;"><strong>type</strong></span><br>表示MySQL在表中找到所需行的方式，或者叫访问类型。常见访问类型如下，从下到上，性能越来越差。</p><blockquote><p><strong>system,const</strong> 表只有一行记录（等于系统表），这是const类型的特列。<br><strong>eq_ref</strong> 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。<br><strong>ref</strong>  非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。<br><strong>range</strong> 只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引。这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。<br><strong>index</strong> Full Index Scan，Index与All区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。<br><strong>all</strong> 全表扫描，性能最差</p></blockquote><p><span style="color: red;"><strong>Extra</strong></span></p><blockquote><p><strong>using index</strong><br>表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错。如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。<br><strong>using filesort</strong><br>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。<br><strong>using temporary</strong><br>使用了用临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</p></blockquote><p>　　可以看到，在我们创建了多个索引的时候，mysql的查询优化，并不一定能够进行智能的解析、用到最优的方式，需要使用force index指定索引。</p><p>　　mysql中的索引，主要就用在where条件中和排序动作中。分两种情况：<br>　　1、<span style="color: red;"><strong>先过滤，再排序</strong></span>，会用到过滤条件中的索引参数，但是排序会使用较慢的外部排序。因为这个结果集是经过过滤的，并没有什么索引参与。</p><p>　　2、<span style="color: red;"><strong>先排序，再过滤</strong></span>，可以使用同一个索引，排序的优先级高于过滤的优先级。选择合适的索引，在过滤的同时就把这个事给办了。但是扫描的行数会增加。</p><p>　　我想，mysql并不能够了解到这两个过程，到底谁快谁慢，于是选了一个最通用的方式，直接选用了第一种。甚至在索引非常多的时候，直接晕菜了。<span style="font-color: red;"><strong>索引建多了，你可能间接把mysql给害了</strong></span>。这是现象，至于深层次的原因，欢迎读过mysql相关源码的给解释一下。</p><p>　　这对经常变换字段进行排序的代码来说，并不是一个好的信号。考虑到程序的稳定性，我想应该要尽量减少where条件过滤后的结果集。这种情况下，创建一个（a，b）的联合索引，或许是一个折衷的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5OTMyNzQzMg==&amp;amp;mid=2257484491&amp;amp;idx=1&amp;amp;sn=4bbc14d324c8f7ea0809baeea0b20516&amp;amp;chksm=a447f96c9330707a1930cf9b46d3263d476135b90f23392b048f668c12c173a53f414c3778c2&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1568291267662&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这句简单的sql，如何加索引？颠覆了我多年的认知&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Class.forName和ClassLoader有什么区别？</title>
    <link href="https://mlone.top/2019/09/11/Class-forName%E5%92%8CClassLoader%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>https://mlone.top/2019/09/11/Class-forName和ClassLoader有什么区别？/</id>
    <published>2019-09-11T15:02:44.000Z</published>
    <updated>2019-09-11T15:50:29.131Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247488216&amp;idx=2&amp;sn=221b30554352cc71c3eeaacd2f22a067&amp;chksm=e8fe8ed1df8907c703e642a83c36f29a5b8638e544ee13d018be230543a15a6d1e450238abd5&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1566828808925&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">面试题：Class.forName 和 ClassLoader 有什么区别？</a><br><a id="more"></a></p><p>　　在 java 中 Class.forName() 和 ClassLoader 都可以对类进行加载。ClassLoader 就是遵循双亲委派模型最终调用启动类加载器的类加载器，实现的功能是“通过一个类的全限定名来获取描述此类的二进制字节流”，获取到二进制流后放到 JVM 中。Class.forName() 方法实际上也是调用的 CLassLoader 来实现的。<br>　　Class.forName(String className)；这个方法的源码是：<br>　　<img src="/blogImg/2019/9/11/1-1.png" alt></p><p>　　最后调用的方法是 forName0 这个方法，在这个 forName0 方法中的第二个参数被默认设置为了 true，这个参数代表是否对加载的类进行初始化，设置为 true 时会类进行初始化，代表会执行类中的静态代码块，以及对静态变量的赋值等操作。</p><p>　　也可以调用 Class.forName(String name, boolean initialize,ClassLoader loader) 方法来手动选择在加载类的时候是否要对类进行初始化。Class.forName(String name, boolean initialize,ClassLoader loader) 的源码如下：<br>　　<img src="/blogImg/2019/9/11/1-2.png" alt></p><p>　　源码中的注释只摘取了一部分，其中对参数 initialize 的描述是：if {@code true} the class will be initialized. 意思就是说：如果参数为 true，则加载的类将会被初始化。<br>　　<br><strong>举例：</strong><br>　　一个含有静态代码块、静态变量、赋值给静态变量的静态方法的类：<br>　　<img src="/blogImg/2019/9/11/1-3.png" alt></p><p>测试方法：<br>　　<img src="/blogImg/2019/9/11/1-4.png" alt></p><p>运行结果：<br>　　<img src="/blogImg/2019/9/11/1-5.png" alt></p><p>　　根据运行结果得出 Class.forName 加载类是将类进了初始化，而 ClassLoader 的 loadClass 并没有对类进行初始化，只是把类加载到了虚拟机中。<br>　　<br><strong>应用场景：</strong><br>　　在我们熟悉的 Spring 框架中的 IOC 的实现就是使用的 ClassLoader。</p><p>　　而在我们使用 JDBC 时通常是使用 Class.forName() 方法来加载数据库连接驱动。这是因为在 JDBC 规范中明确要求 Driver(数据库驱动)类必须向 DriverManager 注册自己。</p><p>　　以 MySQL 的驱动为例解释：<br>　　<img src="/blogImg/2019/9/11/1-6.png" alt></p><p>　　我们看到 Driver 注册到 DriverManager 中的操作写在了静态代码块中，这就是为什么在写 JDBC 时使用 Class.forName() 的原因了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;amp;mid=2247488216&amp;amp;idx=2&amp;amp;sn=221b30554352cc71c3eeaacd2f22a067&amp;amp;chksm=e8fe8ed1df8907c703e642a83c36f29a5b8638e544ee13d018be230543a15a6d1e450238abd5&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;sharer_sharetime=1566828808925&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题：Class.forName 和 ClassLoader 有什么区别？&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>如何解决分布式事务问题</title>
    <link href="https://mlone.top/2019/09/10/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"/>
    <id>https://mlone.top/2019/09/10/如何解决分布式事务问题/</id>
    <published>2019-09-10T14:43:40.000Z</published>
    <updated>2019-09-10T15:01:52.175Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;mid=2247488189&amp;idx=1&amp;sn=4a0408a90c45d11b6ca4e55c1cefb0ba&amp;chksm=e8fe8eb4df8907a27945cbfaa5f8dba33495cf3b2b5a5fe1c535e8b1489d594c195dc288b3db&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">面试官：你们是如何解决分布式事务问题的？</a><br><a id="more"></a></p><p><strong># 面试官心理分析</strong></p><p>　　只要聊到你做了分布式系统，必问分布式事务，你对分布式事务一无所知的话，确实会很坑，你起码得知道有哪些方案，一般怎么来做，每个方案的优缺点是什么。</p><p>　　现在面试，分布式系统成了标配，而分布式系统带来的分布式事务也成了标配了。因为你做系统肯定要用事务吧，如果是分布式系统，肯定要用分布式事务吧。先不说你搞过没有，起码你得明白有哪几种方案，每种方案可能有啥坑？比如 TCC 方案的网络问题、XA 方案的一致性问题。</p><p><strong># 面试题剖析</strong></p><p>分布式事务的实现主要有以下 5 种方案：</p><ul><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h3 id="1、两阶段提交方案-XA方案"><a href="#1、两阶段提交方案-XA方案" class="headerlink" title="1、两阶段提交方案/XA方案"></a>1、两阶段提交方案/XA方案</h3><p>　　所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>　　这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 Spring + JTA 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>　　这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</p><p>　　如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>　　如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。<br>　　<img src="/blogImg/2019/9/10/2-1.png" alt></p><h3 id="2、TCC-方案"><a href="#2、TCC-方案" class="headerlink" title="2、TCC 方案"></a>2、TCC 方案</h3><p>　　TCC 的全称是：Try、Confirm、Cancel。　　</p><blockquote><p>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。<br>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。<br>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</p></blockquote><p>　　这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心。</p><p>　　比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>　　而且最好是你的各个业务执行的时间都比较短。</p><p>　　但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。<br>　　<img src="/blogImg/2019/9/10/2-2.png" alt></p><h3 id="3、本地消息表"><a href="#3、本地消息表" class="headerlink" title="3、本地消息表"></a>3、本地消息表</h3><p>　　本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>这个大概意思是这样的：</p><ol><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li></ol><p>　　这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。<br>　　<img src="/blogImg/2019/9/10/2-3.png" alt></p><h3 id="4、可靠消息最终一致性方案"><a href="#4、可靠消息最终一致性方案" class="headerlink" title="4、可靠消息最终一致性方案"></a>4、可靠消息最终一致性方案</h3><p>　　这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>大概的意思就是：</p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li></ol><h3 id="5、最大努力通知方案"><a href="#5、最大努力通知方案" class="headerlink" title="5、最大努力通知方案"></a>5、最大努力通知方案</h3><p>这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ol><h3 id="6、你们公司是如何处理分布式事务的？"><a href="#6、你们公司是如何处理分布式事务的？" class="headerlink" title="6、你们公司是如何处理分布式事务的？"></a>6、你们公司是如何处理分布式事务的？</h3><p>　　如果你真的被问到，可以这么说，我们某某特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p><p>　　你找一个严格资金要求绝对不能错的场景，你可以说你是用的 TCC 方案；如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</p><p>　　友情提示一下，RocketMQ 3.2.6 之前的版本，是可以按照上面的思路来的，但是之后接口做了一些改变，我这里不再赘述了。</p><p>　　当然如果你愿意，你可以参考可靠消息最终一致性方案来自己实现一套分布式事务，比如基于 RocketMQ 来玩儿。</p><p>　　</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&amp;amp;mid=2247488189&amp;amp;idx=1&amp;amp;sn=4a0408a90c45d11b6ca4e55c1cefb0ba&amp;amp;chksm=e8fe8eb4df8907a27945cbfaa5f8dba33495cf3b2b5a5fe1c535e8b1489d594c195dc288b3db&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试官：你们是如何解决分布式事务问题的？&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://mlone.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中long和double的原子性？</title>
    <link href="https://mlone.top/2019/09/10/Java%E4%B8%ADlong%E5%92%8Cdouble%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F/"/>
    <id>https://mlone.top/2019/09/10/Java中long和double的原子性？/</id>
    <published>2019-09-10T13:49:23.000Z</published>
    <updated>2019-09-10T14:24:20.853Z</updated>
    
    <content type="html"><![CDATA[<p>作者：LouisWong<br>链接：<a href="https://my.oschina.net/u/1753415/blog/724242" target="_blank" rel="noopener">https://my.oschina.net/u/1753415/blog/724242</a><br><a id="more"></a></p><ul><li>JVM中对long的操作是不是原子操作？</li><li>为什么对long的操作不是原子的？</li><li>在硬件，操作系统，JVM都是64位的情况下呢？</li></ul><blockquote><p>java中基本类型中，long和double的长度都是8个字节，32位（4字节）处理器对其读写操作无法一次完成，那么，JVM，long和double是原子性的吗？</p></blockquote><h3 id="JVM中对long的操作是不是原子操作？"><a href="#JVM中对long的操作是不是原子操作？" class="headerlink" title="JVM中对long的操作是不是原子操作？"></a>JVM中对long的操作是不是原子操作？</h3><p>　　首先，通过一段程序对long的原子性进行判断。测试程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAtomTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> field = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongAtomTest</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">100000</span>) &#123;</span><br><span class="line">            LongAtomTest.field = <span class="keyword">this</span>.getValue();</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">long</span> temp = LongAtomTest.field;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="number">1L</span> &amp;&amp; temp != -<span class="number">1L</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"出现错误结果"</span> + temp);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"运行正确"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取并打印当前JVM是32位还是64位的</span></span><br><span class="line">        String arch = System.getProperty(<span class="string">"sun.arch.data.model"</span>);</span><br><span class="line">        System.out.println(arch+<span class="string">"-bit"</span>);</span><br><span class="line">        LongAtomTest t1 = <span class="keyword">new</span> LongAtomTest(<span class="number">1</span>);</span><br><span class="line">        LongAtomTest t2 = <span class="keyword">new</span> LongAtomTest(-<span class="number">1</span>);</span><br><span class="line">        Thread T1 = <span class="keyword">new</span> Thread(t1);</span><br><span class="line">        Thread T2 = <span class="keyword">new</span> Thread(t2);</span><br><span class="line">        T1.start();</span><br><span class="line">        T2.start();</span><br><span class="line">        T1.join();</span><br><span class="line">        T2.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　可以看到，程序中有两条线程t1,t2；t1,t2各自不停的给long类型的静态变量field赋值为1，-1；t1,t2每次赋值后，会读取field的值，若field值既不是1又不是-1，就将field的值打印出来<br>　　如果对long的写入和读取操作是原子性的，那么，field的值只可能是1或者-1<br>　　运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">32-bit</span><br><span class="line">出现错误结果-4294967295</span><br><span class="line">运行正确</span><br></pre></td></tr></table></figure></p><p>　　可以看出，当线程t1,t2同时对long进行写的时候，long出现了既不是t1写入的值，又不是t2写入的值。可以推测，jvm中对long的操作并非原子操作。</p><h3 id="为什么对long的操作不是原子的？"><a href="#为什么对long的操作不是原子的？" class="headerlink" title="为什么对long的操作不是原子的？"></a>为什么对long的操作不是原子的？</h3><p>JVM内存模型中定义了8中原子操作：</p><blockquote><ol><li>lock:将一个变量标识为被一个线程独占状态</li><li>unclock:将一个变量从独占状态释放出来，释放后的变量才可以被其他线程锁定</li><li>read:将一个变量的值从主内存传输到工作内存中，以便随后的load操作</li><li>load:把read操作从主内存中得到的变量值放入工作内存的变量的副本中</li><li>use:把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令</li><li>assign:把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时，都要使用该操作</li><li>store:把工作内存中的一个变量的值传递给主内存，以便随后的write操作</li><li>write:把store操作从工作内存中得到的变量的值写到主内存中的变量</li></ol></blockquote><p>　　其中，与赋值，取值相关的包括 read,load,use,assign,store,write</p><p>　　按照这个规定，long的读写都是原子操作，与我们的实践结果相反，为什会导致这种问题呢？</p><p>　　对于32位操作系统来说，单次次操作能处理的最长长度为32bit，而long类型8字节64bit，所以对long的读写都要两条指令才能完成（即每次读写64bit中的32bit）。如果JVM要保证long和double读写的原子性，势必要做额外的处理。那么，JVM有对这一情况进行额外处理吗？针对这一问题可以参考Java语言规范文档：jls-17 Non-Atomic Treatment of double and long</p><blockquote><p>For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.<br>Writes and reads of volatile long and double values are always atomic.<br>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.<br>Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.<br>Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.</p></blockquote><p>从规定中我们可以知道：</p><blockquote><ol><li>对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。</li><li>如果使用volatile修饰long和double，那么其读写都是原子操作</li><li>对于64位的引用地址的读写，都是原子操作</li><li>在实现JVM时，可以自由选择是否把读写long和double作为原子操作</li><li>推荐JVM实现为原子操作</li></ol></blockquote><p>　　从程序得到的结果来看，32位的HotSpot没有把long和double的读写实现为原子操作。在读写的时候，分成两次操作，每次读写32位。因为采用了这种策略，所以64位的long和double的读与写都不是原子操作。</p><h3 id="在硬件，操作系统，JVM都是64位的情况下呢？"><a href="#在硬件，操作系统，JVM都是64位的情况下呢？" class="headerlink" title="在硬件，操作系统，JVM都是64位的情况下呢？"></a>在硬件，操作系统，JVM都是64位的情况下呢？</h3><p>　　对于64bit的环境来说，单次操作可以操作64bit的数据，即可以以一次性读写long或double的整个64bit。因此我们可以猜测，在64位的环境下，long和double的读写有可能是原子操作。在换了64位的JVM之后，多次运行，结果都是正确的</p><pre><code>64-bit运行正确运行正确</code></pre><p>　　结果表明，在64bit的虚拟机下，long的处理是原子性的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：LouisWong&lt;br&gt;链接：&lt;a href=&quot;https://my.oschina.net/u/1753415/blog/724242&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.oschina.net/u/1753415/blog/724242&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java逃逸分析</title>
    <link href="https://mlone.top/2019/09/10/Java%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>https://mlone.top/2019/09/10/Java逃逸分析/</id>
    <published>2019-09-10T13:35:25.000Z</published>
    <updated>2019-09-10T13:47:30.317Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247489776&amp;idx=1&amp;sn=74a93cea618aec7ff5af173f9b6a0626&amp;chksm=eb539dc6dc2414d09a6277579edda97648ab42cce2da846746d7d85f65a3a250b412eb4a6d8b&amp;mpshare=1&amp;scene=1&amp;srcid=0807fFat2ZPhZVYjS60xpdPw&amp;sharer_sharetime=1565143700829&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">面试问我 Java 逃逸分析，瞬间被秒杀了。。</a><br><a id="more"></a></p><blockquote><p>Java中的对象都是在堆中分配吗？说明为什么！</p></blockquote><h2 id="什么是逃逸分析？"><a href="#什么是逃逸分析？" class="headerlink" title="什么是逃逸分析？"></a>什么是逃逸分析？</h2><p>　　关于 Java 逃逸分析的定义：</p><p>　　逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。</p><p><strong>逃逸分析的 JVM 参数如下：</strong></p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>　　逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。</p><h2 id="逃逸分析算法"><a href="#逃逸分析算法" class="headerlink" title="逃逸分析算法"></a>逃逸分析算法</h2><p>　　Java Hotspot 编译器实现下面论文中描述的逃逸算法：</p><p>　　Java Hotspot 编译器实现下面论文中描述的逃逸算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Choi99] Jong-Deok Choi, Manish Gupta, Mauricio Seffano,            </span><br><span class="line">         Vugranam C. Sreedhar, Sam Midkiff,          </span><br><span class="line">         &quot;Escape Analysis for Java&quot;, Procedings of ACM SIGPLAN          </span><br><span class="line">         OOPSLA  Conference, November 1, 1999</span><br></pre></td></tr></table></figure></p><p>　　根据 Jong-Deok Choi, Manish Gupta, Mauricio Seffano,Vugranam C. Sreedhar, Sam Midkiff 等大牛在论文《<strong>Escape Analysis for Java</strong>》中描述的算法进行逃逸分析的。</p><p>　　该算法引入了连通图，用连通图来构建对象和对象引用之间的可达性关系，并在次基础上，提出一种组合数据流分析法。</p><p>　　由于算法是上下文相关和流敏感的，并且模拟了对象任意层次的嵌套关系，所以分析精度较高，只是运行时间和内存消耗相对较大。</p><h2 id="对象逃逸状态"><a href="#对象逃逸状态" class="headerlink" title="对象逃逸状态"></a>对象逃逸状态</h2><p>　　我们了解了 Java 中的逃逸分析技术，再来了解下一个对象的逃逸状态。</p><h3 id="1、全局逃逸（GlobalEscape）"><a href="#1、全局逃逸（GlobalEscape）" class="headerlink" title="1、全局逃逸（GlobalEscape）"></a>1、全局逃逸（GlobalEscape）</h3><p>　　即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：　　</p><ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul><h3 id="2、参数逃逸（ArgEscape）"><a href="#2、参数逃逸（ArgEscape）" class="headerlink" title="2、参数逃逸（ArgEscape）"></a>2、参数逃逸（ArgEscape）</h3><p>　　即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。</p><h3 id="3、没有逃逸"><a href="#3、没有逃逸" class="headerlink" title="3、没有逃逸"></a>3、没有逃逸</h3><p>　　即方法中的对象没有发生逃逸。</p><h2 id="逃逸分析优化"><a href="#逃逸分析优化" class="headerlink" title="逃逸分析优化"></a>逃逸分析优化</h2><p>　　针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。</p><h3 id="1-锁消除"><a href="#1-锁消除" class="headerlink" title="1) 锁消除"></a>1) 锁消除</h3><p>　　我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。</p><p>　　例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。</p><p><strong>锁消除的 JVM 参数如下：</strong></p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>　　锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。</p><h3 id="2-标量替换"><a href="#2-标量替换" class="headerlink" title="2) 标量替换"></a>2) 标量替换</h3><p>　　首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</p><p>　　对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p><p>　　这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。</p><p><strong>标量替换的 JVM 参数如下：</strong></p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>　　标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。</p><h3 id="3-栈上分配"><a href="#3-栈上分配" class="headerlink" title="3) 栈上分配"></a>3) 栈上分配</h3><p>　　当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　逃逸分析讲完了，总结了不少时间，我们也应该大概知道逃逸分析是为了优化 JVM 内存和提升程序性能的。</p><p>　　我们知道这点后，在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。</p><p>　　简单举一个例子吧，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return sb;</span><br></pre></td></tr></table></figure></p><p>　　可以改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return sb.toString();</span><br></pre></td></tr></table></figure></p><p>　　这是一种优化案例，把 StringBuilder 变量控制在了当前方法之内，没有逃出当前方法作用域。</p><p><strong>参考资料：</strong></p><ul><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis</a></li><li><a href="https://blog.csdn.net/rickiyeat/article/details/76802085" target="_blank" rel="noopener">https://blog.csdn.net/rickiyeat/article/details/76802085</a></li><li><a href="https://blog.csdn.net/baichoufei90/article/details/85180478" target="_blank" rel="noopener">https://blog.csdn.net/baichoufei90/article/details/85180478</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247489776&amp;amp;idx=1&amp;amp;sn=74a93cea618aec7ff5af173f9b6a0626&amp;amp;chksm=eb539dc6dc2414d09a6277579edda97648ab42cce2da846746d7d85f65a3a250b412eb4a6d8b&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0807fFat2ZPhZVYjS60xpdPw&amp;amp;sharer_sharetime=1565143700829&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试问我 Java 逃逸分析，瞬间被秒杀了。。&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是重入锁</title>
    <link href="https://mlone.top/2019/09/10/%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <id>https://mlone.top/2019/09/10/什么是重入锁/</id>
    <published>2019-09-10T13:00:22.000Z</published>
    <updated>2019-09-10T14:28:11.395Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247489881&amp;idx=1&amp;sn=fd30734494272ec71ea9d77e2a2d2b00&amp;chksm=eb539c6fdc241579e420b8a44eca80c50599cf3b11490e240781db064478681bf7b0ea03275f&amp;mpshare=1&amp;scene=1&amp;srcid=08070ZxRSbrvgs6UPJgpCTAe&amp;sharer_sharetime=1565143685590&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">到底什么是重入锁，拜托，一次搞清楚！</a><br><a id="more"></a></p><h2 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h2><blockquote><p>java.util.concurrent.locks.ReentrantLock</p></blockquote><p>　　这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。<br>　　<img src="/blogImg/2019/9/10/1-1.png" alt><br>　　从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p><blockquote><p>java.util.concurrent.locks.Lock</p></blockquote><p>　　它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p><h2 id="为什么叫重入锁呢？"><a href="#为什么叫重入锁呢？" class="headerlink" title="为什么叫重入锁呢？"></a>为什么叫重入锁呢？</h2><p>　　ReentrantLock，我们把它拆开来看就明了了。<br>　　Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p><p>　　试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p><h2 id="重入锁最重要的几个方法"><a href="#重入锁最重要的几个方法" class="headerlink" title="重入锁最重要的几个方法"></a>重入锁最重要的几个方法</h2><p>这几个方法都是 Lock 接口中定义的：</p><p><strong>1）lock()</strong></p><p>获取锁，有以下三种情况：</p><ul><li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li><li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li><li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li></ul><p><strong>2）lockInterruptibly()</strong></p><p>　　获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p><p><strong>3）tryLock()</strong></p><p>　　从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p><ul><li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li><li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li><li>其他线程持有锁：获取锁失败，返回：false；</li></ul><p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p><p>　　逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p><p><strong>5）unlock()</strong></p><p>　　释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p><p><strong>6）newCondition</strong></p><p>　　返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/ notify 要更灵活，更强大！</p><h2 id="重入锁大概的用法"><a href="#重入锁大概的用法" class="headerlink" title="重入锁大概的用法"></a>重入锁大概的用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>　　看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。　　</p><h2 id="synchronized-是重入锁吗？"><a href="#synchronized-是重入锁吗？" class="headerlink" title="synchronized 是重入锁吗？"></a>synchronized 是重入锁吗？</h2><p>　　那么问题来了，synchronized 是重入锁吗？</p><p>　　你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p><p>　　答案是：yes，为什么？看下面的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p><p>　　面试常问的Synchronized的几种用法推荐看下这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247487913&amp;idx=2&amp;sn=318f4cbbde0669bd8c62af3501d2c915&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Synchronized 有几种用法？</a>。</p><p>　　</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247489881&amp;amp;idx=1&amp;amp;sn=fd30734494272ec71ea9d77e2a2d2b00&amp;amp;chksm=eb539c6fdc241579e420b8a44eca80c50599cf3b11490e240781db064478681bf7b0ea03275f&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=08070ZxRSbrvgs6UPJgpCTAe&amp;amp;sharer_sharetime=1565143685590&amp;amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;到底什么是重入锁，拜托，一次搞清楚！&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>md文档基础语法</title>
    <link href="https://mlone.top/2019/09/05/md%E6%96%87%E6%A1%A3%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://mlone.top/2019/09/05/md文档基础语法/</id>
    <published>2019-09-05T13:25:48.000Z</published>
    <updated>2019-09-10T14:11:52.515Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>转自：<a href="https://www.cnblogs.com/liugang-vip/p/6337580.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/6337580.html</a></p><br><a id="more"></a><p></p><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><p>　　<img src="/blogImg/2019/9/5/1-1.png" alt><br>　　<img src="/blogImg/2019/9/5/1-2.png" alt><br>　　前面带#号，后面带文字，分别表示h1-h6,上图可以看出，只到h6，而且h1下面会有一条横线，注意，#号后面有空格。</p><h1 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h1><p>　　无序列表可以使用*，+，- 来创建：<br>　　<img src="/blogImg/2019/9/5/1-3.png" alt><br>　　<img src="/blogImg/2019/9/5/1-4.png" alt><br>　　有序列表使用：数字+英文的点，特别注意，有序列表的序号是根据第一行列表的数字顺序来的：<br>　　<img src="/blogImg/2019/9/5/1-5.png" alt><br>　　<img src="/blogImg/2019/9/5/1-6.png" alt></p><h1 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3. 区块引用"></a>3. 区块引用</h1><p>　　<img src="/blogImg/2019/9/5/1-7.png" alt><br>　　<img src="/blogImg/2019/9/5/1-8.png" alt><br>　　无序列表下方的便是引用，用法就是在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格。因为引用是一个区块，所以理论上应该什么内容都可以放，比如说：标题，列表，引用等等。</p><h1 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4. 分割线"></a>4. 分割线</h1><p>　　分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，且不需要连续，有空格也可以：<br>　　<img src="/blogImg/2019/9/5/1-9.png" alt><br>　　<img src="/blogImg/2019/9/5/1-10.png" alt></p><h1 id="5-链接"><a href="#5-链接" class="headerlink" title="5. 链接"></a>5. 链接</h1><p>　　行内式：<br>　　<img src="/blogImg/2019/9/5/1-11.png" alt><br>　　<img src="/blogImg/2019/9/5/1-12.png" alt><br>　　参数式：<br>　　<img src="/blogImg/2019/9/5/1-13.png" alt><br>　　<img src="/blogImg/2019/9/5/1-14.png" alt></p><h1 id="6-图片"><a href="#6-图片" class="headerlink" title="6. 图片"></a>6. 图片</h1><p>　　图片也有2种方式：行内式和参数式，用法跟链接的基本一样，唯一的不同就是，图片前面要写一个！<br>　　<img src="/blogImg/2019/9/5/1-15.png" alt><br>　　<img src="/blogImg/2019/9/5/1-16.png" alt></p><h1 id="7-代码框"><a href="#7-代码框" class="headerlink" title="7. 代码框"></a>7. 代码框</h1><p>　　如果只有单行的话，可以用单反引号包起来：<br>　　<img src="/blogImg/2019/9/5/1-17.png" alt><br>　　<img src="/blogImg/2019/9/5/1-18.png" alt><br>　　多行用三个反引号，如果要写注释，可以在反引号后面写：<br>　　<img src="/blogImg/2019/9/5/1-19.png" alt><br>　　<img src="/blogImg/2019/9/5/1-20.png" alt>　</p><h1 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h1><p>　　<img src="/blogImg/2019/9/5/1-21.png" alt><br>　　<img src="/blogImg/2019/9/5/1-22.png" alt><br>　　从这3种不同写法看，表格的格式不一定要对的非常起，但是为了好看，对齐肯定是最好的，第一种的分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中，还是有点意思的，不过现实出来的结果是，表格外面并没有线框包起来，不知道别人的怎么弄的。</p><h1 id="9-强调"><a href="#9-强调" class="headerlink" title="9. 强调"></a>9. 强调</h1><p>　　一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗：<br>　　<img src="/blogImg/2019/9/5/1-23.png" alt><br>　　<img src="/blogImg/2019/9/5/1-24.png" alt></strong></em></p><h1 id="10-转义"><a href="#10-转义" class="headerlink" title="10. 转义"></a>10. 转义</h1><p>　　就不一一列举了，基本上跟js转义是一样的：<br>　　<img src="/blogImg/2019/9/5/1-25.png" alt><br>　　<img src="/blogImg/2019/9/5/1-26.png" alt></p><h1 id="11-删除线"><a href="#11-删除线" class="headerlink" title="11. 删除线"></a>11. 删除线</h1><p>　　<img src="/blogImg/2019/9/5/1-27.png" alt><br>　　<img src="/blogImg/2019/9/5/1-28.png" alt></p><p><strong>参考文献：</strong><br>　　<a href="http://www.appinn.com/markdown/" target="_blank" rel="noopener">http://www.appinn.com/markdown/</a><br>　　<a href="http://sspai.com/25137" target="_blank" rel="noopener">http://sspai.com/25137</a>　　　　　　</p><p>　　</p><p>　　</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;转自：&lt;a href=&quot;https://www.cnblogs.com/liugang-vip/p/6337580.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/liugang-vip/p/6337580.html&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>他们-李志</title>
    <link href="https://mlone.top/2019/08/26/%E4%BB%96%E4%BB%AC-%E6%9D%8E%E5%BF%97/"/>
    <id>https://mlone.top/2019/08/26/他们-李志/</id>
    <published>2019-08-26T15:40:53.000Z</published>
    <updated>2019-08-26T15:45:41.765Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>歌曲：《他们》   作者：李志</p><br><a id="more"></a><p></p><p>　　有人在哭泣，有人在歌唱，有人生来有钱包<br>　　有人在奋斗，有人在幻想，有人一生没吃饱<br>　　<br>　　他们指向左，他们指向右，他们买了壮阳药<br>　　我们不能说，我们不能做，我们的生活多美好<br>　　<br>　　啦啦啦啦啦啦，啦啦啦啦啦啦<br>　　啦啦啦啦啦啦，我们的生活多美好<br>　　<br>　　铁路向西走，长江不能流，到底谁才是走狗<br>　　天亮漱漱口，天黑动动手，劳动为了给税收<br>　　他们指向左，他们指向右，他们一直有洋楼<br>　　我们没有闹，我们不能叫，我们的生活带套套<br>　　<br>　　啦啦啦啦啦啦，啦啦啦啦啦啦<br>　　啦啦啦啦啦啦，我们的生活多美好<br>　　<br>　　爸爸喜欢嫖，妈妈就会吵，上学还要请家教<br>　　爷爷睡不著，奶奶看不到，白衣天使真是好<br>　　他们指向左，他们指向右，总是有狗跟著跑<br>　　我们没有闹，我们没上吊，这样还不算厚道？<br>　　<br>　　啦啦啦啦啦啦，啦啦啦啦啦啦<br>　　啦啦啦啦啦啦，怎样才算是厚道<br>　　<br>　　无极是无耻，春晚是婊子，疯狂的石头有意思<br>　　孙逸仙同志，毛润之博士，阿扁闲著没吊事<br>　　他们指向左，他们指向右，你我不能没脑子<br>　　闭眼随便过，睁眼将就活，我们的生活多美好<br>　　<br>　　啦啦啦啦啦啦，啦啦啦啦啦啦<br>　　啦啦啦啦啦啦，我们的生活多美好<br>　　<br>　　啦啦啦啦啦啦，啦啦啦啦啦啦<br>　　啦啦啦啦啦啦，我们的生活多美好</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;歌曲：《他们》   作者：李志&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://mlone.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>少年歌行</title>
    <link href="https://mlone.top/2019/08/26/%E5%B0%91%E5%B9%B4%E6%AD%8C%E8%A1%8C/"/>
    <id>https://mlone.top/2019/08/26/少年歌行/</id>
    <published>2019-08-26T15:22:10.000Z</published>
    <updated>2019-08-26T15:44:17.192Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>动漫：《少年歌行》    作者：无心（叶世安）</p><br><a id="more"></a><p></p><p>　　我欲乘风向北行，雪落轩辕大如席。<br>　　<br>　　我欲借船向东游，绰约仙子迎风立。<br>　　<br>　　我欲踏云千万里，庙堂龙吟奈我何？<br>　　<br>　　昆仑之巅沐日光，沧海绝境见青山。<br>　　<br>　　长风万里燕归来，不见天涯人不回！</p><p>　　<img src="/blogImg/7/1.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;动漫：《少年歌行》    作者：无心（叶世安）&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://mlone.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>湖心亭看雪</title>
    <link href="https://mlone.top/2019/08/06/%E6%B9%96%E5%BF%83%E4%BA%AD%E7%9C%8B%E9%9B%AA/"/>
    <id>https://mlone.top/2019/08/06/湖心亭看雪/</id>
    <published>2019-08-05T16:50:31.000Z</published>
    <updated>2019-09-05T14:49:38.584Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>【作者】张岱  【朝代】明</p><br><a id="more"></a><p></p><p>　　崇祯五年十二月，余住西湖。大雪三日，湖中人鸟声俱绝。是日更定矣，余拏一小舟，拥毳衣炉火，独往湖心亭看雪。雾凇沆砀，天与云与山与水，上下一白。湖上影子，惟长堤一痕、湖心亭一点、与余舟一芥、舟中人两三粒而已。</p><p>　　到亭上，有两人铺毡对坐，一童子烧酒炉正沸。见余大喜曰：“湖中焉得更有此人！”拉余同饮。余强饮三大白而别。问其姓氏，是金陵人，客此。及下船，舟子喃喃曰：“莫说相公痴，更有痴似相公者。”<br>　　<img src="/blogImg/6/6.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;【作者】张岱  【朝代】明&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://mlone.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="古诗词" scheme="https://mlone.top/tags/%E5%8F%A4%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>《长干行-君家何处住》</title>
    <link href="https://mlone.top/2019/08/06/%E3%80%8A%E9%95%BF%E5%B9%B2%E8%A1%8C-%E5%90%9B%E5%AE%B6%E4%BD%95%E5%A4%84%E4%BD%8F%E3%80%8B/"/>
    <id>https://mlone.top/2019/08/06/《长干行-君家何处住》/</id>
    <published>2019-08-05T16:38:37.000Z</published>
    <updated>2019-08-05T16:45:30.342Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>【作者】崔颢   【朝代】唐</p><br><a id="more"></a><br>　　<br>　　<img src="/blogImg/6/5.jpg" alt>　　<p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;【作者】崔颢   【朝代】唐&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://mlone.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="古诗词" scheme="https://mlone.top/tags/%E5%8F%A4%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
</feed>
