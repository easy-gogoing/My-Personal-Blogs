<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Easygo_Space</title>
  
  <subtitle>The quick brown fox jumps over the lazy dog.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mlone.top/"/>
  <updated>2019-05-07T06:44:22.761Z</updated>
  <id>https://mlone.top/</id>
  
  <author>
    <name>easy go</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《心迷宫》简单解读</title>
    <link href="https://mlone.top/2018/09/11/%E3%80%8A%E5%BF%83%E8%BF%B7%E5%AE%AB%E3%80%8B%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/"/>
    <id>https://mlone.top/2018/09/11/《心迷宫》简单解读/</id>
    <published>2018-09-11T06:17:37.000Z</published>
    <updated>2019-05-07T06:44:22.761Z</updated>
    
    <content type="html"><![CDATA[<p>忻钰坤第二弹<br>原文地址：<a href="http://i.mtime.com/5807981/blog/7926134/" target="_blank" rel="noopener">《心迷宫》：迷宫尽头是生存本能</a><br><a id="more"></a></p><p>  电影前10分钟，留下了太多的悬念。这几个看似无关的“线头”故意“现出来”，稍后由它们牵扯出余下的“线”——一条条相互交缠。</p><p>  那些可能永远无法解释的巧合，常常被称之为“命运”的东西，其实存在它的合理性——不过是每个人在衡量自己利益最大化之后的选择。这种趋利避害，也不过是生存的本能而已。</p><p>  <img src="/blogImg/2/1.jpg" alt></p><h5 id="发生在村里的故事"><a href="#发生在村里的故事" class="headerlink" title="发生在村里的故事"></a>发生在村里的故事</h5><p>  故事发生在村里。对这个地点，或者说这个组成社会的一个单位，村是一个极有意思的存在。说它有意思是因为，它的原始性、自然性和独特性。村，是社会化的产物，但同时它又不那么科学化、理性化、法制化。</p><p>  在村之上乡镇、城市似乎都遵循着一个“法”，但村稍稍不同，它更本源的延续了人类凝聚之后的另一种约束方式——道德。在一个村之中，有时候是不讲法的，更多的是理、是信、是义，是约定俗成，是人情世故，是中庸之道。所以，这样一个近似荒诞，看似缺乏逻辑的存在，其实在村里是非常合理的存在。因为，村是自成运作系统的。</p><p>  比如影片中村长的推选，便是建立在信义的基础上。在妻子口中我们知道，老村长为村子兢兢业业，从不贪图，所以换届选举完胜用金钱拉选票的人。在村民们眼中，能为自己办实事，人品上德高望重，办事上以村民利益为先的，便是好村长。而这种道德上的“选举”和“任命”无论在凝聚力上还是在民心所向上，无疑都是更加人性化的。结尾处，无论是老村长要辞去村长一职，还是去自首，其实都是内心中无法跨过道德这道坎。</p><p>  <img src="/blogImg/2/2.jpg" alt></p><h5 id="村里的事都是稀里糊涂的"><a href="#村里的事都是稀里糊涂的" class="headerlink" title="村里的事都是稀里糊涂的"></a>村里的事都是稀里糊涂的</h5><p>  要说人活着，大事小事有时候该糊涂的时候就得糊涂。很多事情都没办法钉是钉铆是铆的去深究。中国人有一句俗话叫“难得糊涂”，虽然是一个公认的可以称得上是知识分子的老先生郑板桥提出来的，但它恰好最大的体现在村里人中。</p><p>  电影中的故事，可能有人会很不理解：怎么死了人，不报警、不验尸、不走法律程序呢？仅仅凭一句话就盖棺定论了呢？从第一个亡者开始，这种“约定俗成”便很好的说明了这个问题：村里的事儿，只要是大家认可了的，在村里就能解决，何必大动干戈？开篇的引子，已经为整部戏定下了基调：一个老头去烧山，结果自己没走出来烧死掉了。大家公认，合情合理，自然没有必要去报案。用棺材装了，停三天，埋了，大家吃个流水席。那么这件事在村里就算是了了。于是乎，当村里接二连三出现尸体的时候，只要有一个适当的解释，那么这自然就不是事。正所谓“民不举，官不究”。单反符合了村里大致的说法，完成了大家公认的程序，每个人都有一个知会，那么这便不再是个事儿。</p><p>  令人感到好笑和荒诞的地方是，为什么最后根本没人深究死人究竟是谁？大家自己过上了自己想要的生活，那么好奇心只会平添烦恼，所以何必事事都要弄得请清除吃吃呢？如果影片最后没有出现那几行字的结局，仅仅是一具棺椁和三个人的心照不宣，村里的生活还将继续。可能过上几个月便是全村兴高采烈地喝上欢欢和和宗耀的喜酒也说不定哦！</p><p>  <img src="/blogImg/2/3.jpg" alt></p><h5 id="村里的人都是精明智慧的"><a href="#村里的人都是精明智慧的" class="headerlink" title="村里的人都是精明智慧的"></a>村里的人都是精明智慧的</h5><p>  要说这事情可能是糊涂，但这人却极为精明。村里是一个相对封闭的环境，人在这种氛围中几乎可以完全熟悉任意一个人的秘密。相处久了，基本上张家长李家短的，没有不知道的。所以，每个人心中都有一杆秤，衡量着自己，也衡量着别人。</p><p>  之所以说越是底层人也是聪明，是因为他们可以循着本能取追求自己利益的最大化。几个镜头中出现的电视节目，播放的都是星星生活的场景，这并非巧合，而是一种映射——从本质上讲，人和动物没什么区别，生存才是最重要的。如何生活的更好，是每个人都追求的。我们完全可以看到，每个人的每条线都如此清晰的摆在眼前。他们的每一次选择都是按照如何最大限度实现自己利益为前提的。而人生，不过就是一次次选择的叠加，于是，每一次选择下来，人生的走向便有所不同。本片中，可笑的是，很多人的“最优选择”却导致的是“最惨后果”。但综合利弊，你却无法指责他每次选择上的正确性，或许这就是我们所说的“命”。</p><p>  要说最智慧的存在，其实还是人民群众。电影展现的非常简洁，却真实的让人汗毛都能竖起来：人在生存的时候，无非就是见招拆招。或许这句话有些武侠化了，那么用普通话说，就是：出事儿，想辙。在事情发生的几乎不到48小时中，你听不到抱怨。事情出了，最简单直接的方式就是想办法解决。而这才是最普通却也是最值得竖起大拇指的行为。</p><p>  人生其实很简单，就像我的曾经在牌桌上说的一句话：不要抱怨你手里的牌，重要的是如何打好一手烂牌。电影中每个人也都是如此，最原始的趋利避害，最原始的解决问题，最原始的寻找生存下来的途径。而这，就是人与生俱来的智慧所在。</p><p>  在九百六十万平方公里的土地上，法律所及的地方太小。从根本上，这是一个讲情的国度，而这情，人类，其实就是这样祖祖辈辈生生不息的延续着。</p><p>  <img src="/blogImg/2/4.jpg" alt></p><p><strong>PS：</strong></p><ol><li>影片最后几行字的交代，应该并非原作者的本意吧。相信他应该也能明白，只留下最后一个镜头就好，整部影片的深意完完全全会提升两个档次！那种民族或人类最原始的东西都在涌动着。当然，为了能让更多人看到，加一个“尾巴”也可以理解。</li><li>人都是以自我为中心运转着，如果说每个人是一个小宇宙，那么可能你永远预料不到的是他人对你的影响，以及你背后更大的银河系发生着什么样的事。一切都是玄而又玄的，变数时时存在。</li></ol><h5 id="最后加几张电影海报："><a href="#最后加几张电影海报：" class="headerlink" title="最后加几张电影海报："></a>最后加几张电影海报：</h5><p>  <img src="/blogImg/2/5.jpg" alt><br>  <img src="/blogImg/2/6.jpg" alt><br>  <img src="/blogImg/2/7.jpg" alt><br>  <img src="/blogImg/2/8.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忻钰坤第二弹&lt;br&gt;原文地址：&lt;a href=&quot;http://i.mtime.com/5807981/blog/7926134/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《心迷宫》：迷宫尽头是生存本能&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="影视" scheme="https://mlone.top/categories/%E5%BD%B1%E8%A7%86/"/>
    
    
      <category term="电影" scheme="https://mlone.top/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>《爆裂无声》深度解析</title>
    <link href="https://mlone.top/2018/09/10/%E3%80%8A%E7%88%86%E8%A3%82%E6%97%A0%E5%A3%B0%E3%80%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>https://mlone.top/2018/09/10/《爆裂无声》深度解析/</id>
    <published>2018-09-10T06:04:02.000Z</published>
    <updated>2019-05-07T08:17:33.180Z</updated>
    
    <content type="html"><![CDATA[<p>忻钰坤第一弹<br>原文地址：<a href="https://baijiahao.baidu.com/s?id=1601128884575929109&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">百家号：我爱烧脑之《暴裂无声》深度解析！这部悬疑电影你看懂了多少？</a><br><a id="more"></a></p><p>  电影《暴裂无声》是由忻钰坤执导的犯罪悬疑片，姜武、宋洋、袁文康、谭卓等主演。暴裂无声剧情讲述了在北方凛冽的冬天，一个牧羊少年带着自家的羊群在山里行走…<br>  <strong>不知道当你看完《暴裂无声》，是不是也和电影的主角一样，不想声，失语了……</strong><br><img src="/blogImg/1/1.jpg" alt><br>  电影的剧情其实挺简单，《暴裂无声》的内容和片名一样，无声的暴力罢了。男主是哑者张保民，以拳头显示暴力，从头打到尾，只是这种近乎的暴力却只是最低能无力的；外表光鲜却身处灰色地带的徐律师，看似平静温文尔雅，沉默少言，他表现的暴力却最为阴冷可怕！当然还有强有力的施暴者姜武饰演的土豪金主昌老板，，他所表现出来的暴力是多元化，最全面的。记得电影里有一个场面：昌老板坐在一满桌切盘羊肉前吃着火锅，旁边机器在咔嚓咔嚓地切着羊肉，另一个矿主说自己信佛吃素，昌老板却淡然地讲到：“羊也是吃素的……”接着殴打，威胁，恐吓等等手段跃然而出，完胜！<br>  <img src="/blogImg/1/2.jpg" alt><br>  这三个男人唱出了一部完美诠释暴力，却控诉无声的悲剧！整部剧的精彩烧脑之处并不是通常悬疑剧的翻转结局，而是在好似不经意间表现出的一个个细节场景。所有细节场景的串联，才是这部烧脑片的精华所在。电影里的主角只是在引导着剧情的发展，而看懂细节，你才是真正的主角。不过，所有细节串联只有等到看完整部电影才会让你都明白过来。<br>  <img src="/blogImg/1/3.jpg" alt></p><h5 id="细节一"><a href="#细节一" class="headerlink" title="细节一:"></a>细节一:</h5><p>  张保民得知儿子失踪回家遇到村长，村长递给张保民抽的洋烟在后来昌老板的桌子上出现了。村长整车的往自己家运矿泉水。这两点说明了昌老板和村长之间的利益输送，村长明知道开矿污染了水源，却只顾自己的安危，贪图了昌老板的贿赂。</p><h5 id="细节二"><a href="#细节二" class="headerlink" title="细节二:"></a>细节二:</h5><p>  昌老板非常喜欢射杀动物和吃羊肉，在最后要射杀张保民的打斗中又表现出了射击水平非常差，加上当手下打手为了威胁张保民交出律师女儿而谎称张保民的儿子在他手中，昌老板气急败坏之下的把手下打的奄奄一息，这些都表明了，徐律师帮昌老板做完伪证，昌老板给徐律师贿赂后心情大好，想要射杀小羊取乐享用，可是在远处放羊的张保民儿子不同意，保护着他心爱的小羊，昌老板依然射击了小羊，却误杀了张保民的儿子。</p><h5 id="细节三："><a href="#细节三：" class="headerlink" title="细节三："></a>细节三：</h5><p>  昌老板的第一次露面，穿着一身干净的西装，站在校长室，一遍看着学生的照片，一遍吃着西红柿，吃相很难看，与他的穿着形成了鲜明的对比，这里解释一下为什么不吃苹果香蕉之类的而是吃西红柿，西红柿是红色的，象征着生命和鲜血，由于吃的太急，西红柿的汁流到了昌老板的衣服上，但昌老板用纸巾怎么擦也擦不掉，这也表达了做过坏事留下的痕迹是不容易抹去的。</p><h5 id="细节四"><a href="#细节四" class="headerlink" title="细节四:"></a>细节四:</h5><p>  昌老板在练习弓箭的时候，弦已拉满，却又最终放弃了，虽然这时候导演并没有给出昌老板回忆的镜头，但不难看出，此时的昌老板内心世界是极其复杂的，他在收拾弓箭时，镜头中有一支箭是没有箭头的。箭头第一次出现是在张保民被绑在吉普车后备箱，张保民摸到了箭头并用它解开了脚上的绳子，还有是到结尾的时候，昌老板跟张保民发生冲突，昌老板快要包张保民勒断气的时候，张保民摸到昌老板口袋里的箭头，果断地把它刺进昌老板的大腿里，这才得以空隙出手反击。</p><p>  这里要补充说明一下，昌老板一直向徐律师索要证据，而徐律师也一头雾水，徐律师其实是真不知道，因为昌老板杀人的证据一直被遗忘在他吉普车的后备箱里，就是那个箭头。这也解释了为什么昌老板会把那个箭头放在裤兜了，最后匆匆把它埋进土里。</p><p>   <img src="/blogImg/1/4.jpg" alt></p><h5 id="细节五"><a href="#细节五" class="headerlink" title="细节五:"></a>细节五:</h5><p>  张保民儿子的鬼魂出现在山洞里解开徐律师女儿的绳索和徐律师把女儿抱出山洞后，向着山洞深处的黑暗里偷偷看了一眼，表达了张磊的尸体就被埋在这个山洞深处，徐律师知道，却还是没有告诉张保民。这就和最后徐律师的一句：“没有。”相互辉映，揭示了人性的可怕。</p><h5 id="细节六"><a href="#细节六" class="headerlink" title="细节六:"></a>细节六:</h5><p>  因为非法采矿，导致矿物污染，所有井水才会越来越难喝，村长才会 一车一车的运纯净水回家，张保民的妻子、栓子的母亲以及更多的村民才会得了怪病，失踪的张磊才会看见小鸟的尸体……</p><h5 id="细节七"><a href="#细节七" class="headerlink" title="细节七:"></a>细节七:</h5><p>  酷爱吃羊肉的昌总为什么会掉那么多头发以导致前额发秃，因为他吃的也都是这个矿区的羊。</p><p>而这种“以彼之道还施彼身”巧妙且富有深意的设计，在电影中还有三处：<br>  一是那枚要了人命、怎么也找不到的箭头，最终扎到了昌总自己身上！<br>  二是律师跟着张保民来到藏护女儿的山洞，他开始恍惚、害怕，因为这个地方也藏着他的秘密！<br>  三是羊肉店老板逼着张保民在拆迁补上签字，换来的不仅是自己瞎了一只眼，更是自己的儿子因为环境污染而精神失常。</p><p>   <img src="/blogImg/1/5.jpg" alt></p><p>   <strong>总结：</strong>虽然最后的结局是让人无言以对的可悲，各种暴力覆盖了一切！山的坍塌，张磊尸体的消失都揭露了黑暗的存在，但是剧中的细节已经表达过一个道理：恶有恶报！出来混总是要还的！<br>  就让我们依靠着剧中曾经虚幻出的两个小孩纯真的站在山上俯瞰这个城市的场景，看出些许希望吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忻钰坤第一弹&lt;br&gt;原文地址：&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1601128884575929109&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百家号：我爱烧脑之《暴裂无声》深度解析！这部悬疑电影你看懂了多少？&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="影视" scheme="https://mlone.top/categories/%E5%BD%B1%E8%A7%86/"/>
    
    
      <category term="电影" scheme="https://mlone.top/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>nginx的作用</title>
    <link href="https://mlone.top/2018/08/10/nginx%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://mlone.top/2018/08/10/nginx的作用/</id>
    <published>2018-08-10T14:36:17.000Z</published>
    <updated>2019-05-09T14:38:27.690Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>参考：<a href="https://blog.csdn.net/qq_36178641/article/details/80110981" target="_blank" rel="noopener">正向代理和反向代理概述</a></p><br><a id="more"></a><p></p><h4 id="一、作为静态资源服务器"><a href="#一、作为静态资源服务器" class="headerlink" title="一、作为静态资源服务器"></a>一、作为静态资源服务器</h4><p>可以通过http请求访问服务器上的静态资源。（首页广告图片、商品图片显示、图片上传回显）　　</p><h4 id="二、反向代理与负载均衡："><a href="#二、反向代理与负载均衡：" class="headerlink" title="二、反向代理与负载均衡："></a>二、反向代理与负载均衡：</h4><p>　　正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p><p>　　<strong>反向代理</strong>，主要用于<strong>服务器集群分布式部署</strong>的情况下，反向代理隐藏了服务器的信息！</p><p>　　多个客户端给服务器发送的请求，nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，nginx扮演的就是一个反向代理角色</p><p>　　客户端发送的、nginx反向代理服务器接收到的<strong>请求数量</strong>，就是我们说的<strong>负载量</strong><br>　　请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种<strong>均衡规则</strong></p><p>　　所以<strong>~将服务器接收到的请求按照规则分发的过程</strong>，称为<strong>负载均衡</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/qq_36178641/article/details/80110981&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正向代理和反向代理概述&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>spring与springmvc</title>
    <link href="https://mlone.top/2018/08/07/spring%E4%B8%8Espringmvc/"/>
    <id>https://mlone.top/2018/08/07/spring与springmvc/</id>
    <published>2018-08-07T14:31:58.000Z</published>
    <updated>2019-05-09T14:35:54.949Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>转自：<a href="https://blog.csdn.net/jonesAriven/article/details/80036602" target="_blank" rel="noopener">spring与springmvc的区别与联系</a></p><br><a id="more"></a><p></p><h5 id="一、spring框架的介绍"><a href="#一、spring框架的介绍" class="headerlink" title="一、spring框架的介绍"></a>一、spring框架的介绍</h5><p>　　<strong>spring是一个一站式的框架，提供了表现层（springmvc）到业务层（spring）再到数据层（springdata）的全套解决方案；</strong>spring的两大核心IOC(控制反转)和AOP(面向切面编程)更是给我们的程序解耦和代码的简介提供了支持。　　</p><h5 id="二、springmvc"><a href="#二、springmvc" class="headerlink" title="二、springmvc"></a>二、springmvc</h5><p>（1）<strong>springmvc给spring的表现层提供支持</strong></p><p>（2）springmvc的流程：<br>　　1.用户发送请求至<strong>前端控制器DispatcherServlet；</strong><br>　　2.DispatcherServlet收到请求调用<strong>HandlerMapping处理器映射器；</strong><br>　　3.处理器映射器根据<strong>请求url</strong>找到具体的处理器，生成<strong>处理器对象</strong>及<strong>处理器拦截器</strong>(如果有则生成)一并返回给DispatcherServlet；<br>　　4.DispatcherServlet通过<strong>HandlerAdapter处理器适配器</strong>调用处理器，执行<strong>处理器</strong>(Controller，也叫后端控制器)；<br>　　5.Controller执行完成返回ModelAndView，并返回给HandlerAdapter，HandlerAdapter将结果返回给DispatcherServlet；<br>　　6.DispatcherServlet将ModelAndView传给<strong>ViewReslover视图解析器</strong>，ViewReslover解析后返回具体View给DispatcherServlet；<br>　　7.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）后返回给客户　　</p><h5 id="三、AOP与IOC"><a href="#三、AOP与IOC" class="headerlink" title="三、AOP与IOC"></a>三、AOP与IOC</h5><p>（1）AOP与IOC给spring的业务层提供支持，使程序的耦合度更低，代码更简洁</p><p>（2）AOP原理：即面向切面编程，就是提取公共部分，集中解决一些公共问题</p><p>（3）IOC原理：控制反转。在传统过程中，当某一个对象依赖于另外一个对象时，会由该对象去创建另外一个对象，有了ioc后，将创建过程交给IOC,由spring创建bean，从而只需给该对象注入即可</p><p><strong>问：什么是AOP和IOC，它们的作用是什么?</strong></p><p>　　AOP：(Aspect Oriented Programing) 面向切面编程。<br>　　是指<strong>使用动态代理模式，在一个事务中无缝地插入多条其他处理。</strong></p><p>　　作用：Spring使用aop声明式事务控制，通过横向抽取方法将service层中的事务控制的代码抽取出来。</p><p>　　IOC： (Inverse of Control) 控制反转。<br>　　是指<strong>将原来程序中自己创建实现类对象的控制权反转到IOC容器中。只需要通过IOC来获对象的实例，将IOC当成一个黑盒子、工厂。</strong></p><p>　　作用：Spring提供ioc容器，对 bean进行实例化。使用bean时候从容器中取。还可以实现依赖注入(DI)，将对象需要的bean注入到其对象属性中。</p><p><strong>拓展：AOP的概念</strong></p><p>　　Aspected Oriented Programming 面向方面编程。</p><p>　　好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。</p><p>实现AOP有几种方式：<br>　　1.Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等。<br>　　2.Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口。<br>　　3.三使用标注（@AspectJ）实现AOP。</p><p>AOP 和 OOP的区别：<br>　　1.面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。<br>　　2.面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。<br>　　也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>　　AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/jonesAriven/article/details/80036602&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring与springmvc的区别与联系&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
  </entry>
  
  <entry>
    <title>MyBatis与Hibernate的区别</title>
    <link href="https://mlone.top/2018/08/06/MyBatis%E4%B8%8EHibernate%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://mlone.top/2018/08/06/MyBatis与Hibernate的区别/</id>
    <published>2018-08-06T14:29:48.000Z</published>
    <updated>2019-05-09T14:31:34.276Z</updated>
    
    <content type="html"><![CDATA[<p></p><p></p><br><a id="more"></a><p></p><h4 id="什么是mybatis？"><a href="#什么是mybatis？" class="headerlink" title="什么是mybatis？"></a>什么是mybatis？</h4><p>　　mybatis是一个持久层的框架，是apache下的顶级项目。一开始托管到goolecode下，再后来托管到github下(<a href="https://github.com/mybatis/mybatis-3/releases)。" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases)。</a></p><p>　　mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。</p><p>　　mybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射）</p><h4 id="Mybatis与Hibernate的区别？"><a href="#Mybatis与Hibernate的区别？" class="headerlink" title="Mybatis与Hibernate的区别？"></a>Mybatis与Hibernate的区别？</h4><p><strong>hibernate：</strong><br>　　是一个标准ORM框架（对象关系映射）。入门门槛较高的，不需要程序写sql，sql语句自动生成了。对sql语句进行优化、修改比较困难的。</p><p>应用场景：<br>　　适用与需求变化不多的中小型项目，比如：后台管理系统，erp、orm、oa…<br>　　<br><strong>mybatis：</strong><br>　　专注于sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。<br>　　mybatis是一个不完全 的ORM框架，虽然程序员自己写sql，mybatis 也可以实现映射（输入映射、输出映射）。</p><p>应用场景：适用与需求变化较多的项目，比如：互联网项目。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
  </entry>
  
  <entry>
    <title>Struts2学习笔记</title>
    <link href="https://mlone.top/2018/08/05/Struts2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://mlone.top/2018/08/05/Struts2学习笔记/</id>
    <published>2018-08-05T14:25:34.000Z</published>
    <updated>2019-05-09T14:29:28.684Z</updated>
    
    <content type="html"><![CDATA[<p></p><p></p><br><a id="more"></a>　　<p></p><h4 id="1-什么是Struts2？"><a href="#1-什么是Struts2？" class="headerlink" title="1.什么是Struts2？"></a>1.什么是Struts2？</h4><p>　　javaEE三层架构：表现层、业务层、持久层，为了提高开发效率，方便项目管理。</p><p>技术结构发展：<br>　　1.单独使用jsp/servlet、<br>　　2.使用jsp+javabean：（model1模式）、<br>　　3.使用：jsp+servlet+javaBean（model2模式）</p><p>　　Model2模式即MVC模式，MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写。</p><p>存在的问题：<br>　　1.控制逻辑复杂且不通用（多个请求得写多个Servlet）。<br>　　2.表现（视图）技术单一，只使用jsp，能否使用其它表现层技术（freemarker，pdf、xls）。<br>　　3.对请求的参数的解析（需手动单独获取每个参数request.getParameter()）。</p><p>　　Struts2 是apache的一个开源项目，它是纯java开发，它是一个非常优秀的MVC框架，基于Model2 设计模型。　　</p><h4 id="2-Struts2的结构优点"><a href="#2-Struts2的结构优点" class="headerlink" title="2.Struts2的结构优点"></a>2.Struts2的结构优点</h4><p>解决jsp+servlet+javabean中的问题：<br>　　1.将控制逻辑单独封装成通用的控制器<br>　　2.原控制逻辑中封装请参数、调用业务逻辑代码抽取出来。<br>　　3.支持多视图技术。</p><p>（1）控制器<br>　　struts2提供前端控制器（Struts2PreparedAndExecutFilter），将控制逻辑封装起来，接收请求。</p><p>（2）模型<br>　　封装请求参数，进行业务处理。<br>struts2提供了action接口，根据业务需求开发不同的action，比如：注册用户Action</p><p>（3）提供Result接口，支持多视图技术<br>　　Result将结果响应给用户。　　</p><h4 id="3-Struts2处理请求的全过程是什么"><a href="#3-Struts2处理请求的全过程是什么" class="headerlink" title="3.Struts2处理请求的全过程是什么?"></a>3.Struts2处理请求的全过程是什么?</h4><p>　　1.当客户端浏览器向服务器端发送请求，会被Struts2的核心前端控制器（一个过滤器）所拦截，然后根据struts2.xml配置文件中的内容来决定调用哪个前端控制器action；</p><p>　　2.前端控制器action接收到请求后，会根据请求的method方法名调用函数进行处理；</p><p>　　3.处理完成后，会返回一个逻辑视图名，然后根据struts2.xml中配置的action的result来决定要跳转到哪个前端页面。</p><p>　　</p><h4 id="4-属性驱动"><a href="#4-属性驱动" class="headerlink" title="4.属性驱动"></a>4.属性驱动</h4><p>　　属性驱动是struts2提供的一种参数绑定机制，如果按照struts指定的开发规则，自动请求的参数设置（赋值）到struts的action类的属性中。</p><p>属性驱动开发规则：<br>　　1.确定请求参数的名称。<br>　　2.在action类中添加属性，属性名和参数名称一致，并且添加 get/set方法。</p><p>　　属性驱动支持不同action类属性类型：包括基本数据类型、list、map、数组、pojo。</p><p>　　重点掌握：1.基本类型 2.pojo 3.数组 4.list</p><p>　　</p><h4 id="5-模型驱动"><a href="#5-模型驱动" class="headerlink" title="5.模型驱动"></a>5.模型驱动</h4><p><strong>问题描述：</strong><br>　　使用属性驱动，如果业务方法比较多，添加很多属性及get/set方法，不方便对业务方法进行维护。</p><p><strong>解决方案：</strong><br>　　将action中接收参数属性及get/set方法单独放到其它pojo中，action只剩下业务方法。可以使用struts2提供模型驱动方法开发action。</p><blockquote><p><em>Ognl和值栈是实现模型驱动的基础原理。</em></p></blockquote><blockquote><p><em>OGNL是Xwork框架提供的功能，Xwork是struts2基础架构，Xwork是一个ioc容器。</em></p></blockquote><blockquote><p><em>OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，它是一个开源项目，struts2使用ognl，作为表达式语言。</em></p></blockquote><blockquote><p><em>使用OGNL可以方便向对象中设置属性值，从对象中获取属性值。</em></p></blockquote><p><strong>模型驱动：</strong><br>　　模型驱动是将请求参数绑定到专门的模型对象中，Action实现ModelDriven接口并指定模型对象类型，模型对象类型即为pojo。</p><p>　　</p><h4 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6.拦截器"></a>6.拦截器</h4><p>　　struts2中通过拦截器实现<strong>参数绑定、参数校验、类型转换</strong>，拦截器就是<strong>在action的执行之前或之后</strong>进行拦截执行一些代码，就是对action代码的增强。</p><p><strong>拦截器的特点：</strong><br>　　1.如果使用拦截器可以很方便访问值栈中的数据；<br>　　2.filter过滤器，可以拦截所有的请求；而struts2的拦截器只能拦截用户的请求，即action请求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
  </entry>
  
  <entry>
    <title>Hibernate学习笔记</title>
    <link href="https://mlone.top/2018/08/05/Hibernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://mlone.top/2018/08/05/Hibernate学习笔记/</id>
    <published>2018-08-05T14:10:39.000Z</published>
    <updated>2019-05-09T14:24:11.904Z</updated>
    
    <content type="html"><![CDATA[<p></p><p></p><br><a id="more"></a><p></p><h4 id="1-Hibernate的核心配置文件是什么及其作用"><a href="#1-Hibernate的核心配置文件是什么及其作用" class="headerlink" title="1.Hibernate的核心配置文件是什么及其作用?"></a>1.Hibernate的核心配置文件是什么及其作用?</h4><p>　　hibernate框架默认会加载classpath下的核心配置文件hibernate.cfg.xml</p><p><strong>作用：</strong></p><ol><li><p>加载对象关系映射文件；</p></li><li><p>配置hibernate运行的参数(属性)，如会话工厂所需要的属性：</p></li></ol><p>　　数据库方言（决定了hibenrate发出哪个数据库认识的sql语句）、驱动、连接url、用户名和密码，数据库连接池、事务隔离级别，开启二级缓存等。</p><h4 id="2-sessionFactory会话工厂生命周期"><a href="#2-sessionFactory会话工厂生命周期" class="headerlink" title="2.sessionFactory会话工厂生命周期"></a>2.sessionFactory会话工厂生命周期</h4><p>　　整个运行过程中只有一个sessionFactory实例即可，使用单例模式管理sessionFactory。<br>　　sessionFactory是线程安全的！</p><h4 id="3-Hibernate中有哪几种关联关系？"><a href="#3-Hibernate中有哪几种关联关系？" class="headerlink" title="3.Hibernate中有哪几种关联关系？"></a>3.Hibernate中有哪几种关联关系？</h4><p><strong>4种：</strong><br>一对一，一对多，多对一，多对多</p><h4 id="4-Hibernate对象的三大状态："><a href="#4-Hibernate对象的三大状态：" class="headerlink" title="4.Hibernate对象的三大状态："></a>4.Hibernate对象的三大状态：</h4><ul><li><p><strong>瞬时态 transient</strong><br>new了一个对象，此时对象就是瞬时态；<br>瞬时态对象和数据库记录没有对应关系，和session没有关系。</p></li><li><p><strong>持久态 persistent</strong><br>瞬时态对象执行save方法后变成持久态；<br>持久态对象和数据库记录存在对应关系，和session有关系。<br>修改对象的属性，会直接将数据保存到数据库中。</p></li><li><p><strong>托管态Detached</strong><br>当session关闭后，持久态对象变为托管态。<br>托管态对象和session没有关系，可能和数据库存在对应也可能不对应。</p></li></ul><h4 id="5-QBC"><a href="#5-QBC" class="headerlink" title="5.QBC"></a>5.QBC</h4><p>　　QBC（Query By Criteria）按条件查询，通过Criteria构造查询条件，即通过调用Criteria的api实现各种查询。</p><p>　　通过Criteria对象拼装 查询条件，调用Criteria的add方法拼接查询条件，最终hibernate通过criteria对象自动生成sql语句。</p><p>　　</p><h4 id="6-一级缓存与二级缓存"><a href="#6-一级缓存与二级缓存" class="headerlink" title="6.一级缓存与二级缓存"></a>6.一级缓存与二级缓存</h4><p><strong>一级缓存：</strong></p><ol><li><p>session级别的缓存，是线程级别的缓存；</p></li><li><p>在session中有一块内存区域，存储了持久态的对象；</p></li><li><p>第一次从数据库查询到数据存到session, 当session不关闭，再次查询不会向数据库发出sql；</p></li><li><p>当session关闭了，一级缓存就会被清空。</p></li></ol><p><strong>二级缓存：</strong><br>　　sessionFactory级别的缓存，是进程级别的缓存；<br>　　可以跨session，多个session可以公用二级缓存的数据。<br>　　<br><strong>二级缓存区域：</strong></p><p><strong>1. 类级别缓冲区，存储了散装对象</strong><br>数据结构：map<br>　　[ key：对象的主键值+对象的全类路径，value：对象内容 ]</p><p><strong>2. 查询缓存区域，存储了查询结果集</strong><br>　　任意执行一个sql语句，将sql结果进行缓存<br>　　数据结构：map [ key：sql语句本身+输入参数，value就是List&lt;对象的主键值&gt; ]</p><p>　　</p><h4 id="7-延迟加载"><a href="#7-延迟加载" class="headerlink" title="7.延迟加载"></a>7.延迟加载</h4><p><strong>什么是延迟加载？</strong><br>　　当查询信息，建议只查询需要的信息，对于不需要信息当需要时再去查询，这叫延迟加载。</p><p>　　好处：提高查询性能。<br>　　例子：对象导航查询。</p><ol><li><p>只查询基本信息，不查询关联属性;</p></li><li><p>当调用cstCustomer对象的get方法获取关联属性，再向数据库发出sql，去加载数据。</p></li></ol><p><strong>Get与Load：</strong></p><p>load执行原理：</p><ol><li><p>执行load查询，得到的是一个代理对象，没有发出sql</p></li><li><p>当调用get方法时，通过代理对象向数据库发出sql</p></li></ol><p><strong>延迟加载原理：</strong></p><ol><li><p>生成一个代理对象</p></li><li><p>执行加载时，通过代理对象向数据库发出sql</p></li></ol><p>　　</p><h4 id="8-抓取策略"><a href="#8-抓取策略" class="headerlink" title="8.抓取策略"></a>8.抓取策略</h4><p><strong>什么是抓取策略？</strong><br>　　指当应用程序需要在（Hibernate实体对象图的）关联关系间进行导航的时候， Hibernate如何获取关联对象的策略。</p><p>策略包括：</p><ol><li><p>延迟加载</p></li><li><p>立即加载，将加载到数据抓取到对象的属性中。</p></li></ol><p><strong>（1）类级别的抓取策略</strong><br>　　(这里的lazy是class标签的属性，默认为true)</p><ol><li><p>延迟加载<br>在hbm.xml中class标签内设置lazy=”true”（延迟加载），相当于load方法;</p></li><li><p>立即加载<br>在hbm.xml中class标签内设置lazy=”false”，立即加载，load和get方法效果一样。</p></li></ol><p>　　<br><strong>（2）关联级别的抓取策略（重点掌握）</strong></p><p><strong>一对多、多对多：</strong><br>　　（这里的fetch和lazy位于class标签下的标签上，fetch=”select” lazy=”true”：此为一方的默认值）<br>set元素提供 lazy属性 和 fetch 用于设置 抓取策略：</p><ol><li><p>fetch=”select”(默认)，lazy=”true”(默认)：fetch=”select”每get请求发出sql，lazy=”true”表示延迟加载（一方lazy的值可设为true或false或extra）;</p></li><li><p>fetch=”join”（lazy不起作用）：批量抓取，自动生成左外连接语句，将关联的多方数据抓取到一方的属性中。</p></li><li><p>(一般不用) fetch=”select”（或不写），lazy=”false”，立即加载（注意：但这里的并不是生成左外连接sql，而是新建的查询sql语句去查外联表）。</p></li></ol><p>最佳实践：<br>　　在进行一对多、多对多关联查询时候，只查询基本信息而不需要关联多方数据的，一般情况下最好采用延迟加载的抓取策略。（就像查询客户列表时并不需要立即加载其联系人信息，就将两个表的关系映射配置为延迟加载，即默认设置）</p><p><strong>多对一：</strong><br>　　（这里的fetch和lazy位于class标签下的标签上，fetch=”select” lazy=”proxy”：此为多方的默认值）<br>　　根据客户查询客户来源，多对一。</p><p>hbm采用 元素，提供lazy属性和fetch属性，用来配置抓取策略：</p><ol><li><p>fetch=”join”：自动生成左外连接，将关联一方属性对象抓取到多方的属性，查询客户信息，将many-to-one中fetch设置join，通过qbc查询客户时自动生成一个客户表和数据字典表的关联查询语句。</p></li><li><p>fetch=”select”，lazy=”proxy”：延迟加载</p></li><li><p>(扩展) fetch=”select”（或不写），lazy=”false”：立即加载。比如在查询联系人信息时，会连带其所属的客户信息一并查询出来（注意：但这里的并不是生成左外连接sql，而是新建的查询sql语句去查客户表）。</p></li></ol><p>　　</p><h4 id="9-HQL"><a href="#9-HQL" class="headerlink" title="9.HQL"></a>9.HQL</h4><p>　　HQL是Hibernate Query Language缩写， 语法很像SQL语法，以完全面向对象的方式操作数据库。（QBC能做的HQL都能做，而反之不然）</p><p><strong>HQL对象导航方式：</strong><br>　　Hql可以实现对象导航查询。<br>　　注意：如果使用投影查询，得到List中是舜时态对象，不能使用对象导航。</p><p><strong>HQL关联查询：</strong><br>　　因为经过测试：</p><ol><li><p>HQL对hbm.xml设置 fetch参数无效；</p></li><li><p>HQL对hbm.xml设置lazy=true，lazy=false有效。</p><p>所以通过HQL实现fetch=”join”的功能。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
  </entry>
  
  <entry>
    <title>forward和redirect的区别</title>
    <link href="https://mlone.top/2018/08/02/forward%E5%92%8Credirect%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://mlone.top/2018/08/02/forward和redirect的区别/</id>
    <published>2018-08-02T14:09:18.000Z</published>
    <updated>2019-05-09T14:10:19.851Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>请求转发和重定向</p><br><a id="more"></a><p></p><p><strong>forward：</strong>请求转发，属于同一请求，浏览器的url不会改变，request域中的数据不会丢失。</p><p><strong>redirect：</strong>重定向，属于不同的请求，浏览器的url改变，request域中的数据清空。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;请求转发和重定向&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>JSP有哪些内置对象</title>
    <link href="https://mlone.top/2018/08/02/JSP%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
    <id>https://mlone.top/2018/08/02/JSP有哪些内置对象/</id>
    <published>2018-08-02T14:07:27.000Z</published>
    <updated>2019-05-09T14:24:27.524Z</updated>
    
    <content type="html"><![CDATA[<p></p><p><strong>JSP共9个内置对象：</strong></p><br><a id="more"></a><p></p><p>　　page、request、session 、application、（四大域对象）</p><p>　　response、out、config、exception、</p><p>　　pageContext（可以获取其他八个内置对象；可以操作域；可以全域查找findAttribute）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;JSP共9个内置对象：&lt;/strong&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>Cookie与Session</title>
    <link href="https://mlone.top/2018/08/02/Cookie%E4%B8%8ESession/"/>
    <id>https://mlone.top/2018/08/02/Cookie与Session/</id>
    <published>2018-08-02T13:55:53.000Z</published>
    <updated>2019-05-09T14:07:06.212Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。</p><br><a id="more"></a><p></p><p><strong>Cookie：</strong>保存在本地客户端。<br>　　如果不设置有效时间则默认为一次会话时间，即浏览器关闭即销毁。</p><p>应用：比如，存储用户的登录信息，用户名、密码。</p><p><strong>Session：</strong>保存在服务器端，保存一次会话。<br>　　当浏览器访问服务器时，服务器会创建一个session会话与当前客户端进行连接。</p><p>何时销毁：</p><ol><li><p>程序调用HttpSession.invalidate()方法主动进行销毁；</p></li><li><p>距离客户端上一次发送请求超过了Session的最大有效时间；</p></li><li><p>服务器进程被停止。</p></li></ol><p>应用：保存用户状态，比如购物车中添加商品。</p><p>　　<br><strong>Session的机制：</strong><br>　　一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。</p><p>　　当程序需要为某个客户端的请求创建一个session的时候，服务器会首先检查这个客户端的请求中是否包含session标识－session id，如果已包含则说明以前为此客户创建过session，服务器就会根据session id把这个session检索出来使用；</p><p>　　如果客户请求中不包含session id，则为此客户新建一个session并同时生成一个相关联的session id，这个session id将在本次响应中返回给客户端保存。</p><p>　　<br><strong>二者区别：</strong></p><ul><li><p>存储数据量方面：session 能够存储任意的 java 对象，cookie 只能存储 String 类型的对象</p></li><li><p>一个在客户端一个在服务端，因为Cookie在客户端所以可以编辑伪造，不是十分安全</p></li><li><p>Session过多时会消耗服务器资源，大型网站会有专门Session服务器，Cookie存在客户端没问题</p></li><li><p>域的支持范围不一样，比方说<code>a.com</code>的Cookie在<code>a.com</code>下都能用，而<code>www.a.com</code>的Session在<code>api.a.com</code>下都不能用，解决这个问题的办法是<u><em>JSONP跨域请求或者跨域资源共享</em></u>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>Servlet的生命周期</title>
    <link href="https://mlone.top/2018/08/02/Servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://mlone.top/2018/08/02/Servlet的生命周期/</id>
    <published>2018-08-02T13:53:37.000Z</published>
    <updated>2019-05-09T13:55:33.865Z</updated>
    
    <content type="html"><![CDATA[<p></p><p></p><br><a id="more"></a><p></p><p>共四个阶段：</p><p>（1）Servlet被类的加载器ClassLoad加载,</p><p>（2）调用其中的init()方法进行初始化，</p><p>（3）调用其中的响应方法，如doGet()、doPost()</p><p>（4）当请求不会再被调用或者当服务器关闭时，会调用其中的destroy()方法进行销毁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
  </entry>
  
  <entry>
    <title>整数中1出现的次数</title>
    <link href="https://mlone.top/2018/07/21/%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>https://mlone.top/2018/07/21/整数中1出现的次数/</id>
    <published>2018-07-21T13:47:35.000Z</published>
    <updated>2019-05-09T13:49:07.854Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>　　求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><br><a id="more"></a><p></p><p><strong>代码：</strong><br>来源：<a href="https://www.nowcoder.com/profile/448404/codeBookDetail?submissionId=1505827" target="_blank" rel="noopener">https://www.nowcoder.com/profile/448404/codeBookDetail?submissionId=1505827</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123; <span class="comment">//遍历n到1</span></span><br><span class="line">            String str = String.valueOf(n); <span class="comment">//整数转字符串</span></span><br><span class="line">            <span class="keyword">char</span>[] arr = str.toCharArray(); <span class="comment">//字符串转字符数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==<span class="string">'1'</span>)</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;　　求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>把字符串转换成整数</title>
    <link href="https://mlone.top/2018/07/20/%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <id>https://mlone.top/2018/07/20/把字符串转换成整数/</id>
    <published>2018-07-20T13:46:29.000Z</published>
    <updated>2019-05-09T13:47:20.487Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>　　将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><br><a id="more"></a><p></p><p><strong>代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.equals(<span class="string">""</span>) || str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//非空判断</span></span><br><span class="line">        <span class="keyword">char</span>[] cs = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> symbol = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cs[<span class="number">0</span>] == <span class="string">'-'</span>) symbol=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=(cs[<span class="number">0</span>]==<span class="string">'-'</span> || cs[<span class="number">0</span>]==<span class="string">'+'</span>) ? <span class="number">1</span>:<span class="number">0</span>; i&lt;cs.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cs[i]&lt;<span class="string">'0'</span> || cs[i]&gt;<span class="string">'9'</span>) <span class="comment">//if(cs[i]&lt;48 || cs[i]&gt;57)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>)+(res&lt;&lt;<span class="number">3</span>)+(cs[i]&amp;<span class="number">0xf</span>);<span class="comment">//res=res*10+cs[i]-'0';</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 左移是乘以2的次方(res&lt;&lt;1)+(res&lt;&lt;3) = res*2+res*8 = res*10</span></span><br><span class="line"><span class="comment">             * 字符'0'到'9'的ascii值的低4个二进制位刚好就是0到9所以cs[i]&amp;0xf等于cs[i]-'0'。 </span></span><br><span class="line"><span class="comment">             * 位运算会比乘法运算效率高那么一点点点点...</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * ASCII码是7位或8位的，如'0'--&gt;十进制48--&gt;二进制0011 0000</span></span><br><span class="line"><span class="comment">             * 而十六进制等于四位二进制，如0xf--&gt;二进制1111</span></span><br><span class="line"><span class="comment">             * 所以'0' &amp; 0xf == 00110000 &amp; 1111 == 0000 = 十进制0</span></span><br><span class="line"><span class="comment">             * 而'0'-'0' == 48 -48 == 0 （减号两边的字符'0'会先被转换为十进制ascii码值48，然后再做运算）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res*symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;　　将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="https://mlone.top/2018/07/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://mlone.top/2018/07/20/数组中重复的数字/</id>
    <published>2018-07-20T13:41:09.000Z</published>
    <updated>2019-05-09T13:46:14.572Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>　　在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><br><a id="more"></a><p></p><p><strong>代码：</strong></p><p><strong>方式一：</strong>（最愚蠢的做法，类似“不正统的冒泡排序2”）时间复杂度为T=O(n^2)<br>　　<em>从numbers[i] (0&lt;=i&lt;=n-2)开始，分别与余下的numbers[i+1]~ numbers[n-1]进行比对，一旦找到重复的元素，就将其放到duplicate[0]中并返回true，否则返回false。</em><br>　　<em>length为数组numbers的长度（似乎有点多余？）。</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( numbers==<span class="keyword">null</span> || numbers.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//非空判断</span></span><br><span class="line">        length = numbers.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i]==numbers[j])&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>]=numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>方式二：</strong><br>　　将数组元素转换成字符串装进StringBuffer中，然后从首末两端查找同一元素，若找到的两个下标不同，则说明该元素重复。时间复杂度为T=O(n),但是消耗内存空间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">                sb.append(numbers[i] + <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.indexOf(numbers[j]+<span class="string">""</span>) != sb.lastIndexOf(numbers[j]+<span class="string">""</span>))&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[j];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　<br><strong>方式三：</strong>（建议这种）T=O(n)<br>　　题目里写了数组里数字的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志，当一个数字被访问过后将标志位置为true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boolean只占一位，所以还是比较省的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] k = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k[numbers[i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k[numbers[i]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　<br><strong>方式四：</strong>（最机智的解法，但是我没咋明白）T=O(n)<br>　　不需要额外的数组，题目里写了数组里数字的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数 + n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( numbers==<span class="keyword">null</span> || numbers.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = numbers[i];</span><br><span class="line">            <span class="keyword">if</span> (index&gt;=length)  </span><br><span class="line">                index-=length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(numbers[index]&gt;=length)&#123;</span><br><span class="line">                duplication[<span class="number">0</span>]=index;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[index] = numbers[index]+length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;　　在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>字符串的全排列</title>
    <link href="https://mlone.top/2018/07/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>https://mlone.top/2018/07/17/字符串的全排列/</id>
    <published>2018-07-17T13:37:57.000Z</published>
    <updated>2019-05-09T13:40:54.164Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>　　输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><br><a id="more"></a><p></p><p><strong>解析：</strong>基于回溯法思想<br>参考：<a href="https://www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7</a></p><p><img src="/blogImg/5/7.png" alt></p><p>全排列就是从第一个数字起，每个数分别与它后面的数字交换：</p><blockquote><p><em>固定第一个字符，递归取得首位后面的各种字符串组合；</em><br><em>再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合。</em></p></blockquote><p><strong>代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//创建结果集</span></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123; <span class="comment">//参数非空判定</span></span><br><span class="line">            PermutationHelper(str.toCharArray(), <span class="number">0</span>, res);<span class="comment">//扔进参数，一顿操作</span></span><br><span class="line">            Collections.sort(res); <span class="comment">//按字典顺序对结果集进行排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ArrayList)res; <span class="comment">//返回结果集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//操作函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PermutationHelper</span><span class="params">(<span class="keyword">char</span>[] cs, <span class="keyword">int</span> i, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == cs.length - <span class="number">1</span>) &#123; <span class="comment">//递归终止条件，当下标i已经移到char数组的末尾的时候，考虑添加这一组字符串到结果集中</span></span><br><span class="line">            String val = String.valueOf(cs);</span><br><span class="line">            <span class="keyword">if</span> (!list.contains(val)) <span class="comment">//排除结果集中的重复字符串元素</span></span><br><span class="line">                list.add(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//这一段就是“回溯法”</span></span><br><span class="line">            <span class="comment">//递归的思想与栈的入栈和出栈是一样的,某一个状态遇到return结束了之后，会回到被调用的地方继续执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; cs.length; j++) &#123;</span><br><span class="line">                swap(cs, i, j);</span><br><span class="line">                PermutationHelper(cs, i+<span class="number">1</span>, list); <span class="comment">//递归子序列</span></span><br><span class="line">                swap(cs, i, j); <span class="comment">//将元素再调换回来，以免影响下趟循环（j=i+1）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换字符数组中两下标元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] cs, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = cs[i];</span><br><span class="line">        cs[i] = cs[j];</span><br><span class="line">        cs[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;　　输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="排列组合" scheme="https://mlone.top/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>不用加减乘除作加法</title>
    <link href="https://mlone.top/2018/07/17/%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E4%BD%9C%E5%8A%A0%E6%B3%95/"/>
    <id>https://mlone.top/2018/07/17/不用加减乘除作加法/</id>
    <published>2018-07-17T13:15:03.000Z</published>
    <updated>2019-05-09T13:37:22.592Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><br><a id="more"></a><p></p><p><strong>解析：</strong><br>首先看十进制是如何做的： 5+7=12，分三步走：</p><ul><li><p>第一步：相加各位的值，不算进位，得到2。</p></li><li><p>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p></li><li><p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p></li></ul><p>　　<br>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111</p><ul><li><p>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p></li><li><p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p></li><li><p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。<br>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p></li></ul><p>　　<br><strong>代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=num1^num2; <span class="comment">//计算当前位值</span></span><br><span class="line">            num2=(num1&amp;num2)&lt;&lt;<span class="number">1</span>; <span class="comment">//计算进位值</span></span><br><span class="line">            num1=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>递归求前n项和</title>
    <link href="https://mlone.top/2018/07/16/%E9%80%92%E5%BD%92%E6%B1%82%E5%89%8Dn%E9%A1%B9%E5%92%8C/"/>
    <id>https://mlone.top/2018/07/16/递归求前n项和/</id>
    <published>2018-07-16T13:13:33.000Z</published>
    <updated>2019-05-09T13:14:50.546Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>　　求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A ? B:C）</p><br><a id="more"></a><p></p><p><strong>代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n+Sum_Solution(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;　　求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A ? B:C）&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>包含min函数的栈</title>
    <link href="https://mlone.top/2018/07/16/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>https://mlone.top/2018/07/16/包含min函数的栈/</id>
    <published>2018-07-16T13:12:08.000Z</published>
    <updated>2019-05-09T13:13:15.714Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>　　定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）</p><br><a id="more"></a><p></p><p><strong>代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=stack.peek();</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = stack.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            tmp=iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(tmp&lt;min)</span><br><span class="line">                min=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;　　定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>顺时针打印矩阵</title>
    <link href="https://mlone.top/2018/07/15/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>https://mlone.top/2018/07/15/顺时针打印矩阵/</id>
    <published>2018-07-15T13:06:20.000Z</published>
    <updated>2019-05-09T13:11:30.855Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>　　输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><br><a id="more"></a><p></p><p><img src="/blogImg/5/6.png" alt><br>　　<br><strong>代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span>) <span class="comment">//非空判定</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       printOuterRace(matrix, <span class="number">0</span>, <span class="number">0</span>, matrix.length-<span class="number">1</span>, matrix[<span class="number">0</span>].length-<span class="number">1</span>, result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顺时针打印矩阵最外圈元素：右--&gt;下--&gt;左--&gt;上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOuterRace</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> startRow,<span class="keyword">int</span> startCol,<span class="keyword">int</span> endRow,<span class="keyword">int</span> endCol,ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startRow&lt;endRow &amp;&amp; startCol&lt;endCol)&#123; <span class="comment">//（1）多行多列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=startCol; i&lt;=endCol; i++) result.add(matrix[startRow][i]); <span class="comment">//向右输出首行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=startRow+<span class="number">1</span>; i&lt;=endRow-<span class="number">1</span>; i++) result.add(matrix[i][endCol]); <span class="comment">//向下输出尾列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=endCol; i&gt;=startCol; i--) result.add(matrix[endRow][i]); <span class="comment">//向左输出尾行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=endRow-<span class="number">1</span>; i&gt;=startRow+<span class="number">1</span>; i--) result.add(matrix[i][startCol]); <span class="comment">//向上输出首列</span></span><br><span class="line"></span><br><span class="line">            printOuterRace(matrix,startRow+<span class="number">1</span>,startCol+<span class="number">1</span>,endRow-<span class="number">1</span>,endCol-<span class="number">1</span>,result); <span class="comment">//继续打印下一圈元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(startRow==endRow &amp;&amp; startCol&lt;endCol)&#123; <span class="comment">//（2）就一行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=startCol; i&lt;=endCol; i++) result.add(matrix[startRow][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(startRow&lt;endRow &amp;&amp; startCol==endCol)&#123; <span class="comment">//（3）就一列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=startRow; i&lt;=endRow; i++) result.add(matrix[i][startCol]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(startRow==endRow &amp;&amp; startCol==endCol)&#123; <span class="comment">//（4）就一个元素</span></span><br><span class="line">            result.add(matrix[startRow][startCol]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//（5）角标越界</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;　　输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="遍历" scheme="https://mlone.top/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的镜像</title>
    <link href="https://mlone.top/2018/07/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>https://mlone.top/2018/07/14/二叉树的镜像/</id>
    <published>2018-07-14T13:04:31.000Z</published>
    <updated>2019-05-09T13:06:00.695Z</updated>
    
    <content type="html"><![CDATA[<p></p><p>操作给定的二叉树，将其变换为源二叉树的镜像：</p><br><a id="more"></a><p></p><p><img src="/blogImg/5/5.png" alt></p><p><strong>代码：</strong>即是Swap函数的函数递归版<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode temp;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp=root.left;</span><br><span class="line">            root.left=root.right;</span><br><span class="line">            root.right=temp;</span><br><span class="line">          <span class="comment">//  if(root.left!=null)</span></span><br><span class="line">                Mirror(root.left);</span><br><span class="line">          <span class="comment">//  if(root.right!=null)</span></span><br><span class="line">                Mirror(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像：&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
