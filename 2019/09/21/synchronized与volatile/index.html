<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>synchronized与volatile | Easygo_Space</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转自：既生synchronized，何生volatile">
<meta property="og:type" content="article">
<meta property="og:title" content="synchronized与volatile">
<meta property="og:url" content="https://mlone.top/2019/09/21/synchronized与volatile/index.html">
<meta property="og:site_name" content="Easygo_Space">
<meta property="og:description" content="转自：既生synchronized，何生volatile">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/21/2-1.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/21/2-2.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/21/2-3.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/21/2-4.png">
<meta property="og:updated_time" content="2019-09-21T06:54:45.479Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="synchronized与volatile">
<meta name="twitter:description" content="转自：既生synchronized，何生volatile">
<meta name="twitter:image" content="https://mlone.top/blogImg/2019/9/21/2-1.png">
<meta name="twitter:creator" content="@yangdongliu2016">
  
  
    <link rel="icon" href="/images/favicon.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<!-- 网页加载条 -->
<script src="https://neveryu.github.io/js/src/pace.min.js"></script></html>

<body>
<div>
  <div class="container">
    <div id="header">
		
<div class="blog-header">
  <h1 class="blog-title">Easygo_Space</h1>
  
    <p class="blog-description">The quick brown fox jumps over the lazy dog.</p>
  
</div>

		<nav class="navbar">
    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class href="/index.html"><i class="fa fa-home"> home</i></a></li>
        
          <li><a class href="/archives/"><i class="fa fa-archive"> archive</i></a></li>
        
          <li><a class href="/photo/"><i class="fa fa-photo"> photo</i></a></li>
        
          <li><a class href="/top/"><i class="fa fa-signal"> signal</i></a></li>
        
          <li><a class href="/about/"><i class="fa fa-user"> user</i></a></li>
        
          <li><a class href="/atom.xml"><i class="fa fa-rss"> rss</i></a></li>
        
      </ul>
    </div>
</nav>

	</div>
    <div class="row">
		<!-- 文章主题 -->
        <div class="col-sm-8 blog-main">
		  <div class="post-body">
            <article id="post-synchronized与volatile" class="article article-type-post" itemscope itemprop="blogPost">
  <!-- 文章加密 -->
  	
  
  <!-- 文章头部标题 -->
  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      synchronized与volatile
    </h1>
  


  </header>
  <!-- 文章头部元数据 -->
  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2019/09/21/synchronized与volatile/" class="article-date"><time datetime="2019-09-21T06:35:43.000Z" itemprop="datePublished">2019-09-21</time></a>
</div>

    
	| <div class="article-author">Hollis</div>
	
		<a id="enlarge-shrink-view" class="btn"> 扩大/缩小文章视图</a>
	
	
  </div>	
  
  <!-- 文章内容 -->
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
	    <!-- 非首页展示文章全部内容 -->
		<!-- 先显示图片集（在文章md文件的photos属性下添加图片url） -->
		
		  

		
		
        <p>转自：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650124577&amp;idx=1&amp;sn=4f471855e58d2ded0c9044a3a7e9c698&amp;chksm=f36bac00c41c25166ec3ca43e5811984e4977e8cbbd5f14947fb4d0bc9c67b4a80c726699ff2&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1566351934675&amp;sharer_shareid=b7684e8d9c73854311a908ce0138e103#rd" target="_blank" rel="noopener">既生synchronized，何生volatile</a><br><a id="more"></a></p>
<blockquote>
<p>之前的文章中我们介绍过了两个在Java并发编程中比较重要的两个关键字：synchronized和volatile</p>
</blockquote>
<p>简单回顾一下相关内容：</p>
<p>1、Java语言为了解决并发编程中存在的原子性、可见性和有序性问题，提供了一系列和并发处理相关的关键字，比如synchronized、volatile、final、concurren包等。(<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121599&amp;idx=1&amp;sn=42b2cfabfb3057ac6c09026a8b9656cd&amp;chksm=f36bb85ec41c31489e461a53e78f2959f0224c87c312724f420265b70e67e4efdae2331155aa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">再有人问你Java内存模型是什么，就把这篇文章发给他</a>)</p>
<p>2、synchronized通过加锁的方式，使得其在需要原子性、可见性和有序性这三种特性的时候都可以作为其中一种解决方案，看起来是“万能”的。的确，大部分并发控制操作都能使用synchronized来完成。（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121805&amp;idx=1&amp;sn=8aea8c329a018c82a7ebfe80ec604226&amp;chksm=f36bbb6cc41c327acc23d3d7cdf0b785e318d8e970d564ba9ce8b28a1ae6b41499d351497af3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">再有人问你synchronized是什么，就把这篇文章发给他</a>）</p>
<p>3、volatile通过在volatile变量的操作前后插入内存屏障的方式，保证了变量在并发场景下的可见性和有序性。（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121952&amp;idx=1&amp;sn=5fd25ca48e2005379bffae1608027b59&amp;chksm=f36bbbc1c41c32d781ca24cfa3373660516a50f8b89772260ea247bfb89a0e9a215317e509a4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">再有人问你volatile是什么，把这篇文章也发给他</a>）</p>
<p>4、volatile关键字是无法保证原子性的，而synchronized通过monitorenter和monitorexit两个指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，即可保证不会出现CPU时间片在多个线程间切换，即可保证原子性。（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121739&amp;idx=1&amp;sn=7b60f56d408457f34d5fc0b200ed32bb&amp;chksm=f36bbb2ac41c323c000e2a51e76c627d17f4759d3a54c520a073506ef3de0c46e196f11cd287&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Java的并发编程中的多线程问题到底是怎么回事儿</a>）<br>　　<br>　　那么，我们知道，synchronized和volatile两个关键字是Java并发编程中经常用到的两个关键字，而且，通过前面的回顾，我们知道synchronized可以保证并发编程中不会出现原子性、可见性和有序性问题，而volatile只能保证可见性和有序性，那么，<strong>既生synchronized、何生volatile？</strong></p>
<p>　　接下来，本文就来论述一下，为什么Java中已经有了synchronized关键字，还要提供volatile关键字。</p>
<h2 id="1-synchronized的问题"><a href="#1-synchronized的问题" class="headerlink" title="1. synchronized的问题"></a>1. synchronized的问题</h2><p>我们都知道synchronized其实是一种加锁机制，那么既然是锁，天然就具备以下几个缺点：</p>
<h3 id="1、有性能损耗"><a href="#1、有性能损耗" class="headerlink" title="1、有性能损耗"></a><strong>1、有性能损耗</strong></h3><p>　　虽然在JDK 1.6中对synchronized做了很多优化，如如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121186&amp;idx=1&amp;sn=248d37be27d3bbeb103464b2a96a0ae4&amp;chksm=f36bbec3c41c37d59277ac8539a616b65ec44637f341325056e98323e8780e09c6e4f7cc7a85&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解多线程（五）—— Java虚拟机的锁优化技术</a>），但是他毕竟还是一种锁。</p>
<p>　　以上这几种优化，都是尽量想办法避免对Monitor（<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120784&amp;idx=1&amp;sn=3436c978f0d7ab3bb672d03689518902&amp;chksm=f36bbf71c41c36672a3a6a7edebe0b913f2f5cf33d75d594d228f086ec7bdb9e253ab0beeae4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解多线程（四）—— Moniter的实现原理</a>）进行加锁，但是，并不是所有情况都可以优化的，况且就算是经过优化，优化的过程也是有一定的耗时的。</p>
<p>　　所以，无论是使用同步方法还是同步代码块，在同步操作之前还是要进行加锁，同步操作之后需要进行解锁，这个加锁、解锁的过程是要有性能损耗的。</p>
<p>　　关于二者的性能对比，由于虚拟机对锁实行的许多消除和优化，使得我们很难量化这两者之间的性能差距，但是我们可以确定的一个基本原则是：volatile变量的读操作的性能小号普通变量几乎无差别，但是写操作由于需要插入内存屏障所以会慢一些，即便如此，volatile在大多数场景下也比锁的开销要低。</p>
<h3 id="2、产生阻塞"><a href="#2、产生阻塞" class="headerlink" title="2、产生阻塞"></a><strong>2、产生阻塞</strong></h3><p>　　我们在<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120537&amp;idx=1&amp;sn=f56201217c0ca6fde45ee12965b56296&amp;chksm=f36bbc78c41c356ee363367addcdc0b311afb2f9df86a7ee20d21348b3332fd64f273d6028ca&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解多线程（一）——Synchronized的实现原理</a>中介绍过关于synchronize的实现原理，无论是同步方法还是同步代码块，无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的。</p>
<p>　　基于Monitor对象，当多个线程同时访问一段同步代码时，首先会进入Entry Set，当有一个线程获取到对象的锁之后，才能进行The Owner区域，其他线程还会继续在Entry Set等待。并且当某个线程调用了wait方法后，会释放锁并进入Wait Set等待。<br>　　<img src="/blogImg/2019/9/21/2-1.png" alt></p>
<p>　　<span style="color: orange;">所以，synchronize实现的锁本质上是一种阻塞锁，也就是说多个线程要排队访问同一个共享对象。</span></p>
<p>　　而volatile是Java虚拟机提供的一种轻量级同步机制，他是基于内存屏障实现的。说到底，他并不是锁，所以他不会有synchronized带来的阻塞和性能损耗的问题。</p>
<h2 id="2-volatile的附加功能"><a href="#2-volatile的附加功能" class="headerlink" title="2. volatile的附加功能"></a>2. volatile的附加功能</h2><p>　　除了前面我们提到的volatile比synchronized性能好以外，<span style="color: orange;">volatile其实还有一个很好的附加功能，那就是禁止指令重排</span>。</p>
<p>　　我们先来举一个例子，看一下如果只使用synchronized而不使用volatile会发生什么问题，就拿我们比较熟悉的单例模式来看。</p>
<p>　　我们通过双重校验锁的方式实现一个单例，这里不使用volatile关键字：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　以上代码，我们通过使用synchronized对Singleton.class进行加锁，可以保证同一时间只有一个线程可以执行到同步代码块中的内容，也就是说singleton = new Singleton()这个操作只会执行一次，这就是实现了一个单例。</p>
<p>　　<strong>但是，当我们在代码中使用上述单例对象的时候有可能发生空指针异常。这是一个比较诡异的情况。</strong></p>
<p>我们假设Thread1 和 Thread2两个线程同时请求Singleton.getSingleton方法的时候：<br>　　<img src="/blogImg/2019/9/21/2-2.png" alt></p>
<ul>
<li>Step1 ,Thread1执行到第8行，开始进行对象的初始化。</li>
<li>Step2 ,Thread2执行到第5行，判断singleton == null。 </li>
<li>Step3 ,Thread2经过判断发现singleton ！= null，所以执行第12行，返回singleton。 </li>
<li>Step4 ,Thread2拿到singleton对象之后，开始执行后续的操作，比如调用singleton.call()。</li>
</ul>
<p>　　以上过程，看上去并没有什么问题，但是，其实，在Step4，Thread2在调用singleton.call()的时候，是有可能抛出空指针异常的。</p>
<p>　　之所有会有NPE抛出，是因为在Step3，Thread2拿到的singleton对象并不是一个完整的对象。<br>　　<br><strong>什么叫做不完整对象，这个怎么理解呢？</strong></p>
<p>我们这里来先来看一下，<code>singleton = new Singleton();</code>这行代码到底做了什么事情，大致过程如下：</p>
<ul>
<li>1、虚拟机遇到new指令，到常量池定位到这个类的符号引用。 </li>
<li>2、检查符号引用代表的类是否被加载、解析、初始化过。 </li>
<li>3、虚拟机为对象分配内存。 </li>
<li>4、虚拟机将分配到的内存空间都初始化为零值。 </li>
<li>5、虚拟机对对象进行必要的设置。 </li>
<li>6、执行方法，成员变量进行初始化。</li>
<li>7、将对象的引用指向这个内存区域。</li>
</ul>
<p>　　<br>我们把这个过程简化一下，简化成3个步骤：</p>
<ul>
<li>a、JVM为对象分配一块内存M </li>
<li>b、在内存M上为对象进行初始化 </li>
<li>c、将内存M的地址复制给singleton变量</li>
</ul>
<p>如下图：<br>　　<img src="/blogImg/2019/9/21/2-3.png" alt></p>
<p>　　因为将内存的地址赋值给singleton变量是最后一步，所以Thread1在这一步骤执行之前，Thread2在对singleton==null进行判断一直都是true的，那么他会一直阻塞，直到Thread1将这一步骤执行完。<br>　　<br>　　但是，问题就出在以上过程并不是一个原子操作，并且编译器可能会进行重排序，如果以上步骤被重排成：</p>
<ul>
<li>a、JVM为对象分配一块内存M </li>
<li>c、将内存的地址复制给singleton变量 </li>
<li>b、在内存M上为对象进行初始化</li>
</ul>
<p>如下图：<br>　　<img src="/blogImg/2019/9/21/2-4.png" alt></p>
<p>　　这样的话，Thread1会先执行内存分配，在执行变量赋值，最后执行对象的初始化，那么，也就是说，在Thread1还没有为对象进行初始化的时候，Thread2进来判断singleton==null就可能提前得到一个false，则会返回一个不完整的sigleton对象，因为他还未完成初始化操作。</p>
<p>　　这种情况一旦发生，我们拿到了一个不完整的singleton对象，当尝试使用这个对象的时候就极有可能发生NPE异常。<br>　　<br>　　那么，怎么解决这个问题呢？因为指令重排导致了这个问题，那就避免指令重排就行了。</p>
<p>　　所以，volatile就派上用场了，因为<span style="color: orange;">volatile可以避免指令重排</span>。只要将代码改成以下代码，就可以解决这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　对singleton使用volatile约束，保证他的初始化过程不会被指令重排。这样就可以保Thread2 要不然就是拿不到对象，要不然就是拿到一个完整的对象。</p>
<h2 id="3-synchronized的有序性保证呢？"><a href="#3-synchronized的有序性保证呢？" class="headerlink" title="3. synchronized的有序性保证呢？"></a>3. synchronized的有序性保证呢？</h2><p>　　看到这里可能有朋友会问了，说到底上面问题是发生了指令重排，其实还是个有序性的问题，<strong>不是说synchronized是可以保证有序性的么，这里为什么就不行了呢？</strong></p>
<p>　　首先，可以明确的一点是：<span style="color: orange;">synchronized是无法禁止指令重排和处理器优化的。</span>那么他是如何保证的有序性呢？</p>
<p>　　这就要再把有序性的概念扩展一下了。Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。</p>
<p>　　以上这句话也是《深入理解Java虚拟机》中的原句，但是怎么理解呢？周志明并没有详细的解释。这里我简单扩展一下，这其实和as-if-serial语义有关。</p>
<p>　　as-if-serial语义的意思指：不管怎么重排序，单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。</p>
<p>　　这里不对as-if-serial语义详细展开了，<span style="color: orange;">简单说就是，as-if-serial语义保证了单线程中，不管指令怎么重排，最终的执行结果是不能被改变的。</span></p>
<p>　　那么，我们回到刚刚那个双重校验锁的例子，站在单线程的角度，也就是只看Thread1的话，因为编译器会遵守as-if-serial语义，所以这种优化不会有任何问题，对于这个线程的执行结果也不会有任何影响。</p>
<p>　　但是，Thread1内部的指令重排却对Thread2产生了影响。</p>
<p>　　那么，我们可以说，<span style="color: orange;">synchronized保证的有序性是多个线程之间的有序性，即被加锁的内容要按照顺序被多个线程执行。但是其内部的同步代码还是会发生重排序，只不过由于编译器和处理器都遵循as-if-serial语义，所以我们可以认为这些重排序在单线程内部可忽略。</span></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>本文从两方面论述了volatile的重要性以及不可替代性：</p>
<p>　　<strong>一方面是因为synchronized是一种锁机制，存在阻塞问题和性能问题，而volatile并不是锁，所以不存在阻塞和性能问题。</strong></p>
<p>　　另外一方面，因为<strong>volatile借助了内存屏障来帮助其解决可见性和有序性问题，而内存屏障的使用还为其带来了一个禁止指令重排的附件功能，所以在有些场景中是可以避免发生指令重排的问题的。</strong></p>
<p>　　所以，在日后需要做并发控制的时候，如果不涉及到原子性的问题，可以优先考虑使用volatile关键字。</p>

      
    </div>
	
	<!-- 分享按钮和标签显示 -->
    <footer class="article-footer">
      <a data-url="https://mlone.top/2019/09/21/synchronized与volatile/" data-id="ck0wlm40s00bny0v92daguxjp" title="synchronized与volatile" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      

    </footer>
  </div>
  <!-- 页码 -->
  
    <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
    <a href="/2019/09/21/一个TCP连接上面能发多少个HTTP请求/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-angle-double-left pull-left"></i>
      <span class="article-nav-link-title">&nbsp;一个TCP连接上面能发多少个HTTP请求</span>
    </a>
  
  
  
    <a href="/2019/09/21/面试题-MyBatis篇-一/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">面试题|MyBatis篇(一)&nbsp;</span>
      <i class="fa fa-angle-double-right pull-right"></i>
    </a>
  
</ul>


  
</article>

<!-- 自定义添加的文章目录 -->

  <!-- 文章目录 -->
<aside id="article-toc" role="navigation" class="fixed">
	<div id="article-toc-inner">
		<strong class="sidebar-title">
		  <a class="toggleToc btn"><i class="fa fa-list">文章目录</i>
		</a></strong>
		<!-- list_number: false表示目录不自动编号 -->
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-synchronized的问题"><span class="toc-text">1. synchronized的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、有性能损耗"><span class="toc-text">1、有性能损耗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、产生阻塞"><span class="toc-text">2、产生阻塞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-volatile的附加功能"><span class="toc-text">2. volatile的附加功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-synchronized的有序性保证呢？"><span class="toc-text">3. synchronized的有序性保证呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-总结"><span class="toc-text">4. 总结</span></a></li></ol>
	</div>
	<div>
	  
	</div>
</aside> 



	



		  </div>
        </div>
		<!-- 侧边栏 -->
		<div class="col-sm-3 col-sm-offset-1 blog-sidebar">
		  
  <div class="sidebar-module sidebar-module-inset">
  <!--<h4>About</h4>
   <p>Etiam porta <em>sem malesuada magna</em> mollis euismod. Cras mattis consectetur purus sit amet fermentum. Aenean lacinia bibendum nulla sed consectetur.</p>
 -->
   
  <div class="aboutme-name">@Easygo</div>
  <ul class="aboutme-content">
    <li><a href="/archives"><p class="num">159</p><p class="title">文章</p></a></li>
    <li><p class="num">188.3k</p><p class="title">总字数</p></li>
    <li><p class="num" id="run-day"></p><p class="title">运行天数</p></li>
  </ul>
</div>

<script>(function() {
  var created_time = new Date('2018/08/01 00:00:00');
  var now_time = new Date();
  document.getElementById("run-day").textContent = Math.floor((now_time.getTime() - created_time.getTime())/1000/60/60/24);
})();</script>


  <div class="sidebar-module sidebar-module-inset">
	<form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank">
		<input type="text" name="q" maxlength="20" placeholder="Search">
		<input type="hidden" name="sitesearch" value="https://www.mlone.top">
	</form>
</div>



  
	<div class="sidebar-module">
		<div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div>
		<ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/FrameWorks/">FrameWorks</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/">Java</a><span class="sidebar-module-list-count">52</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Linux/">Linux</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Web/">Web</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/分布式/">分布式</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/剑指offer/">剑指offer</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/影视/">影视</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/操作系统/">操作系统</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库/">数据库</a><span class="sidebar-module-list-count">12</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/算法/">算法</a><span class="sidebar-module-list-count">16</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/计算机网络/">计算机网络</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/设计模式/">设计模式</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/随笔/">随笔</a><span class="sidebar-module-list-count">23</span></li></ul>
	</div>   



  
  <div class="sidebar-module">
    <div class="widget-title"><i class="fa fa-star-o"> 标签</i></div>
    <p class="tagcloud">
      <a href="/tags/GC/" style="font-size: 13.75px;">GC</a> <a href="/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/tags/JVM/" style="font-size: 16.25px;">JVM</a> <a href="/tags/RMI/" style="font-size: 10px;">RMI</a> <a href="/tags/STL/" style="font-size: 11.25px;">STL</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 12.5px;">mysql</a> <a href="/tags/sql/" style="font-size: 11.25px;">sql</a> <a href="/tags/事务/" style="font-size: 11.25px;">事务</a> <a href="/tags/分治/" style="font-size: 12.5px;">分治</a> <a href="/tags/动态规划/" style="font-size: 12.5px;">动态规划</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/古诗词/" style="font-size: 18.75px;">古诗词</a> <a href="/tags/多线程/" style="font-size: 17.5px;">多线程</a> <a href="/tags/安卓开发/" style="font-size: 10px;">安卓开发</a> <a href="/tags/序列化/" style="font-size: 10px;">序列化</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/散文/" style="font-size: 10px;">散文</a> <a href="/tags/数据结构/" style="font-size: 17.5px;">数据结构</a> <a href="/tags/查找/" style="font-size: 18.75px;">查找</a> <a href="/tags/电影/" style="font-size: 11.25px;">电影</a> <a href="/tags/线程池/" style="font-size: 11.25px;">线程池</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/贪心/" style="font-size: 11.25px;">贪心</a> <a href="/tags/遍历/" style="font-size: 11.25px;">遍历</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <div class="widget-title"><i class="fa fa-archive"> 归档</i></div>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">九月 2019</a><span class="sidebar-module-list-count">34</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">八月 2019</a><span class="sidebar-module-list-count">15</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">六月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">20</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">14</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div>
    <ul class="sidebar-module-list">
      
        <li class="recent-post">
          <a href="/2019/09/23/使用Java-Faker生成随机数/">使用Java Faker生成随机数</a>
        </li>
      
        <li class="recent-post">
          <a href="/2019/09/23/Java-Optional实例介绍/">Java Optional实例介绍</a>
        </li>
      
        <li class="recent-post">
          <a href="/2019/09/23/面试题：MySQL读写分离/">面试题：MySQL读写分离</a>
        </li>
      
        <li class="recent-post">
          <a href="/2019/09/23/使用类型重构/">使用类型重构</a>
        </li>
      
        <li class="recent-post">
          <a href="/2019/09/23/JVM内存结构面试题十道/">JVM内存结构面试题十道</a>
        </li>
      
    </ul>
  </div>


  
<div class="sidebar-module">
	<div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div>
	<ul></ul>
	<i class="fa fa-paperclip"> <a class="link" href="http://www.netcan666.com/" title="Netcan" target="_blank" rel="external nofollow noopener noreferrer"> &nbsp;Netcan</a></i> 
	<ul></ul>
	<i class="fa fa-paperclip"> <a class="link" href="https://www.codeliu.com/" title="Codetiger" target="_blank" rel="external nofollow noopener noreferrer"> &nbsp;Codetiger</a></i> 
</div>




		</div>
    </div>
	
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018-2019
	  | Easygo_Space
      | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  <!-- 回到顶部 -->
  <a class="show" id="rocket" href="#top"></a>
  
</div>
		


<!-- 改由在\themes\bootstrap-blog\layout\layout.ejs文件中引入jQuery -->
<!--<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>-->

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




</body>
<!-- 扩大/缩小文章视图按钮功能 -->
<style type='text/css'>
  .col-sm-main {
      width: 100%;
  }
  .col-sm-sidebar {
	display: none;
  }
</style>
<script>
  $('#enlarge-shrink-view').click(function(){
	  $('div.col-sm-8.blog-main').toggleClass('col-sm-main');
	  $('div.col-sm-3.col-sm-offset-1.blog-sidebar').toggleClass('col-sm-sidebar');
  });
</script>
</html>
