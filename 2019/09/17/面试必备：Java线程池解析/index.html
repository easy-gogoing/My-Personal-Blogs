<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>面试必备：Java线程池解析 | Easygo_Space</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转自：https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14">
<meta property="og:type" content="article">
<meta property="og:title" content="面试必备：Java线程池解析">
<meta property="og:url" content="https://mlone.top/2019/09/17/面试必备：Java线程池解析/index.html">
<meta property="og:site_name" content="Easygo_Space">
<meta property="og:description" content="转自：https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-1.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-2.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-3.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-4.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-5.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-6.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-7.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-8.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-9.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-10.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-11.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-12.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-13.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-14.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-15.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-16.png">
<meta property="og:image" content="https://mlone.top/blogImg/2019/9/17/3-17.png">
<meta property="og:updated_time" content="2019-09-17T15:08:15.633Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试必备：Java线程池解析">
<meta name="twitter:description" content="转自：https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14">
<meta name="twitter:image" content="https://mlone.top/blogImg/2019/9/17/3-1.png">
<meta name="twitter:creator" content="@yangdongliu2016">
  
  
    <link rel="icon" href="/images/favicon.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<!-- 网页加载条 -->
<script src="https://neveryu.github.io/js/src/pace.min.js"></script></html>

<body>
<div>
  <div class="container">
    <div id="header">
		
<div class="blog-header">
  <h1 class="blog-title">Easygo_Space</h1>
  
    <p class="blog-description">The quick brown fox jumps over the lazy dog.</p>
  
</div>

		<nav class="navbar">
    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class href="/index.html"><i class="fa fa-home"> home</i></a></li>
        
          <li><a class href="/archives/"><i class="fa fa-archive"> archive</i></a></li>
        
          <li><a class href="/photo/"><i class="fa fa-photo"> photo</i></a></li>
        
          <li><a class href="/top/"><i class="fa fa-signal"> signal</i></a></li>
        
          <li><a class href="/about/"><i class="fa fa-user"> user</i></a></li>
        
          <li><a class href="/atom.xml"><i class="fa fa-rss"> rss</i></a></li>
        
      </ul>
    </div>
</nav>

	</div>
    <div class="row">
		<!-- 文章主题 -->
        <div class="col-sm-8 blog-main">
		  <div class="post-body">
            <article id="post-面试必备：Java线程池解析" class="article article-type-post" itemscope itemprop="blogPost">
  <!-- 文章加密 -->
  	
  
  <!-- 文章头部标题 -->
  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      面试必备：Java线程池解析
    </h1>
  


  </header>
  <!-- 文章头部元数据 -->
  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2019/09/17/面试必备：Java线程池解析/" class="article-date"><time datetime="2019-09-17T14:02:24.000Z" itemprop="datePublished">2019-09-17</time></a>
</div>

    | 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>


	| <div class="article-author">Jay_huaxiao</div>
	
		<a id="enlarge-shrink-view" class="btn"> 扩大/缩小文章视图</a>
	
	
  </div>	
  
  <!-- 文章内容 -->
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
	    <!-- 非首页展示文章全部内容 -->
		<!-- 先显示图片集（在文章md文件的photos属性下添加图片url） -->
		
		  

		
		
        <p>转自：<a href="https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14" target="_blank" rel="noopener">https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-14</a><br><a id="more"></a></p>
<h1 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h1><ul>
<li>面试问题1：Java的线程池说一下，各个参数的作用，如何进行的?</li>
<li>面试问题2：按线程池内部机制，当提交新任务时，有哪些异常要考虑。</li>
<li>面试问题3：线程池都有哪几种工作队列？</li>
<li>面试问题4：使用无界队列的线程池会导致内存飙升吗？</li>
<li>面试问题5：说说几种常见的线程池及使用场景?</li>
</ul>
<h1 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h1><p><strong> 线程池：</strong> 简单理解，它就是一个管理线程的池子。</p>
<ul>
<li><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li>
<li><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li>
<li><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li>
</ul>
<h1 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h1><p>　　线程池可以通过ThreadPoolExecutor来创建，我们来看一下它的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">   BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">   RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure></p>
<p>几个核心参数的作用：</p>
<ul>
<li><strong>corePoolSize：</strong> 线程池核心线程数最大值</li>
<li><strong>maximumPoolSize：</strong> 线程池最大线程数大小</li>
<li><strong>keepAliveTime：</strong> 线程池中非核心线程空闲的存活时间大小</li>
<li><strong>unit：</strong> 线程空闲存活时间单位</li>
<li><strong>workQueue：</strong> 存放任务的阻塞队列</li>
<li><strong>threadFactory：</strong> 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li>
<li><strong>handler：</strong>  线城池的饱和策略事件，主要有四种类型。</li>
</ul>
<h1 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h1><h2 id="线程池执行流程，即对应execute-方法："><a href="#线程池执行流程，即对应execute-方法：" class="headerlink" title="线程池执行流程，即对应execute()方法："></a>线程池执行流程，即对应execute()方法：</h2><p>　　<img src="/blogImg/2019/9/17/3-1.png" alt></p>
<ul>
<li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li>
<li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ul>
<h2 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h2><ul>
<li>AbortPolicy(抛出一个异常，默认的)</li>
<li>DiscardPolicy(直接丢弃任务)</li>
<li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li>
<li>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</li>
</ul>
<h2 id="为了形象描述线程池执行，我打个比喻："><a href="#为了形象描述线程池执行，我打个比喻：" class="headerlink" title="为了形象描述线程池执行，我打个比喻："></a>为了形象描述线程池执行，我打个比喻：</h2><ul>
<li><p>核心线程比作公司正式员工</p>
</li>
<li><p>非核心线程比作外包员工</p>
</li>
<li><p>阻塞队列比作需求池</p>
</li>
<li><p>提交任务比作提需求<br>　　<img src="/blogImg/2019/9/17/3-2.png" alt></p>
</li>
<li><p>当产品提个需求，正式员工（核心线程）先接需求（执行任务）</p>
</li>
<li>如果正式员工都有需求在做，即核心线程数已满），产品就把需求先放需求池（阻塞队列）。</li>
<li>如果需求池(阻塞队列)也满了，但是这时候产品继续提需求,怎么办呢？那就请外包（非核心线程）来做。</li>
<li>如果所有员工（最大线程数也满了）都有需求在做了，那就执行拒绝策略。</li>
<li>如果外包员工把需求做完了，它经过一段（keepAliveTime）空闲时间，就离开公司了。</li>
</ul>
<p>　　好的，到这里。<strong>面试问题1-&gt;Java的线程池说一下，各个参数的作用，如何进行的?</strong> 是否已经迎刃而解啦， 我觉得这个问题，回答：<strong>线程池构造函数的corePoolSize,maximumPoolSize等参数，并且能描述清楚线程池的执行流程</strong> 就差不多啦。</p>
<h1 id="线程池异常处理"><a href="#线程池异常处理" class="headerlink" title="线程池异常处理"></a>线程池异常处理</h1><p>　　在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p>
<h2 id="当提交新任务时，异常如何处理"><a href="#当提交新任务时，异常如何处理" class="headerlink" title="当提交新任务时，异常如何处理?"></a>当提交新任务时，异常如何处理?</h2><p>我们先来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    threadPool.submit(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"current thread name"</span> + Thread.currentThread().getName());</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        System.out.print(<span class="string">"result## "</span>+object.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然，这段代码会有异常，我们再来看看执行结果：<br>　　<img src="/blogImg/2019/9/17/3-3.png" alt><br>　　虽然没有结果输出，但是没有抛出异常，所以我们无法感知任务出现了异常，所以需要添加try/catch。如下图：<br>　　<img src="/blogImg/2019/9/17/3-4.png" alt></p>
<p>　　OK，线程的异常处理，<strong>我们可以直接try…catch捕获。</strong>
　</p>
<h2 id="线程池exec-submit-runnable-的执行流程"><a href="#线程池exec-submit-runnable-的执行流程" class="headerlink" title="线程池exec.submit(runnable)的执行流程"></a>线程池exec.submit(runnable)的执行流程</h2><p>　　通过debug上面有异常的submit方法（<strong>建议大家也去debug看一下,图上的每个方法内部是我打断点的地方</strong>），处理有异常submit方法的主要执行流程图：<br>　　<img src="/blogImg/2019/9/17/3-5.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造feature对象</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">       <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">       execute(ftask);</span><br><span class="line">       <span class="keyword">return</span> ftask;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">       <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">   &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//线程池执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">              <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//捕获异常</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)</span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>　　通过以上分析，submit执行的任务，可以通过Future对象的get方法接收抛出的异常，再进行处理。 我们再通过一个demo，看一下Future对象的get方法处理异常的姿势，如下图：<br>　　<img src="/blogImg/2019/9/17/3-6.png" alt></p>
<h2 id="其他两种处理线程池异常方案"><a href="#其他两种处理线程池异常方案" class="headerlink" title="其他两种处理线程池异常方案"></a>其他两种处理线程池异常方案</h2><p>除了以上<strong>1. 在任务代码try/catch捕获异常，2. 通过Future对象的get方法接收抛出的异常，再处理</strong>两种方案外，还有以下两种方案：</p>
<h3 id="3-为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常"><a href="#3-为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常" class="headerlink" title="3. 为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常"></a>3. 为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常</h3><p>我们直接看这样实现的正确姿势：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">1</span>, r -&gt; &#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">    t.setUncaughtExceptionHandler(</span><br><span class="line">            (t1, e) -&gt; &#123;</span><br><span class="line">                System.out.println(t1.getName() + <span class="string">"线程抛出的异常"</span>+e);</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">   &#125;);</span><br><span class="line">threadPool.execute(()-&gt;&#123;</span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    System.out.print(<span class="string">"result## "</span> + object.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-7.png" alt></p>
<h3 id="4-重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用"><a href="#4-重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用" class="headerlink" title="4. 重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用"></a>4. 重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用</h3><p>这是jdk文档的一个demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这可是jdk文档里面给的例子。。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> &amp;&amp; r <span class="keyword">instanceof</span> Future&lt;?&gt;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object result = ((Future&lt;?&gt;) r).get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException ce) &#123;</span><br><span class="line">                t = ce;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException ee) &#123;</span><br><span class="line">                t = ee.getCause();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                Thread.currentThread().interrupt(); <span class="comment">// ignore/reset</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="因此，被问到线程池异常处理，如何回答？"><a href="#因此，被问到线程池异常处理，如何回答？" class="headerlink" title="因此，被问到线程池异常处理，如何回答？"></a>因此，被问到线程池异常处理，如何回答？</h2><p>　　<img src="/blogImg/2019/9/17/3-8.png" alt></p>
<h1 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h1><p><strong>线程池都有哪几种工作队列？</strong></p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>DelayQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>　　ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>　　LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><p>　　DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>　　PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列。</p>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>　　SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。<br>　　<br>　　针对面试题：<strong>线程池都有哪几种工作队列？</strong> 我觉得，<strong>回答以上几种ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue等，说出它们的特点，并结合使用到对应队列的常用线程池(如newFixedThreadPool线程池使用LinkedBlockingQueue)，进行展开阐述，</strong> 就可以啦。　　</p>
<h1 id="几种常用的线程池"><a href="#几种常用的线程池" class="headerlink" title="几种常用的线程池"></a>几种常用的线程池</h1><ul>
<li>newFixedThreadPool (固定数目线程的线程池)</li>
<li>newCachedThreadPool(可缓存线程的线程池)</li>
<li>newSingleThreadExecutor(单线程的线程池)</li>
<li>newScheduledThreadPool(定时及周期执行的线程池)</li>
</ul>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池特点："><a href="#线程池特点：" class="headerlink" title="线程池特点："></a>线程池特点：</h3><ul>
<li>核心线程数和最大线程数大小一样</li>
<li>没有所谓的非空闲时间，即keepAliveTime为0</li>
<li>阻塞队列为无界队列LinkedBlockingQueue</li>
</ul>
<h3 id="工作机制："><a href="#工作机制：" class="headerlink" title="工作机制："></a>工作机制：</h3><p>　　<img src="/blogImg/2019/9/17/3-9.png" alt></p>
<ul>
<li>提交任务</li>
<li>如果线程数少于核心线程，创建核心线程执行任务</li>
<li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li>
<li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li>
</ul>
<h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            executor.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>IDE指定JVM参数：<code>-Xmx8m -Xms8m</code> :<br>　　<img src="/blogImg/2019/9/17/3-10.png" alt></p>
<p>run以上代码，会抛出OOM：<br>　　<img src="/blogImg/2019/9/17/3-11.png" alt></p>
<p>　　<br>因此，<strong>面试题：使用无界队列的线程池会导致内存飙升吗？</strong></p>
<p>答案 <strong>：会的，newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长(比如，上面demo设置了10秒)，会导致队列的任务越积越多，导致机器内存使用不停飙升，</strong> 最终导致OOM。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池特点：-1"><a href="#线程池特点：-1" class="headerlink" title="线程池特点："></a>线程池特点：</h3><ul>
<li>核心线程数为0</li>
<li>最大线程数为Integer.MAX_VALUE</li>
<li>阻塞队列是SynchronousQueue</li>
<li>非核心线程空闲存活时间为60秒</li>
</ul>
<p>　　当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>　　<img src="/blogImg/2019/9/17/3-12.png" alt></p>
<ul>
<li>提交任务</li>
<li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li>
<li>判断是否有空闲线程，如果有，就去取出任务执行。</li>
<li>如果没有空闲线程，就新建一个线程执行。</li>
<li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li>
</ul>
<h3 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-13.png" alt></p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　用于并发执行大量短期的小任务。</p>
<h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池特点"><a href="#线程池特点" class="headerlink" title="线程池特点"></a>线程池特点</h3><ul>
<li>核心线程数为1</li>
<li>最大线程数也为1</li>
<li>阻塞队列是LinkedBlockingQueue</li>
<li>keepAliveTime为0</li>
</ul>
<h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><p>　　<img src="/blogImg/2019/9/17/3-14.png" alt></p>
<ul>
<li>提交任务</li>
<li>线程池是否有一条线程在，如果没有，新建线程执行任务</li>
<li>如果有，讲任务加到阻塞队列</li>
<li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</li>
</ul>
<h3 id="实例代码-2"><a href="#实例代码-2" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">     executor.execute(() -&gt; &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-15.png" alt></p>
<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　适用于串行执行任务的场景，一个任务一个任务地执行。</p>
<h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池特点-1"><a href="#线程池特点-1" class="headerlink" title="线程池特点"></a>线程池特点</h3><ul>
<li>最大线程数为Integer.MAX_VALUE</li>
<li>阻塞队列是DelayedWorkQueue</li>
<li>keepAliveTime为0</li>
<li>scheduleAtFixedRate() ：按某种速率周期执行</li>
<li>scheduleWithFixedDelay()：在某个延迟后执行</li>
</ul>
<h3 id="工作机制-2"><a href="#工作机制-2" class="headerlink" title="工作机制"></a>工作机制</h3><ul>
<li>添加一个任务</li>
<li>线程池中的线程从 DelayQueue 中取任务</li>
<li>线程从 DelayQueue 中获取 time 大于等于当前时间的task</li>
<li>执行完后修改这个 task 的 time 为下次被执行的时间</li>
<li>这个 task 放回DelayQueue队列中</li>
</ul>
<h3 id="实例代码-3"><a href="#实例代码-3" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  创建一个给定初始延迟的间隔性的任务，之后的下次执行时间是上一次任务从执行到结束所需要的时间+* 给定的间隔时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">scheduledExecutorService.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"current Time"</span> + System.currentTimeMillis());</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>　　<img src="/blogImg/2019/9/17/3-16.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  创建一个给定初始延迟的间隔性的任务，之后的每次任务执行时间为 初始延迟 + N * delay(间隔) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"current Time"</span> + System.currentTimeMillis());</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　周期性执行任务的场景，需要限制线程数量的场景</p>
<p>　　回到面试题：<strong>说说几种常见的线程池及使用场景？</strong></p>
<p>　　回答这四种经典线程池 <strong>：newFixedThreadPool，newSingleThreadExecutor，newCachedThreadPool，newScheduledThreadPool，分线程池特点，工作机制，使用场景分开描述，再分析可能存在的问题，比如newFixedThreadPool内存飙升问题</strong> 即可。</p>
<h1 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h1><p>线程池有这几个状态：<br>　　- RUNNING<br>　　- SHUTDOWN<br>　　- STOP<br>　　- TIDYING<br>　　- TERMINATED</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<h2 id="线程池各个状态切换图："><a href="#线程池各个状态切换图：" class="headerlink" title="线程池各个状态切换图："></a>线程池各个状态切换图：</h2><p>　　<img src="/blogImg/2019/9/17/3-17.png" alt></p>
<h3 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h3><ul>
<li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li>
<li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li>
<li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li>
</ul>
<h3 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h3><ul>
<li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li>
<li>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</li>
</ul>
<h3 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h3><ul>
<li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li>
<li>线程池中执行的任务为空,进入TIDYING状态;</li>
</ul>
<h3 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h3><ul>
<li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li>
<li>terminated()执行完毕，进入TERMINATED状态</li>
</ul>
<h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><ul>
<li>该状态表示线程池彻底终止</li>
</ul>
<h1 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h1><ul>
<li>Java线程池异常处理方案：<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F30e488f4e021" target="_blank" rel="noopener">www.jianshu.com/p/30e488f4e…</a></li>
<li>Java线程池  <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.hollischuang.com%2Farchives%2F2888" target="_blank" rel="noopener">www.hollischuang.com/archives/28…</a></li>
<li>关于线程池的面试题 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F9710b899e749" target="_blank" rel="noopener">www.jianshu.com/p/9710b899e…</a></li>
<li>线程池的五种状态 <a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fl_kanglin%2Farticle%2Fdetails%2F57411851" target="_blank" rel="noopener">blog.csdn.net/l_kanglin/a…</a></li>
<li>深入分析java线程池的实现原理 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F87bff5cc8d8c%2F" target="_blank" rel="noopener">www.jianshu.com/p/87bff5cc8…</a></li>
</ul>

      
    </div>
	
	<!-- 分享按钮和标签显示 -->
    <footer class="article-footer">
      <a data-url="https://mlone.top/2019/09/17/面试必备：Java线程池解析/" data-id="ck13c8zh700dksov9fxd9dyeo" title="面试必备：Java线程池解析" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      

    </footer>
  </div>
  <!-- 页码 -->
  
    <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
    <a href="/2019/09/17/count-1-、count-与count-列名-的执行区别/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-angle-double-left pull-left"></i>
      <span class="article-nav-link-title">&nbsp;count(1)、count(*)与count(列名)的执行区别</span>
    </a>
  
  
  
    <a href="/2019/09/18/Linux最常用命令/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">Linux最常用命令&nbsp;</span>
      <i class="fa fa-angle-double-right pull-right"></i>
    </a>
  
</ul>


  
</article>

<!-- 自定义添加的文章目录 -->

  <!-- 文章目录 -->
<aside id="article-toc" role="navigation" class="fixed">
	<div id="article-toc-inner">
		<strong class="sidebar-title">
		  <a class="toggleToc btn"><i class="fa fa-list">文章目录</i>
		</a></strong>
		<!-- list_number: false表示目录不自动编号 -->
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#经典面试题"><span class="toc-text">经典面试题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池概念"><span class="toc-text">线程池概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池的创建"><span class="toc-text">线程池的创建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#任务执行"><span class="toc-text">任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池执行流程，即对应execute-方法："><span class="toc-text">线程池执行流程，即对应execute()方法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四种拒绝策略"><span class="toc-text">四种拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为了形象描述线程池执行，我打个比喻："><span class="toc-text">为了形象描述线程池执行，我打个比喻：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池异常处理"><span class="toc-text">线程池异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#当提交新任务时，异常如何处理"><span class="toc-text">当提交新任务时，异常如何处理?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池exec-submit-runnable-的执行流程"><span class="toc-text">线程池exec.submit(runnable)的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他两种处理线程池异常方案"><span class="toc-text">其他两种处理线程池异常方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常"><span class="toc-text">3. 为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用"><span class="toc-text">4. 重写ThreadPoolExecutor的afterExecute方法，处理传递的异常引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#因此，被问到线程池异常处理，如何回答？"><span class="toc-text">因此，被问到线程池异常处理，如何回答？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池的工作队列"><span class="toc-text">线程池的工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DelayQueue"><span class="toc-text">DelayQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityBlockingQueue"><span class="toc-text">PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronousQueue"><span class="toc-text">SynchronousQueue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#几种常用的线程池"><span class="toc-text">几种常用的线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-text">newFixedThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池特点："><span class="toc-text">线程池特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作机制："><span class="toc-text">工作机制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例代码"><span class="toc-text">实例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-text">newCachedThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池特点：-1"><span class="toc-text">线程池特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作机制"><span class="toc-text">工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例代码-1"><span class="toc-text">实例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-1"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-text">newSingleThreadExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池特点"><span class="toc-text">线程池特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作机制-1"><span class="toc-text">工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例代码-2"><span class="toc-text">实例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-2"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newScheduledThreadPool"><span class="toc-text">newScheduledThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池特点-1"><span class="toc-text">线程池特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作机制-2"><span class="toc-text">工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例代码-3"><span class="toc-text">实例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景-3"><span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池状态"><span class="toc-text">线程池状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池各个状态切换图："><span class="toc-text">线程池各个状态切换图：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RUNNING"><span class="toc-text">RUNNING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHUTDOWN"><span class="toc-text">SHUTDOWN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STOP"><span class="toc-text">STOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIDYING"><span class="toc-text">TIDYING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TERMINATED"><span class="toc-text">TERMINATED</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考与感谢"><span class="toc-text">参考与感谢</span></a></li></ol>
	</div>
	<div>
	  
	</div>
</aside> 



	



		  </div>
        </div>
		<!-- 侧边栏 -->
		<div class="col-sm-3 col-sm-offset-1 blog-sidebar">
		  
  <div class="sidebar-module sidebar-module-inset">
  <!--<h4>About</h4>
   <p>Etiam porta <em>sem malesuada magna</em> mollis euismod. Cras mattis consectetur purus sit amet fermentum. Aenean lacinia bibendum nulla sed consectetur.</p>
 -->
   
  <div class="aboutme-name">@Easygo</div>
  <ul class="aboutme-content">
    <li><a href="/archives"><p class="num">162</p><p class="title">文章</p></a></li>
    <li><p class="num">199.2k</p><p class="title">总字数</p></li>
    <li><p class="num" id="run-day"></p><p class="title">运行天数</p></li>
  </ul>
</div>

<script>(function() {
  var created_time = new Date('2018/08/01 00:00:00');
  var now_time = new Date();
  document.getElementById("run-day").textContent = Math.floor((now_time.getTime() - created_time.getTime())/1000/60/60/24);
})();</script>


  <div class="sidebar-module sidebar-module-inset">
	<form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank">
		<input type="text" name="q" maxlength="20" placeholder="Search">
		<input type="hidden" name="sitesearch" value="https://www.mlone.top">
	</form>
</div>



  
	<div class="sidebar-module">
		<div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div>
		<ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/FrameWorks/">FrameWorks</a><span class="sidebar-module-list-count">7</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Java/">Java</a><span class="sidebar-module-list-count">54</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Linux/">Linux</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Web/">Web</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/分布式/">分布式</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/剑指offer/">剑指offer</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/影视/">影视</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/操作系统/">操作系统</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/数据库/">数据库</a><span class="sidebar-module-list-count">12</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/算法/">算法</a><span class="sidebar-module-list-count">16</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/计算机网络/">计算机网络</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/设计模式/">设计模式</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/随笔/">随笔</a><span class="sidebar-module-list-count">23</span></li></ul>
	</div>   



  
  <div class="sidebar-module">
    <div class="widget-title"><i class="fa fa-star-o"> 标签</i></div>
    <p class="tagcloud">
      <a href="/tags/GC/" style="font-size: 13.75px;">GC</a> <a href="/tags/JDBC/" style="font-size: 10px;">JDBC</a> <a href="/tags/JVM/" style="font-size: 16.25px;">JVM</a> <a href="/tags/RMI/" style="font-size: 10px;">RMI</a> <a href="/tags/STL/" style="font-size: 11.25px;">STL</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 12.5px;">mysql</a> <a href="/tags/sql/" style="font-size: 11.25px;">sql</a> <a href="/tags/事务/" style="font-size: 11.25px;">事务</a> <a href="/tags/分治/" style="font-size: 12.5px;">分治</a> <a href="/tags/动态规划/" style="font-size: 12.5px;">动态规划</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/古诗词/" style="font-size: 18.75px;">古诗词</a> <a href="/tags/多线程/" style="font-size: 17.5px;">多线程</a> <a href="/tags/安卓开发/" style="font-size: 10px;">安卓开发</a> <a href="/tags/序列化/" style="font-size: 10px;">序列化</a> <a href="/tags/排列组合/" style="font-size: 10px;">排列组合</a> <a href="/tags/排序/" style="font-size: 15px;">排序</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/散文/" style="font-size: 10px;">散文</a> <a href="/tags/数据结构/" style="font-size: 17.5px;">数据结构</a> <a href="/tags/查找/" style="font-size: 18.75px;">查找</a> <a href="/tags/电影/" style="font-size: 11.25px;">电影</a> <a href="/tags/线程池/" style="font-size: 11.25px;">线程池</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/贪心/" style="font-size: 11.25px;">贪心</a> <a href="/tags/遍历/" style="font-size: 11.25px;">遍历</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <div class="widget-title"><i class="fa fa-archive"> 归档</i></div>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">九月 2019</a><span class="sidebar-module-list-count">37</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">八月 2019</a><span class="sidebar-module-list-count">15</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/06/">六月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">27</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">17</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">20</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">14</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div>
    <ul class="sidebar-module-list">
      
        <li class="recent-post">
          <a href="/2019/09/28/反射—Java高级开发必须懂的/">反射—Java高级开发必须懂的</a>
        </li>
      
        <li class="recent-post">
          <a href="/2019/09/28/Java-SFTP传输文件实例/">Java SFTP传输文件实例</a>
        </li>
      
        <li class="recent-post">
          <a href="/2019/09/24/java高并发面试题/">java高并发面试题</a>
        </li>
      
        <li class="recent-post">
          <a href="/2019/09/23/使用Java-Faker生成随机数/">使用Java Faker生成随机数</a>
        </li>
      
        <li class="recent-post">
          <a href="/2019/09/23/Java-Optional实例介绍/">Java Optional实例介绍</a>
        </li>
      
    </ul>
  </div>


  
<div class="sidebar-module">
	<div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div>
	<ul></ul>
	<i class="fa fa-paperclip"> <a class="link" href="http://www.netcan666.com/" title="Netcan" target="_blank" rel="external nofollow noopener noreferrer"> &nbsp;Netcan</a></i> 
	<ul></ul>
	<i class="fa fa-paperclip"> <a class="link" href="https://www.codeliu.com/" title="Codetiger" target="_blank" rel="external nofollow noopener noreferrer"> &nbsp;Codetiger</a></i> 
</div>




		</div>
    </div>
	
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018-2019
	  | Easygo_Space
      | Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  <!-- 回到顶部 -->
  <a class="show" id="rocket" href="#top"></a>
  
</div>
		


<!-- 改由在\themes\bootstrap-blog\layout\layout.ejs文件中引入jQuery -->
<!--<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>-->

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




</body>
<!-- 扩大/缩小文章视图按钮功能 -->
<style type='text/css'>
  .col-sm-main {
      width: 100%;
  }
  .col-sm-sidebar {
	display: none;
  }
</style>
<script>
  $('#enlarge-shrink-view').click(function(){
	  $('div.col-sm-8.blog-main').toggleClass('col-sm-main');
	  $('div.col-sm-3.col-sm-offset-1.blog-sidebar').toggleClass('col-sm-sidebar');
  });
</script>
</html>
